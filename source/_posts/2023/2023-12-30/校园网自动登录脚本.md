---
title: 校园网自动登录脚本
tags:
  - python
  - spider
categories:
  - spider
  - python
keywords: 'python, spider'
description: 校园网自动登录脚本
abbrlink: 49674
date: 2023-12-30 17:21:30
---

# 校园网自动登录脚本

## 1. 开发原因

1. 组内的服务器联网存在一些问题，总是自动断网
2. 手动联网比较缓慢，而且有时还容易失败
3. 服务器联网对于安装依赖，安装软件等都是非常关键的

## 2. 实现方法

### 2.1 使用 selenium 模拟登录[^2]

> 这种方法比较简单，而且成功的概率很大，基本就是`所见即所得`，能够看得到的页面都可以使用这种方法进行模拟登录
>
> 优点就是：代码简单，逻辑清晰，所见即所得
>
> 缺点就是：需要一些软件的配合，如果网站的页面发生改变需要重新写代码

**参考代码如下**：

```python
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.by import By
import time
import subprocess


def spider():
    driver = webdriver.Edge()
    driver.get('登录的网址')  # 这里输入你的校园网登录网址
    time.sleep(1)
    #input_tag = driver.find_element(By.XPATH, "//input[@type='text' and @name='username' and @id='username' and @class='from-control']")  # 通过xpath确定账号框位置
    input_tag = driver.find_element(By.XPATH, "//input[ @type='text' and @name='username' and @id='username' and @id='username']")
    input_tag.send_keys("你自己的账户")  # 输入账号
    input_tag2 = driver.find_element(By.XPATH, "//input[ @type='password' and @name='password' and  @id='password']")  # 通过xpath确定密码框位置
    input_tag2.send_keys("你自己的密码")  # 输入密码
    input_tag2.send_keys(Keys.ENTER)  # 敲一下回车
    time.sleep(1)
    input_tag3 = driver.find_element(By.XPATH, "//button[@class='btn btn-block btn-primary' and @id='login' and @type='button']")  # 找到开通网络按钮
    input_tag3.send_keys(Keys.ENTER)  # 敲一下回车
    time.sleep(1)  # 1秒后自动关闭浏览器


# 测试网络是否连通
def Ping():
    backinfo = subprocess.call('ping www.zhihu.com -n 1', shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                               stderr=subprocess.PIPE)
    if backinfo:
        print('网络未连接')
        return 1
    else:
        print("有网")
        return 2


if __name__ == '__main__':
    spider()
    print("连接网络中·····")
    connection = Ping()
    if connection == 2:
        print("ping")
    elif connection == 1:
        spider()
    exit()
```



### 2.2 使用 requests 请求登录接口[^1][^2]

> 这种方法比较困难，而且成功的概率不大，需要一些技术手段找到网站后端的接口，然后破解后端的加密方法才能使用
>
> 优点就是：不需要其他软件的配合，执行速度快，执行效率高，不依赖网站的界面，网站界面修改后还能使用
>
> 缺点就是：需要一些JavaScript相关的知识，找到后端的接口，破解后端的加密方法，代码复杂，逻辑复杂

**参考代码如下**：

```python
# -*-coding: Utf-8 -*-
# @Packages: auto_srun-master
# @File : AutoLogin.py
# @Author: David
# @Date: 2023/12/30 15:07
# @Software: PyCharm
import hashlib
import hmac
import logging
import math
import re
import time
from logging import Logger
from typing import List

import requests


def get_logger(is_log_to_file=False) -> Logger:
    """
    获取日志输出对象
    :param is_log_to_file: 是否输出到日志文件中
    :return:
    """
    # 1、创建一个logger
    log_obj = logging.getLogger(__name__)
    log_obj.setLevel(logging.DEBUG)

    # 2、定义handler的输出格式（formatter）
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    # 3. 创建一个handler，用于输出到控制台
    ch = logging.StreamHandler()
    ch.setLevel(logging.INFO)  # 设置日志输出的等级
    ch.setFormatter(formatter)  # 设置日志输出格式
    log_obj.addHandler(ch)  # 将 handler 添加到 log_obj 中

    if is_log_to_file:
        # 4. 创建一个handler，用于写入日志文件
        fh = logging.FileHandler('auto_login.log')
        fh.setLevel(logging.DEBUG)  # 设置日志输出的等级
        fh.setFormatter(formatter)  # 设置日志输出格式
        log_obj.addHandler(fh)  # 将 handler 添加到 log_obj 中

    return log_obj


def logger_message(message_key: str, message_value: object, level: str = 'info') -> None:
    """
    输出日志
    :param message_key:
    :param message_value:
    :param level:
    :return:
    """
    message = f"{message_key} >> {message_value}\n"
    if level == 'info':
        logger.info(message)
    elif level == 'debug':
        logger.info(message)
    else:
        logger.critical(message)


def get_byte(s: str, i: int) -> int:
    x = ord(s[i])
    if x > 255:
        exit(0)
    return x


def get_base64(s: str) -> str:
    """
    base64 编码器
    :param s:
    :return:
    """
    pad_char = "="
    alpha = "LVoJPiCN2R8G90yg+hmFHuacZ1OWMnrsSTXkYpUq/3dlbfKwv6xztjI7DeBE45QA"
    res = []
    imax = len(s) - len(s) % 3
    if len(s) == 0:
        return s
    for i in range(0, imax, 3):
        b10 = (get_byte(s, i) << 16) | (get_byte(s, i + 1) << 8) | get_byte(s, i + 2)
        res.append(alpha[(b10 >> 18)])
        res.append(alpha[((b10 >> 12) & 63)])
        res.append(alpha[((b10 >> 6) & 63)])
        res.append(alpha[(b10 & 63)])
    i = imax
    if len(s) - imax == 1:
        b10 = get_byte(s, i) << 16
        res.append(alpha[(b10 >> 18)] + alpha[((b10 >> 12) & 63)] + pad_char + pad_char)
    else:
        b10 = (get_byte(s, i) << 16) | (get_byte(s, i + 1) << 8)
        res.append(alpha[(b10 >> 18)] + alpha[((b10 >> 12) & 63)] + alpha[((b10 >> 6) & 63)] + pad_char)
    return "".join(res)


def get_md5(password: str, token: str) -> str:
    """
    md5 编码器
    :param password:
    :param token:
    :return:
    """
    return hmac.new(token.encode(), password.encode(), hashlib.md5).hexdigest()


def get_sha1(value: str) -> str:
    """
    sha1 编码器
    :param value:
    :return:
    """
    return hashlib.sha1(value.encode()).hexdigest()


def force(msg) -> bytes:
    ret = []
    for w in msg:
        ret.append(ord(w))
    return bytes(ret)


def ordat(msg: List[str], idx: int) -> int:
    if len(msg) > idx:
        return ord(msg[idx])
    return 0


def str_encode(msg, key: bool) -> list[int]:
    """
    编码器
    :param msg:
    :param key:
    :return:
    """
    length = len(msg)
    pwd = []
    for i in range(0, length, 4):
        pwd.append(
            ordat(msg, i) | ordat(msg, i + 1) << 8 | ordat(msg, i + 2) << 16
            | ordat(msg, i + 3) << 24)
    if key:
        pwd.append(length)
    return pwd


def lencode(msg, key: bool) -> str:
    """
    编码器
    :param msg:
    :param key:
    :return:
    """
    length = len(msg)
    ll = (length - 1) << 2
    if key:
        m = msg[length - 1]
        if m < ll - 3 or m > ll:
            return ""
        ll = m
    for i in range(0, length):
        msg[i] = chr(msg[i] & 0xff) + chr(msg[i] >> 8 & 0xff) + chr(
            msg[i] >> 16 & 0xff) + chr(msg[i] >> 24 & 0xff)
    if key:
        return "".join(msg)[0:ll]
    return "".join(msg)


def get_x_encode(msg: str, key: str) -> str:
    """
    自定义编码器
    :param msg:
    :param key:
    :return:
    """
    if msg == "":
        return ""
    pwd = str_encode(msg, True)
    pwdk = str_encode(key, False)
    if len(pwdk) < 4:
        pwdk = pwdk + [0] * (4 - len(pwdk))
    n = len(pwd) - 1
    z = pwd[n]
    c = 0x86014019 | 0x183639A0
    q = math.floor(6 + 52 / (n + 1))
    d = 0
    while 0 < q:
        d = d + c & (0x8CE0D9BF | 0x731F2640)
        e = d >> 2 & 3
        p = 0
        while p < n:
            y = pwd[p + 1]
            m = z >> 5 ^ y << 2
            m = m + ((y >> 3 ^ z << 4) ^ (d ^ y))
            m = m + (pwdk[(p & 3) ^ e] ^ z)
            pwd[p] = pwd[p] + m & (0xEFB8D130 | 0x10472ECF)
            z = pwd[p]
            p = p + 1
        y = pwd[0]
        m = z >> 5 ^ y << 2
        m = m + ((y >> 3 ^ z << 4) ^ (d ^ y))
        m = m + (pwdk[(p & 3) ^ e] ^ z)
        pwd[n] = pwd[n] + m & (0xBB390742 | 0x44C6F8BD)
        z = pwd[n]
        q = q - 1
    return lencode(pwd, False)


def get_check_sum(token: str, username: str, hmd5: str, ac_id: str, ip: str, n: str, type_str: str, info: str) -> str:
    """
    获取校验str
    :param token:
    :param username:
    :param hmd5:
    :param ac_id:
    :param ip:
    :param n:
    :param type_str:
    :param info:
    :return:
    """
    check_str = f"{token}{username}{token}{hmd5}{token}{ac_id}{token}{ip}{token}{n}{token}{type_str}{token}{info}"
    logger_message(message_key="check str", message_value=check_str, level="info")
    return check_str


def get_info(username: str, password: str, ip: str, ac_id: str, enc: str) -> str:
    """
    获取 info
    :param username:
    :param password:
    :param ip:
    :param ac_id:
    :param enc:
    :return:
    """
    info_temp = {
        "username": username,
        "password": password,
        "ip": ip,
        "acid": ac_id,
        "enc_ver": enc
    }
    info = re.sub("'", '"', str(info_temp))
    info = re.sub(" ", '', info)
    logger_message(message_key="info", message_value=info, level="info")
    return info


def init_get_ip(base_url: str, headers: dict) -> str:
    """
    获取 ip
    :param base_url:
    :param headers:
    :return:
    """
    init_res = requests.get(base_url, headers=headers)
    ip = re.search('id="user_ip" value="(.*?)"', init_res.text).group(1)
    logger_message(message_key="ip", message_value=ip, level="info")
    return ip


def get_token(username: str, ip: str, get_challenge_url: str, headers: dict) -> str:
    get_challenge_params = {
        "callback": "jQuery112404953340710317169_" + str(int(time.time() * 1000)),
        "username": username,
        "ip": ip,
        "_": int(time.time() * 1000),
    }
    get_challenge_res = requests.get(get_challenge_url, params=get_challenge_params, headers=headers)
    token = re.search('"challenge":"(.*?)"', get_challenge_res.text).group(1)
    logger_message(message_key="params", message_value=get_challenge_params, level="info")
    logger_message(message_key="token", message_value=token, level="info")
    return token


def do_login(
        username: str,
        hmd5: str,
        ac_id: str,
        ip: str,
        check_sum: str,
        info: str,
        n: str,
        type_str: str,
        srun_portal_url: str,
        headers: dict
) -> str:
    srun_portal_params = {
        'callback': 'jQuery11240645308969735664_' + str(int(time.time() * 1000)),
        'action': 'login',
        'username': username,
        'password': '{MD5}' + hmd5,
        'ac_id': ac_id,
        'ip': ip,
        'chksum': check_sum,
        'info': info,
        'n': n,
        'type': type_str,
        'os': 'Windows 10',
        'name': 'Windows',
        'double_stack': '1',
        '_': int(time.time() * 1000)
    }
    srun_portal_res = requests.get(srun_portal_url, params=srun_portal_params, headers=headers)
    logger_message(message_key="params", message_value=srun_portal_params, level="info")
    logger_message(message_key="response", message_value=srun_portal_res.text, level="info")
    return srun_portal_res.text


def main(config: dict) -> None:
    """
    主程序
    :param config: 配置文件
    :return:
    """
    ip = init_get_ip(base_url=config['base_url'], headers=config['headers'])
    token = get_token(
        username=config['username'],
        ip=ip,
        get_challenge_url=config["get_challenge_url"],
        headers=config['headers']
    )
    info = get_info(
        username=config['username'],
        password=config['password'],
        ip=ip,
        ac_id=config["ac_id"],
        enc=config["enc"]
    )

    info = "{SRBX1}" + get_base64(s=get_x_encode(msg=info, key=token))
    hmd5 = get_md5(password=config['password'], token=token)

    check_sum = get_check_sum(
        token=token,
        username=config['username'],
        hmd5=hmd5,
        ac_id=config["ac_id"],
        ip=ip,
        n=config["n"],
        type_str=config["type"],
        info=info
    )
    check_sum = get_sha1(check_sum)

    do_login(
        username=config['username'],
        hmd5=hmd5,
        ac_id=config["ac_id"],
        ip=ip,
        check_sum=check_sum,
        info=info,
        n=config["n"],
        type_str=config["type"],
        srun_portal_url=config["srun_portal_url"],
        headers=config['headers']
    )
    res = requests.get(config["get_info_url"], headers=config['headers'])
    logger_message(message_key="response", message_value=res.text, level="info")


def get_config() -> dict:
    """
    获取全局配置文件
    :return: 配置文件
    """
    config = {
        "username": "你的校园网账号",
        "password": "你的校园网密码",
        "headers": {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.26 Safari/537.36"
        },
        # "base_url": "http://192.168.0.1/cgi-bin",
        "base_url": "校园网的基础地址，参考上面的链接",
        "n": "200",
        "type": "1",
        "ac_id": "4",
        "enc": "srun_bx1",
    }
    config["get_challenge_url"] = f"{config['base_url']}/get_challenge"
    config["srun_portal_url"] = f"{config['base_url']}/srun_portal"
    get_info_url = f"{config['base_url']}/rad_user_info?callback=jQuery112406118340540763985_1556004912581&_=1556004912582"
    config["get_info_url"] = get_info_url
    logger_message(message_key="config", message_value=config, level="info")
    return config


if __name__ == "__main__":
    logger = get_logger()
    cfg = get_config()
    main(config=cfg)

```

## 使用 requests 方式代码解析

> 本文借鉴了 `校园网自动登录Python版` [^1]博主的思路，基于该博主的代码进行了改进，博主的源码路径：[Gitee](https://gitee.com/yshbcom/auto_srun)

> 首先，获取初始化的 `ip` 这是你在局域网中的`ip`地址，该地址隐藏在登录的界面中，具体的情况需要具体的分析。获取`ip`的代码如下：

```python
def init_get_ip(base_url: str, headers: dict) -> str:
    """
    获取 ip
    :param base_url:
    :param headers:
    :return:
    """
    init_res = requests.get(base_url, headers=headers)
    ip = re.search('id="user_ip" value="(.*?)"', init_res.text).group(1)
    logger_message(message_key="ip", message_value=ip, level="info")
    return ip
```

> 其次，获得登录时需要的`token`令牌，获取令牌时需要上一步获取到的`ip`才行，这是你登录时候的验证令牌，获取登录令牌的代码如下：

```python
def get_token(username: str, ip: str, get_challenge_url: str, headers: dict) -> str:
    get_challenge_params = {
        "callback": "jQuery112404953340710317169_" + str(int(time.time() * 1000)),
        "username": username,
        "ip": ip,
        "_": int(time.time() * 1000),
    }
    get_challenge_res = requests.get(get_challenge_url, params=get_challenge_params, headers=headers)
    token = re.search('"challenge":"(.*?)"', get_challenge_res.text).group(1)
    logger_message(message_key="params", message_value=get_challenge_params, level="info")
    logger_message(message_key="token", message_value=token, level="info")
    return token
```

> 之后，需要获取你的登录信息，通过`username`，`password`，`ip`获取认证信息，获取认证信息的代码如下：

```python
def get_info(username: str, password: str, ip: str, ac_id: str, enc: str) -> str:
    """
    获取 info
    :param username:
    :param password:
    :param ip:
    :param ac_id:
    :param enc:
    :return:
    """
    info_temp = {
        "username": username,
        "password": password,
        "ip": ip,
        "acid": ac_id,
        "enc_ver": enc
    }
    info = re.sub("'", '"', str(info_temp))
    info = re.sub(" ", '', info)
    logger_message(message_key="info", message_value=info, level="info")
    return info

```

> 之后，获取登录时的校验和，校验和使用sha1算法加密，获取校验和的代码如下：

```python
def get_check_sum(token: str, username: str, hmd5: str, ac_id: str, ip: str, n: str, type_str: str, info: str) -> str:
    """
    获取校验str
    :param token:
    :param username:
    :param hmd5:
    :param ac_id:
    :param ip:
    :param n:
    :param type_str:
    :param info:
    :return:
    """
    check_str = f"{token}{username}{token}{hmd5}{token}{ac_id}{token}{ip}{token}{n}{token}{type_str}{token}{info}"
    logger_message(message_key="check str", message_value=check_str, level="info")
    return check_str

```

>  最后，将上述所有的信息统一放入登录接口的参数中，即可完成登录的联网的功能，具体登录的方法代码如下：

```python
def do_login(
        username: str,
        hmd5: str,
        ac_id: str,
        ip: str,
        check_sum: str,
        info: str,
        n: str,
        type_str: str,
        srun_portal_url: str,
        headers: dict
) -> str:
    srun_portal_params = {
        'callback': 'jQuery11240645308969735664_' + str(int(time.time() * 1000)),
        'action': 'login',
        'username': username,
        'password': '{MD5}' + hmd5,
        'ac_id': ac_id,
        'ip': ip,
        'chksum': check_sum,
        'info': info,
        'n': n,
        'type': type_str,
        'os': 'Windows 10',
        'name': 'Windows',
        'double_stack': '1',
        '_': int(time.time() * 1000)
    }
    srun_portal_res = requests.get(srun_portal_url, params=srun_portal_params, headers=headers)
    logger_message(message_key="params", message_value=srun_portal_params, level="info")
    logger_message(message_key="response", message_value=srun_portal_res.text, level="info")
    return srun_portal_res.text

```

> 总结：使用 `requests `方式需要清楚的了解后端的接口参数，已经参数使用何种方式进行加密，这需要一定的``JavaScript``能力，所以相比于使用 `selenium `方法更加的复杂，逻辑也更加的复杂。但是使用 `requests `代码的效率更高，对于网站的界面没有依赖，所以网站界面修改后也可以使用，泛化能力较强。

## 3. 参考链接

[^1]:[校园网自动登录Python版_深澜软件校园网自动登录-CSDN博客](https://blog.csdn.net/qq_20534023/article/details/124159181)
[^2]:[【python】自动登录中科大校园网_中科大统一身份登录脚本-CSDN博客](https://blog.csdn.net/qq_39534909/article/details/131523646)

