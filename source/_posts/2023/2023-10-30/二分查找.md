---
title: 二分查找
layout: post
tags:
  - 算法
  - LeetCode
categories:
  - 算法
  - LeetCode
lang: zh-CN
abbrlink: 42877
date: 2023-10-30 15:16:46
---

# 二分查找

## 二分查找的概念

> 一些网站对于二分查找的解释
>
> 1. [百度百科](https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE)：二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求[线性表](https://baike.baidu.com/item/线性表/3228081?fromModule=lemma_inlink)必须采用[顺序存储结构](https://baike.baidu.com/item/顺序存储结构/1347176?fromModule=lemma_inlink)，而且表中元素按关键字有序排列。
>
> 2. [菜鸟教程](https://www.runoob.com/python3/python-binary-search.html)：二分搜索是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。
>
>    ![binary search](https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/Binary_search_into_array.png)
>
> 3. [wikipedia](https://zh.wikipedia.org/zh-hans/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95)：在[计算机科学](https://zh.wikipedia.org/wiki/计算机科学)中，**二分查找算法**（英语：binary search algorithm），也称**折半搜索算法**（英语：half-interval search algorithm）[[1\]](https://zh.wikipedia.org/zh-hans/二分搜尋演算法#cite_note-1)、**对数搜索算法**（英语：logarithmic search algorithm）[[2\]](https://zh.wikipedia.org/zh-hans/二分搜尋演算法#cite_note-FOOTNOTEKnuth1998§6.2.1_("Searching_an_ordered_table"),_subsection_"Binary_search"-2)，是一种在[有序数组](https://zh.wikipedia.org/wiki/有序数对)中查找某一特定元素的搜索[算法](https://zh.wikipedia.org/wiki/算法)。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。

> 我的一些理解：
>
> 1. 二分查找，又称折半查找或者对数搜索等等。目的是从有序的数组中快速的找出目标值(target)
> 2. 所以从上面的定义中我们知道，二分查找是一种搜索算法，并且要求数组是有序的(从大到小或者从小到大都行)
> 3. 二分查找的`时间复杂度`通常的 `O(log n)`，`空间复杂度`通常是 `O(1)`
> 4. `一般在题目中出现数组有序，或者数组可以进行排序时使用。能够极大的提高查找的效率。`

> 网友的看法： `关键不在于区间里的元素具有什么性质，而是区间外面的元素具有什么性质。`
>
> 也就是看最终左右指针会停在哪里。
> 如果我们要找第一个大于等于x的位置，那么我就假设L最终会停在第一个大于等于x的位置，R停在L的左边。
> 这样按照上面那句话，可以把循环不变式描述为“L的左边恒小于x，R的右边恒大于等于x”，这样一来，其他的各种条件就不言自明了。
> 比如循环条件肯定是L小于R，因为我假设R停在L的左边。
> 而L和R转移的时候，根据循环不变式，如果mid小于x，肯定要令L等于mid+1，如果大于等于x，就令R等于mid-1。
> 至于初始的时候L和R怎么选，也是看循环不变式，只需要保证初始L和R的选择满足“L的左边恒小于x，R的右边恒大于等于x”，并且不会出现越界的情况即可，L必为0，因为0左边可以看作负无穷，恒小于x，R取第一个一定满足条件的（防止mid取到非法值），例如n-1（n开始可以看作正无穷，恒大于等于x，如果保证x在数组里可以选择n-2，其实大于等于n也满足不变式，但是mid可能会取非法值），而且这样一来即使是搜索数组的某一段，也可以很方便根据这个条件地找到初始位置。
>
> 如果假设L最终会停在第一个大于等于x的位置，R停在L的位置，那么循环不变式就是“L的左边恒小于x，R以及R的右边恒大于等于x”，这样的话，循环条件就是L等于R的时候退出；转移的时候R=mid；初始时，一般取R=n（如果保证x在数组里，也可以取n-1）。
>
> 其他的情况也类似，比较直观的推导方法就是在要找的位置的分界处（比如在第一个大于等于x的位置后面）画一条线，然后假定L和R最终会停在这条线的左边还是右边，接着倒推各种条件即可。

## 二分查找的相关题目

### [题目：275. H 指数 II - 力扣（LeetCode）](https://leetcode.cn/problems/h-index-ii/description/)

#### 1. 题目要求：

![题目要求](https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20231030155054847.png)



#### 2. 问题分析：

首先，题目中有两个关键点让我们知道这题需要使用`二分查找`来解决

1. 题目中提到`citations`是有序的
2. 题目要求在对数时间复杂度内解决问题

这两点就可以确定，这题只能使用`二分查找`来解决。

具体的题目分析如下：

![lc275-c.png](https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/1698492370-tnIhCf-lc275-c.png)



#### 3. 问题解决：

根据视频 [二分查找 红蓝染色法 - 哔哩哔哩 (bilibili.com)](https://www.bilibili.com/video/BV1AP41137w7/) 我们可以知道，二分查找存在三种写法以及四种情况。

三种写法分别是：

1. 闭区间
2. 半开半闭区间
3. 开区间

四种情况分别是：

1. 大于等于(≥)
2. 大于(＞)
3. 小于等于(≤)
4. 小于(＜)

其中四种情况可以相互进行转化，具体的转化方式可以参考上面提到的视频中 [如何处理不是≥的情况](https://www.bilibili.com/video/BV1AP41137w7?t=580.7) 部分。下面将使用三种不同的写法，解决这道题目。

##### 1. 闭区间

`Python `代码如下：

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        # 在区间 [left, right] 内询问
        left = 1
        right = len(citations)
        while left <= right:  # 区间不为空
            # 循环不变量：
            # left-1 的回答一定为「是」
            # right+1 的回答一定为「否」
            mid = (left + right) // 2
            # 引用次数最多的 mid 篇论文，引用次数均 >= mid
            if citations[-mid] >= mid:
                left = mid + 1  # 询问范围缩小到 [mid+1, right]
            else:
                right = mid - 1  # 询问范围缩小到 [left, mid-1]
        # 循环结束后 right 等于 left-1，回答一定为「是」
        # 根据循环不变量，right 现在是最大的回答为「是」的数
        return right
    
```



##### 2. 半开半闭区间

###### 1. 左闭右开区间写法

`Python `代码如下：

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        # 在区间 [left, right) 内询问
        left = 1
        right = len(citations) + 1
        while left < right:  # 区间不为空
            # 循环不变量：
            # left-1 的回答一定为「是」
            # right 的回答一定为「否」
            mid = (left + right) // 2
            # 引用次数最多的 mid 篇论文，引用次数均 >= mid
            if citations[-mid] >= mid:
                left = mid + 1  # 询问范围缩小到 [mid+1, right)
            else:
                right = mid  # 询问范围缩小到 [left, mid)
        # 根据循环不变量，left-1 现在是最大的回答为「是」的数
        return left - 1
    
```

###### 2. 左开右闭区间写法

`Python `代码如下：

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        # 在区间 (left, right] 内询问
        left = 0
        right = len(citations)
        while left < right:  # 区间不为空
            # 循环不变量：
            # left 的回答一定为「是」
            # right+1 的回答一定为「否」
            mid = (left + right + 1) // 2  # 保证 mid 在二分区间内
            # 引用次数最多的 mid 篇论文，引用次数均 >= mid
            if citations[-mid] >= mid:
                left = mid  # 询问范围缩小到 (mid, right]
            else:
                right = mid - 1  # 询问范围缩小到 (left, mid-1]
        # 根据循环不变量，left 现在是最大的回答为「是」的数
        return left
    
```



##### 3. 开区间

`Python `代码如下：

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        # 在区间 (left, right) 内询问
        left = 0
        right = len(citations) + 1
        while left + 1 < right:  # 区间不为空
            # 循环不变量：
            # left 的回答一定为「是」
            # right 的回答一定为「否」
            mid = (left + right) // 2
            # 引用次数最多的 mid 篇论文，引用次数均 >= mid
            if citations[-mid] >= mid:
                left = mid  # 询问范围缩小到 (mid, right)
            else:
                right = mid  # 询问范围缩小到 (left, mid)
        # 根据循环不变量，left 现在是最大的回答为「是」的数
        return left

```

详细的题解可以参考：[275. H 指数 II - 力扣（LeetCode）](https://leetcode.cn/problems/h-index-ii/solutions/2504326/tu-jie-yi-tu-zhang-wo-er-fen-da-an-si-ch-d15k/)



### [题目：34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

#### 1. 题目要求：

![题目要求](https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20231030205656237.png)

#### 2. 问题分析：

1. 数组 `nums ` 是有序的，有序的数组就可以考虑使用二分查找的方法
2. 问题的要求是找到第一个和最后一个元素，所以可以使用二分查找方法，快速定位问题中的要求的位置

具体的问题分析可以查看 [二分查找 红蓝染色法](https://www.bilibili.com/video/BV1AP41137w7)



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python
# -*-coding: Utf-8 -*-
# @Packages: leetcode-daily-algorithm-challenge
# @File : __init__.py.py
# @Author: David
# @Date: 2023/10/29 14:36
# @Software: PyCharm


def lower_bound(arr: List[int], target: int) -> int:
    """
    下界(lower bound)函数, 闭区间写法
    找到第一个大于等于 target 元素的下标
    问题分析
        循环不变量:
            left 的左边全部都是小于 target 的元素
            right 右边全部都是大于等于 target 的元素
        最后的结果会是 right + 1 = left, 所以既可以返回 left, 也可以返回 right + 1
    :param arr:
    :param target:
    :return:
    """
    left, right = 0, len(arr) - 1  # 搜索的范围 [left, right]
    while left <= right:  # 如果区间不为空
        mid = left + (right - left) // 2  # 这种写法可以避免 (right + left) // 2 导致的溢出问题
        if arr[mid] >= target:
            right = mid - 1  # 收缩右边界
        else:
            left = mid + 1  # 收缩左边界
    return left  # 返回结果

class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        start = lower_bound(nums, target)
        if start == len(nums) or nums[start] != target:
            return [-1, -1]
        end = lower_bound(nums, target + 1) - 1
        return [start, end]
```



##### 2. 半开半闭区间

###### 1. 左闭右开区间写法

`Python `代码如下：

```python
# -*-coding: Utf-8 -*-
# @Packages: leetcode-daily-algorithm-challenge
# @File : __init__.py.py
# @Author: David
# @Date: 2023/10/29 14:36
# @Software: PyCharm


def lower_bound(arr: List[int], target: int) -> int:
    """
    下界(lower bound)函数, 左闭右开区间写法
    找到第一个大于等于 target 元素的下标
    问题分析
        循环不变量:
            left 的左边全部都是小于 target 的元素
            right 右边全部都是大于等于 target 的元素
        最后的结果会是 right = left, 所以既可以返回 left, 也可以返回 right
    :param arr:
    :param target:
    :return:
    """
    left, right = 0, len(arr)  # 搜索的范围 [left, right)
    while left < right:  # 如果区间不为空
        mid = left + (right - left) // 2  # 这种写法可以避免 (right + left) // 2 导致的溢出问题
        if arr[mid] >= target:
            right = mid  # 收缩右边界
        else:
            left = mid + 1  # 收缩左边界
    return left  # 返回结果

class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        start = lower_bound(nums, target)
        if start == len(nums) or nums[start] != target:
            return [-1, -1]
        end = lower_bound(nums, target + 1) - 1
        return [start, end]
```

###### 2. 左闭右开区间写法

`Python `代码如下：

```python
# -*-coding: Utf-8 -*-
# @Packages: leetcode-daily-algorithm-challenge
# @File : __init__.py.py
# @Author: David
# @Date: 2023/10/29 14:36
# @Software: PyCharm


def lower_bound(arr: List[int], target: int) -> int:
    """
    下界(lower bound)函数, 左闭右开区间写法
    找到第一个大于等于 target 元素的下标
    问题分析
        循环不变量:
            left 的左边全部都是小于 target 的元素
            right 右边全部都是大于等于 target 的元素
        最后的结果会是 (right - 1) + 1 = left, 所以既可以返回 left, 也可以返回 right
    :param arr:
    :param target:
    :return:
    """
    left, right = 0, len(arr)  # 搜索的范围 [left, right)
    while left <= right - 1:  # 如果区间不为空
        mid = left + ((right - 1) - left) // 2  # 这种写法可以避免 (right + left) // 2 导致的溢出问题
        if arr[mid] >= target:
            right = mid  # 收缩右边界
        else:
            left = mid + 1  # 收缩左边界
    return left  # 返回结果

class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        start = lower_bound(nums, target)
        if start == len(nums) or nums[start] != target:
            return [-1, -1]
        end = lower_bound(nums, target + 1) - 1
        return [start, end]
```

###### 3. 左开右闭区间写法

```python
# -*-coding: Utf-8 -*-
# @Packages: leetcode-daily-algorithm-challenge
# @File : __init__.py.py
# @Author: David
# @Date: 2023/10/29 14:36
# @Software: PyCharm


def lower_bound(arr: List[int], target: int) -> int:
    """
    下界(lower bound)函数, 左开右闭区间写法
    找到第一个大于等于 target 元素的下标
    问题分析
        循环不变量:
            left 的左边全部都是小于 target 的元素
            right 右边全部都是大于等于 target 的元素
        最后的结果会是 right + 1 = left + 1, 所以既可以返回 right + 1, 也可以返回 left + 1
    :param arr:
    :param target:
    :return:
    """
    left, right = -1, len(arr) - 1  # 搜索的范围 (left, right]
    while left + 1 <= right:  # 如果区间不为空
        mid = (left + 1) + (right - (left + 1)) // 2  # 这种写法可以避免 (right + left) // 2 导致的溢出问题
        if arr[mid] >= target:
            right = mid - 1  # 收缩右边界
        else:
            left = mid  # 收缩左边界
    return left + 1  # 返回结果

class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        start = lower_bound(nums, target)
        if start == len(nums) or nums[start] != target:
            return [-1, -1]
        end = lower_bound(nums, target + 1) - 1
        return [start, end]
```



##### 3. 开区间

`Python `代码如下：

```python
    # -*-coding: Utf-8 -*-
# @Packages: leetcode-daily-algorithm-challenge
# @File : __init__.py.py
# @Author: David
# @Date: 2023/10/29 14:36
# @Software: PyCharm


def lower_bound(arr: List[int], target: int) -> int:
    """
    下界(lower bound)函数, 开区间写法
    找到第一个大于等于 target 元素的下标
    问题分析
        循环不变量:
            left 的左边全部都是小于 target 的元素
            right 右边全部都是大于等于 target 的元素
        最后的结果会是 right = left + 1, 所以既可以返回 right, 也可以返回 left + 1
    :param arr:
    :param target:
    :return:
    """
    left, right = -1, len(arr)  # 搜索的范围 [left, right]
    while left + 1 <= right - 1:  # 如果区间不为空
        mid = (left + 1) + ((right - 1) - (left + 1)) // 2  # 这种写法可以避免 (right + left) // 2 导致的溢出问题
        if arr[mid] >= target:
            right = mid  # 收缩右边界
        else:
            left = mid  # 收缩左边界
    return left + 1  # 返回结果

class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        start = lower_bound(nums, target)
        if start == len(nums) or nums[start] != target:
            return [-1, -1]
        end = lower_bound(nums, target + 1) - 1
        return [start, end]
```



### 题目：[1283. 使结果不超过阈值的最小除数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/description/)

#### 1. 题目要求：

![image-20231103161142018](https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20231103161142018.png)

####  2. 问题分析：

1. 求解最大化最小值问题，数组`nums`的顺序可以是有序的也可以是无序的。
2. 阈值`threshold`的取值范围是`[nums.length, 10^6]`我们需要求解的答案是是的除数之和小于等于阈值的最小正整数
3. 通过分析得知，我们除数越大，得到的`商的和`越小，越能够满足题目的条件，但是题目要求除数`最小`，所以得到的`商最大`，这就是典型的最大化最小值问题
4. 我们可以在`[1, 10^6]`范围内找到需要求的正整数，且`越靠近右边，得到的商越小`，越能够满足商的和小于`threshold`的要求。并且答案的取值范围天然的有序，所以我们可以使用二分查找的方式求解问题。

#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python
def divide(a, b):
    return math.ceil(a / b)

class Solution:
    """
    最小化最大值类型：
        给你一个整数数组 nums 和一个正整数 threshold  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。
        请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。
        每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。 题目保证一定有解。
    """

    def smallestDivisor(self, nums: List[int], threshold: int) -> int:
        """
        最小化最大值问题，使用二分法求解：
        1. 先将数组从小到达排序
        2. 循环不变量:
            1. left 的左边都是满足题目要求小于等于阈值的正整数, 但是除数之和从大到小进行排序
            2. right 的右边都是不满足题目条件的正整数
        :param nums:
        :param threshold:
        :return:
        """
        left, right = 1, 10 ** 6
        while left <= right:
            mid = (left + right) // 2
            if sum(divide(num, mid) for num in nums) > threshold:
                left = mid + 1
            else:
                right = mid - 1
        return left
```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python
def lower_bound(nums: List[int], threshold: int) -> int:
    """
        最小化最大值问题，使用二分法求解, 左开右闭区间写法：
        1. 循环不变量:
            1. left 的左边都是满足题目要求小于等于阈值的正整数, 但是除数之和从大到小进行排序
            2. right 的右边都是不满足题目条件的正整数
        最终的结果是 left + 1 = right + 1 所以返回 left + 1 或者 right + 1 都行
        :param nums:
        :param threshold:
        :return:
    """
    left, right = 0, 10 ** 6
    while left + 1 <= right:
        mid = (left + right + 1) // 2
        if sum(math.ceil(num / mid) for num in nums) > threshold:
            left = mid
        else:
            right = mid - 1
    return left + 1

class Solution:
    """
    最小化最大值类型：
        给你一个整数数组 nums 和一个正整数 threshold  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。
        请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。
        每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。 题目保证一定有解。
    """

    def smallestDivisor(self, nums: List[int], threshold: int) -> int:
        return lower_bound(nums, threshold)
```

###### 2. 左闭右开区间

`Python `代码如下：

```python
def lower_bound(nums: List[int], threshold: int) -> int:
    """
        最小化最大值问题，使用二分法求解, 左闭右开区间写法：
        1. 循环不变量:
            1. left 的左边都是满足题目要求小于等于阈值的正整数, 但是除数之和从大到小进行排序
            2. right 的右边都是不满足题目条件的正整数
        最终的结果是 left = right + 2 所以返回 left 或者 right + 2 都行
        :param nums:
        :param threshold:
        :return:
    """
    left, right = 1, 10 ** 6 + 1
    while left <= right + 1:
        mid = (left + right + 1) // 2
        if sum(math.ceil(num / mid) for num in nums) > threshold:
            left = mid + 1
        else:
            right = mid - 2
    return left

class Solution:
    """
    最小化最大值类型：
        给你一个整数数组 nums 和一个正整数 threshold  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。
        请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。
        每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。 题目保证一定有解。
    """

    def smallestDivisor(self, nums: List[int], threshold: int) -> int:
        return lower_bound(nums, threshold)
```

##### 3. 开区间

`Python `代码如下：

```python
def lower_bound(nums: List[int], threshold: int) -> int:
    """
        最小化最大值问题，使用二分法求解, 开区间写法：
        1. 循环不变量:
            1. left 的左边都是满足题目要求小于等于阈值的正整数, 但是除数之和从大到小进行排序
            2. right 的右边都是不满足题目条件的正整数
        最终的结果是 left + 1 = (right - 1) + 1 所以返回 left + 1 或者 right + 1 都行
        :param nums:
        :param threshold:
        :return:
    """
    left, right = 0, 10 ** 6 + 1
    while left + 1 <= right - 1:
        mid = (left + right) // 2
        if sum(math.ceil(num / mid) for num in nums) > threshold:
            left = mid
        else:
            right = mid
    return left + 1

class Solution:
    """
    最小化最大值类型：
        给你一个整数数组 nums 和一个正整数 threshold  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。
        请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。
        每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。 题目保证一定有解。
    """

    def smallestDivisor(self, nums: List[int], threshold: int) -> int:
        return lower_bound(nums, threshold)
```



### 题目：[2187. 完成旅途的最少时间 (leetcode.cn)](https://leetcode.cn/problems/minimum-time-to-complete-trips/)

#### 1. 题目要求：

![image-20231103162536304](https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20231103162536304.png)

#### 2. 问题分析：

1. 求解最大化最小值问题，花费时间越长，能够完成的最大旅行次数越多，我们需要求解的是能够完成 `totalTrips`次旅途花费最少的时间。
2. 设花费的最少时间为`t`，则 `t` 的取值范围是: `[1, time[-1] * totalTrips]` 其中`time`已经从小到大排序
3. 所以我们知道答案`t`的取值范围天然是有序的，可以使用二分查找的方法求解。

#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python
def lower_bound(time: List[int], totalTrips: int) -> int:
    """
    最大化最小值，使用二分法求解，闭区间写法
    循环不变量:
        1. left 的左边的所有值都不满足题目的要求, 即 t = left 时刻不能完成 totalTrips 次旅途
        2. right 的右边的所有值都满足题目的要求, 即 t = right 时刻可以完成 totalTrips 次旅途
    :param time:
    :param totalTrips:
    :return:
    """
    if len(time) < 2:
        return time[0] * totalTrips
    time.sort()
    left, right = 1, time[-1] * totalTrips
    while left <= right:  # 区间不为空, 搜索的区间为: [left, right]
        mid = left + (right - left) // 2
        max_trips = sum(mid // t for t in time)
        if max_trips >= totalTrips:
            right = mid - 1
        else:
            left = mid + 1
    return left

class Solution:
    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        return lower_bound(time, totalTrips)
```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python
def lower_bound(time: List[int], totalTrips: int) -> int:
    """
    最大化最小值，使用二分法求解，左开右闭区间写法
    循环不变量:
        1. left 的左边的所有值都不满足题目的要求, 即 t = left 时刻不能完成 totalTrips 次旅途
        2. right 的右边的所有值都满足题目的要求, 即 t = right 时刻可以完成 totalTrips 次旅途
    最终的结果 left + 1 = right + 1, 所以既可以返回 left + 1, 也可以返回 right + 1
    :param time:
    :param totalTrips:
    :return:
    """
    if len(time) < 2:
        return time[0] * totalTrips
    time.sort()
    left, right = 0, time[-1] * totalTrips
    while left + 1 <= right:  # 区间不为空, 搜索的区间为: (left, right]
        mid = left + 1 + (right - left - 1) // 2
        max_trips = sum(mid // t for t in time)
        if max_trips >= totalTrips:
            right = mid - 1
        else:
            left = mid
    return left + 1

class Solution:
    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        return lower_bound(time, totalTrips)
```

###### 2. 左闭右开区间

`Python `代码如下：

```python
def lower_bound(time: List[int], totalTrips: int) -> int:
    """
    最大化最小值，使用二分法求解，左闭右开区间写法
    循环不变量:
        1. left 的左边的所有值都不满足题目的要求, 即 t = left 时刻不能完成 totalTrips 次旅途
        2. right 的右边的所有值都满足题目的要求, 即 t = right 时刻可以完成 totalTrips 次旅途
    最终的结果 left = (right - 1) + 1, 所以既可以返回 left, 也可以返回 right
    :param time:
    :param totalTrips:
    :return:
    """
    if len(time) < 2:
        return time[0] * totalTrips
    time.sort()
    left, right = 1, time[-1] * totalTrips + 1
    while left <= right - 1:  # 区间不为空, 搜索的区间为: [left, right)
        mid = left + (right - 1 - left) // 2
        max_trips = sum(mid // t for t in time)
        if max_trips >= totalTrips:
            right = mid
        else:
            left = mid + 1
    return left

class Solution:
    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        return lower_bound(time, totalTrips)
```

##### 3. 开区间

`Python `代码如下：

```python
def lower_bound(time: List[int], totalTrips: int) -> int:
    """
    最大化最小值，使用二分法求解，开区间写法
    循环不变量:
        1. left 的左边的所有值都不满足题目的要求, 即 t = left 时刻不能完成 totalTrips 次旅途
        2. right 的右边的所有值都满足题目的要求, 即 t = right 时刻可以完成 totalTrips 次旅途
    最终的结果 left + 1 = (right - 1) + 1, 所以既可以返回 left + 1, 也可以返回 right
    :param time:
    :param totalTrips:
    :return:
    """
    if len(time) < 2:
        return time[0] * totalTrips
    time.sort()
    left, right = 0, time[-1] * totalTrips + 1
    while left + 1 <= right - 1:  # 区间不为空, 搜索的区间为: (left, right)
        mid = (right + left) // 2
        max_trips = sum(mid // t for t in time)
        if max_trips >= totalTrips:
            right = mid
        else:
            left = mid
    return right

class Solution:
    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        return lower_bound(time, totalTrips)
```



### 题目：[2226. 每个小孩最多能分到多少糖果 (leetcode.cn)](https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/)

#### 1. 题目要求：

![image-20231216154151715](https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20231216154151715.png)

#### 2. 问题分析：

1. 求解最大值问题，题目要求的要求是：
   - 每个小孩拿到的糖果数量相同
   - 每个小孩拿到的糖果数量尽量最大
   - 每堆糖果只能拆分不能合并
2. 根据题目的要求，我们可以使用二分的方式求解(==**注：**== 一般遇到求最大值 or 最小值的问题，尽量使用二分法求解，这样时间复杂度会比较小)
3. 我们枚举每个小孩能够拿到的最多的糖果数量，记作：`x`， `x` 的取值范围是`[1， max(candies)]` 
4. 每次枚举中间值 `mid` 的时候，需要判断中间值 `mid` 是否能够满足题目的要求。 

==**注：**== 代码中使用的 `mid` 表示想要分配给每个小孩的糖果数量，`cnt` 表示`candies`能够分配给`cnt`个小孩数量为`mid` 的糖果

#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python
def lower_bound(candies: List[int], k: int) -> int:
    """
    求最大值问题, 使用二分法求解, 闭区间写法
    循环不变量：
        1. left 的左边的所有值都能满足题目的要求, 即 res = left 时 k 个小孩肯定能够拿到 left 颗糖果
        2. right 的右边的所有值都不满足题目的要求, 即 res = right 时, k 个小孩肯定不能能够拿到 right 颗糖果
        left 和 right 都表示 k 个小孩能够拿到的糖果数量, 题目要求所有小孩能够拿到的糖果数量相同并且尽量最大
        所以最后的结果 left = right + 1, 既可以返回 right 也可以返回 left - 1
    :param candies:
    :param k:
    :return:
    """
    left, right = 1, candies[-1]  # 左右边界
    while left <= right:
        cnt, mid = 0, (left + right) >> 1
        for x in candies:
            cnt += x // mid
        if cnt >= k:
            left = mid + 1
        else:
            right = mid - 1
    return left - 1

class Solution:
    def maximumCandies(self, candies: List[int], k: int) -> int:
        if k > sum(candies):
            return 0  # 特殊情况的判断
        candies.sort()  # 将 candies 数组排序
        return lower_bound(candies, k)
```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python
def lower_bound(candies: List[int], k: int) -> int:
    """
    求最大值问题, 使用二分法求解, 左开右闭区间写法
    循环不变量：
        1. left 的左边的所有值都能满足题目的要求, 即 res = left 时 k 个小孩肯定能够拿到 left 颗糖果
        2. right 的右边的所有值都不满足题目的要求, 即 res = right 时, k 个小孩肯定不能能够拿到 right 颗糖果
        left 和 right 都表示 k 个小孩能够拿到的糖果数量, 题目要求所有小孩能够拿到的糖果数量相同并且尽量最大
        所以最后的结果 left + 1 = right + 1 ==> left = right , 既可以返回 right 也可以返回 left
    :param candies:
    :param k:
    :return:
    """
    left, right = 0, candies[-1]  # 左右边界
    while left + 1 <= right:
        cnt, mid = 0, ((left + 1) + right) >> 1
        for x in candies:
            cnt += x // mid
        if cnt >= k:
            left = mid
        else:
            right = mid - 1
    # return (left + 1) - 1
    return left  # +1 -1 抵消, 直接返回 left

class Solution:
    def maximumCandies(self, candies: List[int], k: int) -> int:
        if k > sum(candies):
            return 0  # 特殊情况的判断
        candies.sort()  # 将 candies 数组排序
        return lower_bound(candies, k)
```

###### 2. 左闭右开区间

`Python `代码如下：

```python
def lower_bound(candies: List[int], k: int) -> int:
    """
    求最大值问题, 使用二分法求解, 左闭右开区间写法
    循环不变量：
        1. left 的左边的所有值都能满足题目的要求, 即 res = left 时 k 个小孩肯定能够拿到 left 颗糖果
        2. right 的右边的所有值都不满足题目的要求, 即 res = right 时, k 个小孩肯定不能能够拿到 right 颗糖果
        left 和 right 都表示 k 个小孩能够拿到的糖果数量, 题目要求所有小孩能够拿到的糖果数量相同并且尽量最大
        所以最后的结果 left = (right - 1) + 1 ==> left = right, 既可以返回 right - 1 也可以返回 left - 1
    :param candies:
    :param k:
    :return:
    """
    left, right = 1, candies[-1] + 1  # 左右边界
    while left <= (right - 1):
        cnt, mid = 0, ((right - 1) + left) >> 1
        for x in candies:
            cnt += x // mid
        if cnt >= k:
            left = mid + 1
        else:
            right = mid
    return left - 1

class Solution:
    def maximumCandies(self, candies: List[int], k: int) -> int:
        if k > sum(candies):
            return 0  # 特殊情况的判断
        candies.sort()  # 将 candies 数组排序
        return lower_bound(candies, k)
```

##### 3. 开区间

`Python `代码如下：

```python
def lower_bound(candies: List[int], k: int) -> int:
    """
    求最大值问题, 使用二分法求解, 开区间写法
    循环不变量：
        1. left 的左边的所有值都能满足题目的要求, 即 res = left 时 k 个小孩肯定能够拿到 left 颗糖果
        2. right 的右边的所有值都不满足题目的要求, 即 res = right 时, k 个小孩肯定不能能够拿到 right 颗糖果
        left 和 right 都表示 k 个小孩能够拿到的糖果数量, 题目要求所有小孩能够拿到的糖果数量相同并且尽量最大
        所以最后的结果 (left + 1) = (right - 1) + 1 ==> left = right - 1, 既可以返回 right 也可以返回 left
    :param candies:
    :param k:
    :return:
    """
    left, right = 0, candies[-1] + 1  # 左右边界
    while left + 1 <= right - 1:
        # cnt, mid = 0, ((left + 1) + (right - 1)) >> 1
        cnt, mid = 0, (left + right) >> 1
        for x in candies:
            cnt += x // mid
        if cnt >= k:
            left = mid
        else:
            right = mid
    # return (left + 1) - 1
    return right - 1

class Solution:
    def maximumCandies(self, candies: List[int], k: int) -> int:
        if k > sum(candies):
            return 0  # 特殊情况的判断
        candies.sort()  # 将 candies 数组排序
        return lower_bound(candies, k)
```



### 题目：[1870. 准时到达的列车最小时速 (leetcode.cn)](https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



## TODO 未完待续 ... 

### 题目：[1011. 在 D 天内送达包裹的能力 (leetcode.cn)](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[875. 爱吃香蕉的珂珂 (leetcode.cn)](https://leetcode.cn/problems/koko-eating-bananas/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[1898. 可移除字符的最大数目 (leetcode.cn)](https://leetcode.cn/problems/maximum-number-of-removable-characters/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[1482. 制作 m 束花所需的最少天数 (leetcode.cn)](https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[1642. 可以到达的最远建筑 (leetcode.cn)](https://leetcode.cn/problems/furthest-building-you-can-reach/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[2258. 逃离火灾 (leetcode.cn)](https://leetcode.cn/problems/escape-the-spreading-fire/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[2064. 分配给商店的最多商品的最小值 (leetcode.cn)](https://leetcode.cn/problems/minimized-maximum-of-products-distributed-to-any-store/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[1760. 袋子里最少数目的球 (leetcode.cn)](https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[2439. 最小化数组中的最大值 (leetcode.cn)](https://leetcode.cn/problems/minimize-maximum-of-array/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[2560. 打家劫舍 IV (leetcode.cn)](https://leetcode.cn/problems/house-robber-iv/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[778. 水位上升的泳池中游泳 (leetcode.cn)](https://leetcode.cn/problems/swim-in-rising-water/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[2616. 最小化数对的最大差值 (leetcode.cn)](https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[2513. 最小化两个数组中的最大值 (leetcode.cn)](https://leetcode.cn/problems/minimize-the-maximum-of-two-arrays/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[1552. 两球之间的磁力 (leetcode.cn)](https://leetcode.cn/problems/magnetic-force-between-two-balls/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[2861. 最大合金数 (leetcode.cn)](https://leetcode.cn/problems/maximum-number-of-alloys/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[2517. 礼盒的最大甜蜜度 (leetcode.cn)](https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[2812. 找出最安全路径 (leetcode.cn)](https://leetcode.cn/problems/find-the-safest-path-in-a-grid/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[2528. 最大化城市的最小供电站数目 (leetcode.cn)](https://leetcode.cn/problems/maximize-the-minimum-powered-city/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[378. 有序矩阵中第 K 小的元素 (leetcode.cn)](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[373. 查找和最小的 K 对数字 (leetcode.cn)](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[719. 找出第 K 小的数对距离 (leetcode.cn)](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[1439. 有序矩阵中的第 k 个最小数组和 (leetcode.cn)](https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[786. 第 K 个最小的素数分数 (leetcode.cn)](https://leetcode.cn/problems/k-th-smallest-prime-fraction/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[2040. 两个有序数组的第 K 小乘积 (leetcode.cn)](https://leetcode.cn/problems/kth-smallest-product-of-two-sorted-arrays/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



### 题目：[2386. 找出数组的第 K 大和 (leetcode.cn)](https://leetcode.cn/problems/find-the-k-sum-of-an-array/)

#### 1. 题目要求：



#### 2. 问题分析：



#### 3. 问题解决：

##### 1. 闭区间

`Python `代码如下：

```python

```

##### 2. 半开半闭区间

###### 1. 左开右闭区间

`Python `代码如下：

```python

```

###### 2. 左闭右开区间

`Python `代码如下：

```python

```

##### 3. 开区间

`Python `代码如下：

```python

```



## 参考资料&链接：

1. [灵茶山艾府的个人空间-灵茶山艾府个人主页-哔哩哔哩视频 (bilibili.com)](https://space.bilibili.com/206214)
2. [EndlessCheng/codeforces-go: 算法竞赛模板库 by 灵茶山艾府 💭💡🎈 (github.com)](https://github.com/EndlessCheng/codeforces-go/tree/master)
3. [二分查找中的循环不变式_二分搜索的循环不变式-CSDN博客](https://blog.csdn.net/groovy2007/article/details/78309120)
4. [二分查找_百度百科 (baidu.com)](https://baike.baidu.com/item/二分查找)
5. [Python 二分查找 | 菜鸟教程 (runoob.com)](https://www.runoob.com/python3/python-binary-search.html)
6. [二分搜寻演算法 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/zh-hans/二分搜尋演算法)
7. [二分查找 红蓝染色法 - 哔哩哔哩 (bilibili.com)](https://www.bilibili.com/video/BV1AP41137w7/)
8. [275. H 指数 II - 力扣（LeetCode）](https://leetcode.cn/problems/h-index-ii/solutions/2504326/tu-jie-yi-tu-zhang-wo-er-fen-da-an-si-ch-d15k/)




---

我的`LeetCode`主页：[熬夜冠军🏆 - 力扣（LeetCode）](https://leetcode.cn/u/david-deng-01/)
