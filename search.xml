<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深度学习代码笔记-01</title>
    <url>//2023/05/05/Deep-Learning-Code-Note/</url>
    <content><![CDATA[<h1 id="深度学习代码笔记-01"><a href="#深度学习代码笔记-01" class="headerlink" title="深度学习代码笔记-01"></a>深度学习代码笔记-01</h1><h2 id="1-配置环境"><a href="#1-配置环境" class="headerlink" title="1. 配置环境"></a>1. 配置环境</h2><h2 id="1-1-Conda"><a href="#1-1-Conda" class="headerlink" title="1.1 Conda"></a>1.1 <code>Conda</code></h2><blockquote>
<p>任选其一（推荐后者）</p>
<ol>
<li><a href="https://repo.anaconda.com/archive/">Anaconda 安装</a></li>
<li><a href="https://docs.conda.io/en/latest/miniconda.html">Miniconda 安装</a></li>
</ol>
</blockquote>
<h2 id="1-2-Conda-常用命令"><a href="#1-2-Conda-常用命令" class="headerlink" title="1.2 Conda 常用命令"></a>1.2 Conda 常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示所有环境</span></span><br><span class="line">conda env list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示当前环境下的包</span></span><br><span class="line">conda list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建conda环境</span></span><br><span class="line">conda create -n 环境名 python=版本号</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除conda环境</span></span><br><span class="line">conda remove -n 环境名 --all</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入conda环境</span></span><br><span class="line">conda activate 环境名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出conda环境</span></span><br><span class="line">conda deactivate</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除缓存</span></span><br><span class="line">conda clean -a -y</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">conda环境导出</span></span><br><span class="line">conda activate 环境名</span><br><span class="line">conda env export &gt; env.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">conda环境迁移</span></span><br><span class="line">conda env create -f env.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">conda国内源</span></span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br></pre></td></tr></table></figure>

<h2 id="1-2-安装Pytorch"><a href="#1-2-安装Pytorch" class="headerlink" title="1.2 安装Pytorch"></a>1.2 安装<code>Pytorch</code></h2><p>官网地址：<a href="https://pytorch.org/">PyTorch</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20230506004259724.png" alt="pythorch.png"></p>
<h2 id="1-分词任务"><a href="#1-分词任务" class="headerlink" title="1. 分词任务"></a>1. 分词任务</h2><h3 id="任务简介："><a href="#任务简介：" class="headerlink" title="任务简介："></a>任务简介：</h3><blockquote>
<p>模型内部是一系列的矩阵运算，只能处理数字。因此倘若需要让模型处理一个句子（比如判断这个句子是积极的，还是消极的），需要先把句子转为一串数字。所以在 NLP 学习中，我们需要先了解怎么将文本进行分词，并将每一个词都转化成对应的词向量。</p>
</blockquote>
<h3 id="任务步骤"><a href="#任务步骤" class="headerlink" title="任务步骤"></a>任务步骤</h3><ol>
<li>安装第三方库<code>pip install numpy nltk transformers</code></li>
<li>下载词向量文件 <code>glove.6B.50d.txt</code>, 下载地址：<a href="https://www.kaggle.com/datasets/watts2/glove6b50dtxt">glove.6B.50d.txt</a></li>
<li>任务目标：将每个词转为词向量</li>
</ol>
<h3 id="Example-1-代码解释"><a href="#Example-1-代码解释" class="headerlink" title="Example 1 代码解释"></a>Example 1 代码解释</h3><ol>
<li><p>首先需要导入需要的第三方依赖</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果没有安装第三方依赖, 请安装</span></span><br><span class="line"><span class="comment"># pip install numpy nltk transformers</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> nltk <span class="keyword">import</span> word_tokenize</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> ndarray</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载词向量文件</p>
<ul>
<li>从<code>glove.6B.50d.txt</code> 文件中按行读取词向量，每次读取一行</li>
<li>按照空格分割每一行的数据</li>
<li>分割得到的列表(list) 第一个元素是单词, 后面所有的元素是单词对应的词向量(vector)</li>
<li>将单词(word)作为 key, 词向量(vector) 作为 value, 存入 result 中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_glove_file</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">List</span>[<span class="built_in">float</span>]]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        读取glove词向量文件, 并将其转换为字典形式</span></span><br><span class="line"><span class="string">        :return:  Dict[str, List[float]], key 为词, value 为词向量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">List</span>[<span class="built_in">float</span>]] = &#123;&#125;</span><br><span class="line">    glove_path = <span class="string">f&quot;<span class="subst">&#123;self.base_path&#125;</span>/<span class="subst">&#123;self.glove_file_name&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;加载词向量文件：<span class="subst">&#123;glove_path&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(glove_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            line: <span class="built_in">str</span> = file.readline()  <span class="comment"># 读取一行</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 如果没有读取成功</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                line_split: <span class="built_in">list</span>[<span class="built_in">str</span>] = line.strip().split()  <span class="comment"># 按空格分割读取的一行数据</span></span><br><span class="line">                word: <span class="built_in">str</span> = line_split[<span class="number">0</span>]  <span class="comment"># 第一个为词，作为 key</span></span><br><span class="line">                vector: <span class="built_in">list</span>[<span class="built_in">float</span>] = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>, line_split[<span class="number">1</span>:]))  <span class="comment"># 除了第一个元素外, 其他元素组成对应的词向量</span></span><br><span class="line">                result[word] = vector  <span class="comment"># 将词作为 key, 向量作为 value, 存入结果中</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</li>
<li><p>将句子转换成对应的词向量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>) -&gt; ndarray:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;原始句子：<span class="subst">&#123;self.sentence&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第一步：分词</span></span><br><span class="line">    tokens: <span class="built_in">list</span>[<span class="built_in">str</span>] = word_tokenize(self.sentence)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;分词结果：<span class="subst">&#123;tokens&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;序列长度：<span class="subst">&#123;<span class="built_in">len</span>(tokens)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第二步：加载glove词向量文件, 提取每个word的词向量</span></span><br><span class="line">    word_to_vector_dict: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">List</span>[<span class="built_in">float</span>]] = self.read_glove_file()</span><br><span class="line">    dimension: <span class="built_in">int</span> = <span class="built_in">len</span>(word_to_vector_dict[<span class="string">&#x27;the&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;词向量的大小：<span class="subst">&#123;<span class="built_in">len</span>(word_to_vector_dict)&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;单词的维度：<span class="subst">&#123;dimension&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    special_token_list: <span class="built_in">list</span>[<span class="built_in">str</span>] = [<span class="string">&#x27;unk&#x27;</span>, <span class="string">&#x27;pad&#x27;</span>, <span class="string">&#x27;cls&#x27;</span>, <span class="string">&#x27;sep&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> sp_token <span class="keyword">in</span> special_token_list:</span><br><span class="line">        <span class="keyword">if</span> sp_token <span class="keyword">not</span> <span class="keyword">in</span> word_to_vector_dict:  <span class="comment"># 如果特殊字符不在词向量文件中</span></span><br><span class="line">            word_to_vector_dict[sp_token] = np.random.random(dimension).tolist()  <span class="comment"># 随机生成一些数字放入词向量文件中,作为特殊字符的词向量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三步：转为词向量</span></span><br><span class="line">    arr = []</span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">        <span class="comment"># 将分词得到的 token 通过词向量表, 转换成对应的词向量</span></span><br><span class="line">        <span class="keyword">if</span> token <span class="keyword">not</span> <span class="keyword">in</span> word_to_vector_dict:</span><br><span class="line">            arr.append(word_to_vector_dict[<span class="string">&#x27;unk&#x27;</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arr.append(word_to_vector_dict[token])</span><br><span class="line"></span><br><span class="line">    vector: ndarray = np.array(arr)  <span class="comment"># 将数组转成 numpy.ndarray</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;数组形状为：<span class="subst">&#123;vector.shape&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回分词的结果</span></span><br><span class="line">    <span class="keyword">return</span> vector</span><br></pre></td></tr></table></figure>

<p><strong><code>操作步骤：</code></strong></p>
<ol>
<li>将句子(sentence)分词, 分成一个一个的单词(word)</li>
<li>将单词(word)通过 <code>word_to_vector_dict</code> 转换成对应的词向量 (vector)</li>
<li>将所有单词(word)的词向量(vector)按照顺序放入 <code>arr</code> 列表中，然后将 <code>arr</code> 数据类型转换成 <code>numpy.ndarray</code></li>
</ol>
</li>
<li><p>完整代码: <code>Example1.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> nltk <span class="keyword">import</span> word_tokenize</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> ndarray</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example1</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 原始的句子</span></span><br><span class="line">        self.sentence = <span class="string">&#x27;Commonsense knowledge and commonsense reasoning play &#x27;</span> \</span><br><span class="line">                        <span class="string">&#x27;a vital role in all aspects of machine intelligence,&#x27;</span> \</span><br><span class="line">                        <span class="string">&#x27;from language understanding to computer vision and &#x27;</span> \</span><br><span class="line">                        <span class="string">&#x27;robotics .&#x27;</span>.lower()</span><br><span class="line">        self.base_path = <span class="string">&quot;Model/glove&quot;</span>  <span class="comment"># 基础路径</span></span><br><span class="line">        self.glove_file_name = <span class="string">&quot;glove.6B.50d.txt&quot;</span>  <span class="comment"># 词向量文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>) -&gt; ndarray:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;原始句子：<span class="subst">&#123;self.sentence&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一步：分词</span></span><br><span class="line">        tokens: <span class="built_in">list</span>[<span class="built_in">str</span>] = word_tokenize(self.sentence)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;分词结果：<span class="subst">&#123;tokens&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;序列长度：<span class="subst">&#123;<span class="built_in">len</span>(tokens)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二步：加载glove词向量文件, 提取每个word的词向量</span></span><br><span class="line">        word_to_vector_dict: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">List</span>[<span class="built_in">float</span>]] = self.read_glove_file()</span><br><span class="line">        dimension: <span class="built_in">int</span> = <span class="built_in">len</span>(word_to_vector_dict[<span class="string">&#x27;the&#x27;</span>])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;词向量的大小：<span class="subst">&#123;<span class="built_in">len</span>(word_to_vector_dict)&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;单词的维度：<span class="subst">&#123;dimension&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        special_token_list: <span class="built_in">list</span>[<span class="built_in">str</span>] = [<span class="string">&#x27;unk&#x27;</span>, <span class="string">&#x27;pad&#x27;</span>, <span class="string">&#x27;cls&#x27;</span>, <span class="string">&#x27;sep&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> sp_token <span class="keyword">in</span> special_token_list:</span><br><span class="line">            <span class="keyword">if</span> sp_token <span class="keyword">not</span> <span class="keyword">in</span> word_to_vector_dict:  <span class="comment"># 如果特殊字符不在词向量文件中</span></span><br><span class="line">                word_to_vector_dict[sp_token] = np.random.random(dimension).tolist()  <span class="comment"># 随机生成一些数字放入词向量文件中,作为特殊字符的词向量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第三步：转为词向量</span></span><br><span class="line">        arr = []</span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="comment"># 将分词得到的 token 通过词向量表, 转换成对应的词向量</span></span><br><span class="line">            <span class="keyword">if</span> token <span class="keyword">not</span> <span class="keyword">in</span> word_to_vector_dict:</span><br><span class="line">                arr.append(word_to_vector_dict[<span class="string">&#x27;unk&#x27;</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                arr.append(word_to_vector_dict[token])</span><br><span class="line"></span><br><span class="line">        vector: ndarray = np.array(arr)  <span class="comment"># 将数组转成 numpy.ndarray</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;数组形状为：<span class="subst">&#123;vector.shape&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回分词的结果</span></span><br><span class="line">        <span class="keyword">return</span> vector</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_glove_file</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">List</span>[<span class="built_in">float</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            读取glove词向量文件, 并将其转换为字典形式</span></span><br><span class="line"><span class="string">            :return:  Dict[str, List[float]], key 为词, value 为词向量</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">List</span>[<span class="built_in">float</span>]] = &#123;&#125;</span><br><span class="line">        glove_path = <span class="string">f&quot;<span class="subst">&#123;self.base_path&#125;</span>/<span class="subst">&#123;self.glove_file_name&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;加载词向量文件：<span class="subst">&#123;glove_path&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(glove_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                line: <span class="built_in">str</span> = file.readline()  <span class="comment"># 读取一行</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">                    <span class="keyword">break</span>  <span class="comment"># 如果没有读取成功</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    line_split: <span class="built_in">list</span>[<span class="built_in">str</span>] = line.strip().split()  <span class="comment"># 按空格分割读取的一行数据</span></span><br><span class="line">                    word: <span class="built_in">str</span> = line_split[<span class="number">0</span>]  <span class="comment"># 第一个为词，作为 key</span></span><br><span class="line">                    vector: <span class="built_in">list</span>[<span class="built_in">float</span>] = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>, line_split[<span class="number">1</span>:]))  <span class="comment"># 除了第一个元素外, 其他元素组成对应的词向量</span></span><br><span class="line">                    result[word] = vector  <span class="comment"># 将词作为 key, 向量作为 value, 存入结果中</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    v = Example1().run()</span><br><span class="line">    <span class="built_in">print</span>(v)</span><br><span class="line"></span><br></pre></td></tr></table></figure>




</li>
</ol>
<p>   <code>代码运行结果：</code></p>
   <img src="img/index/image-20230507233228291.png" alt="image-20230507233228291" style="zoom:100%;" />

<h3 id="Example2-代码解释"><a href="#Example2-代码解释" class="headerlink" title="Example2 代码解释"></a>Example2 代码解释</h3><ol>
<li><p><code>Example2.py</code> 和 <code>Example1.py </code>的区别：</p>
<ol>
<li><code>Example2.py</code> 是 <code>Example1.py</code> 的升级版，<code>Example1.py</code> 只是演示了如果将句子分词，将单词通过词向量文件转化成对应的词向量</li>
<li><code>Example2.py</code> 是我们在写模型中真正会用到的分词过程，不仅仅是将句子转换成对应的词向量</li>
<li>这两个文件最大的区别就是，在 <code>Example2.py</code> 中我们构建了自己的词汇表，然后将输入的句子通过词汇表转换成了对应的 token id</li>
</ol>
</li>
<li><p>首先需要先了解一下词汇表这个类 <code>Vocabulary</code></p>
<ol>
<li><p><code>Vocabulary</code> 类中有 5 个主要的成员变量，分别是: <code>id_to_word: dict[int, str]</code>、<code>word_to_id: dict[str, int]</code>、<code>word_feq: defaultdict[str, int]</code>、<code>special_token_list: list[str]</code>和<code>size: int</code></p>
</li>
<li><p>初始化方法 <code>def __init__(self)</code> 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    self.word_to_id: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>] = &#123;&#125;  <span class="comment"># key: 单词, value: 单词 id</span></span><br><span class="line">    self.id_to_word: <span class="type">Dict</span>[<span class="built_in">int</span>, <span class="built_in">str</span>] = &#123;&#125;  <span class="comment"># key: 单词 id, value: 单词</span></span><br><span class="line">    self.word_feq: defaultdict[<span class="built_in">str</span>, <span class="built_in">int</span>] = defaultdict(<span class="built_in">int</span>)  <span class="comment"># 单词的频繁程度, 单词在词汇表中出现的次数</span></span><br><span class="line">    self.special_token_list: <span class="type">List</span>[<span class="built_in">str</span>] = []  <span class="comment"># 特殊的 token</span></span><br><span class="line">    self.size: <span class="built_in">int</span> = <span class="number">0</span>  <span class="comment"># 词汇表的大小, 初始时为 0</span></span><br><span class="line">    self.save_path = <span class="string">&quot;vocabulary&quot;</span>  <span class="comment"># 默认的文件保存路径</span></span><br><span class="line">    self.load_path = self.save_path  <span class="comment"># 默认的文件加载路径</span></span><br><span class="line">    self.keys = [<span class="string">&quot;word_to_id&quot;</span>, <span class="string">&quot;id_to_word&quot;</span>, <span class="string">&quot;special_token_list&quot;</span>, <span class="string">&quot;word_feq&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;size&quot;</span>]  <span class="comment"># 保存时 json 文件的key, 也是 Vocabulary 的属性名称</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Vocabulary</code> 类中剩下的部分就是对这些变量的操作，详细的请看代码中的注释，具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 词汇表类</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vocabulary</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 成员变量的类型提示</span></span><br><span class="line">    id_to_word: <span class="built_in">dict</span>[<span class="built_in">int</span>, <span class="built_in">str</span>]</span><br><span class="line">    word_to_id: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]</span><br><span class="line">    word_feq: defaultdict[<span class="built_in">str</span>, <span class="built_in">int</span>]</span><br><span class="line">    special_token_list: <span class="built_in">list</span>[<span class="built_in">str</span>]</span><br><span class="line">    size: <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.word_to_id: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>] = &#123;&#125;  <span class="comment"># key: 单词, value: 单词 id</span></span><br><span class="line">        self.id_to_word: <span class="type">Dict</span>[<span class="built_in">int</span>, <span class="built_in">str</span>] = &#123;&#125;  <span class="comment"># key: 单词 id, value: 单词</span></span><br><span class="line">        self.word_feq: defaultdict[<span class="built_in">str</span>, <span class="built_in">int</span>] = defaultdict(<span class="built_in">int</span>)  <span class="comment"># 单词的频繁程度, 单词在词汇表中出现的次数</span></span><br><span class="line">        self.special_token_list: <span class="type">List</span>[<span class="built_in">str</span>] = []  <span class="comment"># 特殊的 token</span></span><br><span class="line">        self.size: <span class="built_in">int</span> = <span class="number">0</span>  <span class="comment"># 词汇表的大小, 初始时为 0</span></span><br><span class="line">        self.save_path = <span class="string">&quot;vocabulary&quot;</span>  <span class="comment"># 默认的文件保存路径</span></span><br><span class="line">        self.load_path = self.save_path  <span class="comment"># 默认的文件加载路径</span></span><br><span class="line">        self.keys = [<span class="string">&quot;word_to_id&quot;</span>, <span class="string">&quot;id_to_word&quot;</span>, <span class="string">&quot;special_token_list&quot;</span>, <span class="string">&quot;word_feq&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;size&quot;</span>]  <span class="comment"># 保存时 json 文件的key, 也是 Vocabulary 的属性名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_token</span>(<span class="params">self, token: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            将当前 token 添加到当前词汇表中</span></span><br><span class="line"><span class="string">            :param token: 待添加的 token</span></span><br><span class="line"><span class="string">            :return: 添加 token 后对应的 token id</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> token <span class="keyword">not</span> <span class="keyword">in</span> self.word_to_id:</span><br><span class="line">            self.word_to_id[token] = self.size  <span class="comment"># 将 token 添加到 word_to_id 中</span></span><br><span class="line">            self.id_to_word[self.size] = token  <span class="comment"># 将 token 添加到 id_to_word 中</span></span><br><span class="line">            self.size += <span class="number">1</span>  <span class="comment"># 词汇表中 token 数量 +1</span></span><br><span class="line">        self.word_feq[token] += <span class="number">1</span>  <span class="comment"># 当前 token 出现的频率 +1</span></span><br><span class="line">        <span class="keyword">return</span> self.word_to_id[token]  <span class="comment"># 返回当前 token 的 id</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_tokens</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            批量添加 token 到词汇表中</span></span><br><span class="line"><span class="string">            :param tokens: 待添加的 token 列表</span></span><br><span class="line"><span class="string">            :return: 添加 token 后对应的 token id</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(self.add_token(token) <span class="keyword">for</span> token <span class="keyword">in</span> tokens)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_special_token</span>(<span class="params">self, token: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            添加特殊的 token 或者说添加自定义的 token</span></span><br><span class="line"><span class="string">            :param token: 待添加的 token</span></span><br><span class="line"><span class="string">            :return: 添加 token 后对应的 token id</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> token <span class="keyword">not</span> <span class="keyword">in</span> self.special_token_list:</span><br><span class="line">            <span class="comment"># 如果 token 没有在特殊 token 列表中出现</span></span><br><span class="line">            self.special_token_list.append(token)  <span class="comment"># 将当前 token 添加到特殊 token 列表中</span></span><br><span class="line">            <span class="keyword">return</span> self.add_token(token)  <span class="comment"># 将当前 token 添加到词汇表中, 并返回添加后的 token id</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果 token 已经在特殊 token 列表中出现过</span></span><br><span class="line">            <span class="keyword">return</span> self.word_to_id[token]  <span class="comment"># 查询词汇表, 返回对应的 token id</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_special_tokens</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            批量添加特殊的 token 到词汇表中</span></span><br><span class="line"><span class="string">            :param tokens: 待添加的 token 列表</span></span><br><span class="line"><span class="string">            :return: 添加 token 后对应的 token id</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(self.add_special_token(token) <span class="keyword">for</span> token <span class="keyword">in</span> tokens)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save_vocabulary_to_file</span>(<span class="params">self, path: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>, filename: <span class="built_in">str</span> = <span class="string">&quot;vocabulary.json&quot;</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            保存 Vocabulary 到指定的路径下</span></span><br><span class="line"><span class="string">            :param filename: 默认文件名称s</span></span><br><span class="line"><span class="string">            :param path: 指定的保存路径</span></span><br><span class="line"><span class="string">            :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> path == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            path = self.save_path</span><br><span class="line"></span><br><span class="line">        os.makedirs(path, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        vocabulary_dict: <span class="built_in">dict</span> = &#123;key: <span class="built_in">getattr</span>(self, key) <span class="keyword">for</span> key <span class="keyword">in</span> self.keys&#125;  <span class="comment"># 通过属性名称获取对应的属性值</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;path&#125;</span>/<span class="subst">&#123;filename&#125;</span>&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            json.dump(vocabulary_dict, file)  <span class="comment"># 将 Vocabulary 类中指定的属性写入文件中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_vocabulary_from_file</span>(<span class="params">self, path: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>, filename: <span class="built_in">str</span> = <span class="string">&quot;vocabulary.json&quot;</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            读取指定路径下的 Vocabulary</span></span><br><span class="line"><span class="string">            :param filename: 默认文件名称</span></span><br><span class="line"><span class="string">            :param path:  指定的读取路径</span></span><br><span class="line"><span class="string">            :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> path == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            path = self.load_path</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">            <span class="comment"># 文件路径不存在, 直接返回</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;【<span class="subst">&#123;path&#125;</span>/<span class="subst">&#123;filename&#125;</span>】, 文件不存在&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;path&#125;</span>/<span class="subst">&#123;filename&#125;</span>&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            vocabulary_dict: <span class="built_in">dict</span> = json.load(file)  <span class="comment"># 读取文件中的词汇表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> self.keys:</span><br><span class="line">            <span class="built_in">setattr</span>(self, key, vocabulary_dict[key])  <span class="comment"># 通过 key 为 Vocabulary 的属性进行赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">covert_token_to_id</span>(<span class="params">self, token: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            将 token 转换成 token id</span></span><br><span class="line"><span class="string">            :param token: 待转换的 token</span></span><br><span class="line"><span class="string">            :return: 指定 token 的 token id</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.word_to_id[token]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convert_tokens_to_ids</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            批量 将 token 转换成 token id</span></span><br><span class="line"><span class="string">            :param tokens: 待转换的 token 列表</span></span><br><span class="line"><span class="string">            :return: token 列表中 token 的 token id</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(self.covert_token_to_id(token) <span class="keyword">for</span> token <span class="keyword">in</span> tokens)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convert_id_to_token</span>(<span class="params">self, token_id: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            通过 id 获取指定的 token</span></span><br><span class="line"><span class="string">            :param token_id: token id</span></span><br><span class="line"><span class="string">            :return: 指定的 token</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.id_to_word[token_id]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convert_ids_to_tokens</span>(<span class="params">self, token_ids: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            批量通过 id 获取指定的 token</span></span><br><span class="line"><span class="string">            :param token_ids: token id 列表</span></span><br><span class="line"><span class="string">            :return: 指定的 token 列表</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(self.convert_id_to_token(token_id) <span class="keyword">for</span> token_id <span class="keyword">in</span> token_ids)</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ol>
<ol start="3">
<li><p>首先我们需要根据自己的数据集创建对应的词汇表，这里演示使用的是 <code>Yelp</code> 数据集，详细的数据集可以在 <a href="https://huggingface.co/">Hugging Face</a> 中下载，也可以使用我已经下载好的 <a href="https://cdn.jsdelivr.net/gh/David-deng-01/images/dataset/yelp.jsonl">Yelp 数据集</a> 数据集里面的数据大致格式如下图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20230508172028197.png" alt="image-20230508172028197" style="zoom:100%;" />

<p><code>text</code> 表示句子， <code>label</code> 是句子的标签, 0 表示句子情感消极, 1 表示句子情感积极</p>
</li>
<li><p>根据数据集(dataset)创建词汇表(vocabulary)具体操作步骤如下:</p>
<ol>
<li>按行读取数据集，将句子取出</li>
<li>将句子进行分词，每个单词都存入词汇表中</li>
</ol>
<p>创建词汇表的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_my_vocabulary</span>(<span class="params">data_file_path: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span></span>) -&gt; Vocabulary:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        根据自己的数据集, 创建自己的词汇表</span></span><br><span class="line"><span class="string">        :param data_file_path: 词汇表路径</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    voca = Vocabulary()  <span class="comment"># 创建词汇表对象</span></span><br><span class="line">    <span class="keyword">if</span> data_file_path == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        <span class="comment"># 如果没有传入数据集保存的位置, 则加载默认的词汇表</span></span><br><span class="line">        voca.load_vocabulary_from_file()</span><br><span class="line">        <span class="keyword">return</span> voca</span><br><span class="line"></span><br><span class="line">    voca.add_special_tokens([<span class="string">&#x27;unk&#x27;</span>, <span class="string">&#x27;pad&#x27;</span>, <span class="string">&#x27;cls&#x27;</span>, <span class="string">&#x27;sep&#x27;</span>])  <span class="comment"># 向词汇表中添加特殊 token</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(data_file_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file.readlines():</span><br><span class="line">            text: <span class="built_in">str</span> = json.loads(line)[<span class="string">&#x27;text&#x27;</span>].lower()  <span class="comment"># 提取文件中的所有句子, 并将句子中的单词全部小写</span></span><br><span class="line">            voca.add_tokens(nltk.word_tokenize(text))  <span class="comment"># 使用分词工具, 将句子分词后添加到词汇表中</span></span><br><span class="line">    <span class="keyword">return</span> voca</span><br></pre></td></tr></table></figure>
</li>
<li><p>词汇表创建结束后，再将词向量文件加载到模型中，具体的加载操作与 <code>Example1.py</code> 中加载词向量文件的操作相似。具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_glove</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, FloatTensor]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        读取预训练的词向量文件</span></span><br><span class="line"><span class="string">        :return: 单词和对应的词向量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始读取词向量文件&quot;</span>.center(<span class="number">50</span>, <span class="string">&quot;*&quot;</span>))</span><br><span class="line">    word_to_vector: <span class="type">Dict</span>[<span class="built_in">str</span>, FloatTensor] = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(self.glove_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            line = file.readline()  <span class="comment"># 从词向量文件中读取一行数据</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 如果没有读取到数据, 即 line is None, 跳出循环</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                line_split: <span class="built_in">list</span>[<span class="built_in">str</span>] = line.strip().split()  <span class="comment"># 删除 line 前面和后面多余的空格, 并将 line 按照空格分开</span></span><br><span class="line">                word: <span class="built_in">str</span> = line_split[<span class="number">0</span>]  <span class="comment"># 单词, str</span></span><br><span class="line">                vector: FloatTensor = FloatTensor(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>, line_split[<span class="number">1</span>:])))  <span class="comment"># 单词对应的向量, FloatTensor</span></span><br><span class="line">                word_to_vector[word] = vector  <span class="comment"># key: word, value: vector</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;词向量文件读取完成&quot;</span>.center(<span class="number">50</span>, <span class="string">&quot;*&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> word_to_vector</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来是创建模型，我们使用的是 <code>torch.nn.Embedding</code> 如果没有安装 <code>Pytorch</code> 请先安装，再进行接下来的操作</p>
</li>
<li><p>创建模型后，将一个批量(batch) 的数据放入模型中，在实际的神经网络训练中，我们也是一个批量一个批量的将数据送入模型中，而不是一条一条数据送入模型中</p>
</li>
<li><p>将数据输入模型后，在模型内部会进行填充(padding)操作，这是因为模型一般都是对矩阵进行操作，但是我们输入的句子可能有长有短，所以需要将短的句子使用特殊的 token 填充到和当前 batch 中最长的句子一样长，这样模型才能进行处理</p>
</li>
<li><p><code>Example2.py</code> 完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn <span class="keyword">as</span> nn, FloatTensor, LongTensor</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Embedding</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> utils.Vocabulary <span class="keyword">import</span> Vocabulary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_my_vocabulary</span>(<span class="params">data_file_path: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span></span>) -&gt; Vocabulary:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        根据自己的数据集, 创建自己的词汇表</span></span><br><span class="line"><span class="string">        :param data_file_path: 词汇表路径</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    voca = Vocabulary()  <span class="comment"># 创建词汇表对象</span></span><br><span class="line">    <span class="keyword">if</span> data_file_path == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        <span class="comment"># 如果没有传入数据集保存的位置, 则加载默认的词汇表</span></span><br><span class="line">        voca.load_vocabulary_from_file()</span><br><span class="line">        <span class="keyword">return</span> voca</span><br><span class="line"></span><br><span class="line">    voca.add_special_tokens([<span class="string">&#x27;unk&#x27;</span>, <span class="string">&#x27;pad&#x27;</span>, <span class="string">&#x27;cls&#x27;</span>, <span class="string">&#x27;sep&#x27;</span>])  <span class="comment"># 向词汇表中添加特殊 token</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(data_file_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file.readlines():</span><br><span class="line">            text: <span class="built_in">str</span> = json.loads(line)[<span class="string">&#x27;text&#x27;</span>].lower()  <span class="comment"># 提取文件中的所有句子, 并将句子中的单词全部小写</span></span><br><span class="line">            voca.add_tokens(nltk.word_tokenize(text))  <span class="comment"># 使用分词工具, 将句子分词后添加到词汇表中</span></span><br><span class="line">    <span class="keyword">return</span> voca</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example2</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocabulary: Vocabulary = <span class="literal">None</span>, dimension: <span class="built_in">int</span> = <span class="number">50</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            初始化方法</span></span><br><span class="line"><span class="string">            :param vocabulary: 词汇表</span></span><br><span class="line"><span class="string">            :param dimension: 每个单词的维度, 默认为 50 维</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 调用父类 nn.Module 的初始化方法</span></span><br><span class="line">        <span class="built_in">super</span>(Example2, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存词汇表</span></span><br><span class="line">        self.vocabulary: Vocabulary = vocabulary</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建一个嵌入层 embedding, 是一个二维矩阵, 形状为 (word_number, dimension)</span></span><br><span class="line">        self.embedding: Embedding = nn.Embedding(num_embeddings=vocabulary.size, embedding_dim=dimension)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 路径</span></span><br><span class="line">        self.glove_path = <span class="string">&quot;Model/glove/glove.6B.50d.txt&quot;</span>  <span class="comment"># 预训练的词向量文件位置</span></span><br><span class="line">        self.output_dir = <span class="string">&quot;output/example2&quot;</span>  <span class="comment"># 输出文件保存位置</span></span><br><span class="line">        self.vocabulary_filename = <span class="string">&quot;vocabulary.json&quot;</span>  <span class="comment"># 输出的词汇表文件名称</span></span><br><span class="line">        self.vocabulary_ckpt_path = <span class="string">f&quot;<span class="subst">&#123;self.output_dir&#125;</span>/<span class="subst">&#123;self.vocabulary_filename&#125;</span>&quot;</span>  <span class="comment"># 词汇表保存位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init_embedding</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            初始化</span></span><br><span class="line"><span class="string">            :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 1.加载预训练的词向量文件</span></span><br><span class="line">        word_to_vector = self.read_glove()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 计算词向量文件相对于自己的数据集的命中率</span></span><br><span class="line">        hit = <span class="number">0</span>  <span class="comment"># 命中次数</span></span><br><span class="line">        unhit_token = []  <span class="comment"># 未命中的 token</span></span><br><span class="line">        <span class="keyword">for</span> word, word_id <span class="keyword">in</span> self.vocabulary.word_to_id.items():</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> word_to_vector:</span><br><span class="line">                hit += <span class="number">1</span>  <span class="comment"># 命中的次数 +1</span></span><br><span class="line">                vector = word_to_vector[word]  <span class="comment"># 获取当前 word 对应的 vector</span></span><br><span class="line">                self.embedding.weight.data[word_id] = vector  <span class="comment"># 给词向量赋值</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                unhit_token.append(word)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;由数据库创建的单词表的大小为: <span class="subst">&#123;self.vocabulary.size&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;其中<span class="subst">&#123;hit&#125;</span>个词有预训练的词向量, 命中率为: <span class="subst">&#123;hit / self.vocabulary.size&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;没有预训练词向量的词有: <span class="subst">&#123;unhit_token&#125;</span>, 它们的词向量是随机初始化的&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_glove</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, FloatTensor]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            读取预训练的词向量文件</span></span><br><span class="line"><span class="string">            :return: 单词和对应的词向量</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始读取词向量文件&quot;</span>.center(<span class="number">50</span>, <span class="string">&quot;*&quot;</span>))</span><br><span class="line">        word_to_vector: <span class="type">Dict</span>[<span class="built_in">str</span>, FloatTensor] = &#123;&#125;</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.glove_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                line = file.readline()  <span class="comment"># 从词向量文件中读取一行数据</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">                    <span class="keyword">break</span>  <span class="comment"># 如果没有读取到数据, 即 line is None, 跳出循环</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    line_split: <span class="built_in">list</span>[<span class="built_in">str</span>] = line.strip().split()  <span class="comment"># 删除 line 前面和后面多余的空格, 并将 line 按照空格分开</span></span><br><span class="line">                    word: <span class="built_in">str</span> = line_split[<span class="number">0</span>]  <span class="comment"># 单词, str</span></span><br><span class="line">                    vector: FloatTensor = FloatTensor(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>, line_split[<span class="number">1</span>:])))  <span class="comment"># 单词对应的向量, FloatTensor</span></span><br><span class="line">                    word_to_vector[word] = vector  <span class="comment"># key: word, value: vector</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;词向量文件读取完成&quot;</span>.center(<span class="number">50</span>, <span class="string">&quot;*&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> word_to_vector</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, input_text: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; FloatTensor:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            查询 input_text 中的句子的</span></span><br><span class="line"><span class="string">            :param input_text: 一个个句子组成的列表</span></span><br><span class="line"><span class="string">            :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 1. 将句子全部进行分词转为相应 token id</span></span><br><span class="line">        word_list: <span class="built_in">list</span>[<span class="built_in">list</span>[<span class="built_in">str</span>]] = <span class="built_in">list</span>(nltk.word_tokenize(sentence) <span class="keyword">for</span> sentence <span class="keyword">in</span> input_text)</span><br><span class="line">        input_ids: <span class="built_in">list</span>[<span class="built_in">list</span>[<span class="built_in">int</span>]] = <span class="built_in">list</span>(self.vocabulary.convert_tokens_to_ids(sequence) <span class="keyword">for</span> sequence <span class="keyword">in</span> word_list)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 计算序列的最大长度, 方便以后的 padding 操作, 因为模型输入的是矩阵, 如果句子的长度不一样, 我们应该进行 padding 操作</span></span><br><span class="line">        max_len: <span class="built_in">int</span> = <span class="built_in">max</span>(<span class="built_in">len</span>(sequence) <span class="keyword">for</span> sequence <span class="keyword">in</span> input_ids)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 获取用于 padding 的 token id, 即 &quot;pad&quot; 的 id</span></span><br><span class="line">        pad_id: <span class="built_in">int</span> = self.vocabulary.word_to_id[<span class="string">&quot;pad&quot;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4. 因为 input_ids 中 list 的长度不一, 所以需要统一长度, 即 padding 操作</span></span><br><span class="line">        input_ids: <span class="built_in">list</span>[<span class="built_in">list</span>[<span class="built_in">int</span>]] = <span class="built_in">list</span>(sequence + [pad_id] * (max_len - <span class="built_in">len</span>(sequence)) <span class="keyword">for</span> sequence <span class="keyword">in</span> input_ids)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 5. 将 input_ids 转成 tensor, shape &gt;&gt; [bath_size, max_len]</span></span><br><span class="line">        input_ids: LongTensor = LongTensor(input_ids)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 6. 将 input_ids 转成词向量</span></span><br><span class="line">        input_embedding: FloatTensor = self.embedding(input_ids)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> input_embedding</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">dimension: <span class="built_in">int</span> = <span class="number">50</span></span>):</span><br><span class="line">    data_file_path = <span class="string">&quot;data/yelp.jsonl&quot;</span>  <span class="comment"># 自己的数据集的位置</span></span><br><span class="line">    output_dir = <span class="string">&quot;output/example2&quot;</span>  <span class="comment"># 输出文件保存位置</span></span><br><span class="line">    embedding_layer_ckpt_path = <span class="string">f&quot;<span class="subst">&#123;output_dir&#125;</span>/embedding_layer.pt&quot;</span>  <span class="comment"># 嵌入层保存位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 创建输出文件目录, 如果不存在的话</span></span><br><span class="line">    os.makedirs(output_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 根据自己的数据集创建词汇表</span></span><br><span class="line">    voca = create_my_vocabulary(data_file_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 创建 embedding 层</span></span><br><span class="line">    embedding_layer = Example2(vocabulary=voca, dimension=dimension)</span><br><span class="line">    <span class="keyword">if</span> embedding_layer_ckpt_path <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        embedding_layer.init_embedding()</span><br><span class="line">        torch.save(embedding_layer.state_dict(), <span class="string">f&quot;<span class="subst">&#123;output_dir&#125;</span>/embedding_layer.pt&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        embedding_layer.load_state_dict(torch.load(embedding_layer_ckpt_path))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 将一个 batch 的 sentences 转为向量</span></span><br><span class="line">    <span class="comment"># 演示的batch size = 4</span></span><br><span class="line">    batch_text = [</span><br><span class="line">        <span class="string">&quot;ever since joes has changed hands it &#x27;s just gotten worse and worse .&quot;</span>,</span><br><span class="line">        <span class="string">&quot;there is definitely not enough room in that part of the venue .&quot;</span>,</span><br><span class="line">        <span class="string">&quot;so basically tasted watered down .&quot;</span>,</span><br><span class="line">        <span class="string">&quot;she said she &#x27;d be back and disappeared for a few minutes .&quot;</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="built_in">print</span>([item.shape <span class="keyword">for</span> item <span class="keyword">in</span> embedding_layer.forward(batch_text)])</span><br><span class="line">    <span class="built_in">print</span>(embedding_layer(batch_text).shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run(dimension=<span class="number">50</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>   <code>代码运行结果如下</code>：</p>
<img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20230508180244621.png" alt="image-20230508180244621" style="zoom:100%;" />

<h2 id="2-句子情感分类任务"><a href="#2-句子情感分类任务" class="headerlink" title="2. 句子情感分类任务"></a>2. 句子情感分类任务</h2><h2 id="3-对话生成任务"><a href="#3-对话生成任务" class="headerlink" title="3. 对话生成任务"></a>3. 对话生成任务</h2>]]></content>
      <categories>
        <category>笔记</category>
        <category>DL</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>typora 快捷键</title>
    <url>//2023/05/06/typora-shortcut-keys/</url>
    <content><![CDATA[<h1 id="Shortcut-Keys"><a href="#Shortcut-Keys" class="headerlink" title="Shortcut Keys"></a><a href="https://support.typoraio.cn/Shortcut-Keys/">Shortcut Keys</a></h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>您可以使用快捷键快速插入或修改样式，或执行 Typora 支持的其他操作。<br>您可以在菜单栏中的每个菜单项的右侧找到快捷键。</p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><h3 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h3><p>在 macOS 上，您可以按 <code>ESC</code> 键打开内联数学的内联预览，以及表情符号的自动完成等。</p>
<h3 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">快捷键 (Windows/Linux)</th>
<th>快捷键 (macOS)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">New</td>
<td align="left">Ctrl + N</td>
<td>Command + N</td>
</tr>
<tr>
<td align="left">New Window</td>
<td align="left">Ctrl + Shift + N</td>
<td>Command +Shift + N</td>
</tr>
<tr>
<td align="left">New Tab</td>
<td align="left"><em>(Not Supported)</em></td>
<td>Command + T</td>
</tr>
<tr>
<td align="left">Open</td>
<td align="left">Ctrl + O</td>
<td>Command + O</td>
</tr>
<tr>
<td align="left">Open Quickly</td>
<td align="left">Ctrl + P</td>
<td>Command + Shift + O</td>
</tr>
<tr>
<td align="left">Reopen Closed File</td>
<td align="left">Ctrl + Shift + T</td>
<td>Command + Shift + T</td>
</tr>
<tr>
<td align="left">Save</td>
<td align="left">Ctrl + S</td>
<td>Command + S</td>
</tr>
<tr>
<td align="left">Save As / Duplicate</td>
<td align="left">Ctrl + Shift + S</td>
<td>Command + Shift + S</td>
</tr>
<tr>
<td align="left">Preference</td>
<td align="left">Ctrl + ,</td>
<td>Command + ,</td>
</tr>
<tr>
<td align="left">Close</td>
<td align="left">Ctrl + W</td>
<td>Command + W</td>
</tr>
</tbody></table>
<h3 id="编辑相关"><a href="#编辑相关" class="headerlink" title="编辑相关"></a>编辑相关</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">快捷键 (Windows/Linux)</th>
<th>快捷键 (macOS)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">New Paragraph</td>
<td align="left">Enter</td>
<td>Enter</td>
</tr>
<tr>
<td align="left">New Line</td>
<td align="left">Shift + Enter</td>
<td>Shift + Enter</td>
</tr>
<tr>
<td align="left">Cut</td>
<td align="left">Ctrl + X</td>
<td>Command + X</td>
</tr>
<tr>
<td align="left">Copy</td>
<td align="left">Ctrl + C</td>
<td>Command + C</td>
</tr>
<tr>
<td align="left">Paste</td>
<td align="left">Ctrl + V</td>
<td>Command + V</td>
</tr>
<tr>
<td align="left">Copy As Markdown</td>
<td align="left">Ctrl + Shift + C</td>
<td>Command + Shift + C</td>
</tr>
<tr>
<td align="left">Paste As Plain Text</td>
<td align="left">Ctrl + Shift + V</td>
<td>Command + Shift + V</td>
</tr>
<tr>
<td align="left">Select All</td>
<td align="left">Ctrl + A</td>
<td>Command + A</td>
</tr>
<tr>
<td align="left">Select Line/Sentence Select Row (in table)</td>
<td align="left">Ctrl + L</td>
<td>Command + L</td>
</tr>
<tr>
<td align="left">Delete Row (in table)</td>
<td align="left">Ctrl + Shift + Backspace</td>
<td>Command + Shift + Backspace</td>
</tr>
<tr>
<td align="left">Select Style Scope Select Cell (in table)</td>
<td align="left">Ctrl + E</td>
<td>Command + E</td>
</tr>
<tr>
<td align="left">Select Word</td>
<td align="left">Ctrl + D</td>
<td>Command + D</td>
</tr>
<tr>
<td align="left">Delete Word</td>
<td align="left">Ctrl + Shift + D</td>
<td>Command + Shift + D</td>
</tr>
<tr>
<td align="left">Jump to Top</td>
<td align="left">Ctrl + Home</td>
<td>Command + ↑</td>
</tr>
<tr>
<td align="left">Jump to Selection</td>
<td align="left">Ctrl + J</td>
<td>Command + J</td>
</tr>
<tr>
<td align="left">Jump to Bottom</td>
<td align="left">Ctrl + End</td>
<td>Command + ↓</td>
</tr>
<tr>
<td align="left">Find</td>
<td align="left">Ctrl + F</td>
<td>Command + F</td>
</tr>
<tr>
<td align="left">Find Next</td>
<td align="left">F3 / Enter</td>
<td>Command + G / Enter</td>
</tr>
<tr>
<td align="left">Find Previous</td>
<td align="left">Shift + F3 / Shift + Enter</td>
<td>Command + Shift + G / Shift + Enter</td>
</tr>
<tr>
<td align="left">Replace</td>
<td align="left">Ctrl + H</td>
<td>Command + H</td>
</tr>
</tbody></table>
<h3 id="段落相关"><a href="#段落相关" class="headerlink" title="段落相关"></a>段落相关</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">快捷键 (Windows/Linux)</th>
<th>快捷键 (macOS)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Heading 1 to 6</td>
<td align="left">Ctrl + 1/2/3/4/5/6</td>
<td>Command + 1/2/3/4/5/6</td>
</tr>
<tr>
<td align="left">Paragraph</td>
<td align="left">Ctrl + 0</td>
<td>Command + 0</td>
</tr>
<tr>
<td align="left">Increase Heading Level</td>
<td align="left">Ctrl + =</td>
<td>Command + =</td>
</tr>
<tr>
<td align="left">Decrease Heading Level</td>
<td align="left">Ctrl + -</td>
<td>Command + -</td>
</tr>
<tr>
<td align="left">Table</td>
<td align="left">Ctrl + T</td>
<td>Command + Option + T</td>
</tr>
<tr>
<td align="left">Code Fences</td>
<td align="left">Ctrl + Shift + K</td>
<td>Command + Option + C</td>
</tr>
<tr>
<td align="left">Math Block</td>
<td align="left">Ctrl + Shift + M</td>
<td>Command + Option + B</td>
</tr>
<tr>
<td align="left">Quote</td>
<td align="left">Ctrl + Shift + Q</td>
<td>Command + Option + Q</td>
</tr>
<tr>
<td align="left">Ordered List</td>
<td align="left">Ctrl + Shift + [</td>
<td>Command + Option + O</td>
</tr>
<tr>
<td align="left">Unordered List</td>
<td align="left">Ctrl + Shift + ]</td>
<td>Command + Option + U</td>
</tr>
<tr>
<td align="left">Indent</td>
<td align="left">Ctrl + [ / Tab</td>
<td>Command + [ / Tab</td>
</tr>
<tr>
<td align="left">Outdent</td>
<td align="left">Ctrl + ] / Shift + Tab</td>
<td>Command + ] / Shift + Tab</td>
</tr>
</tbody></table>
<h3 id="版式相关"><a href="#版式相关" class="headerlink" title="版式相关"></a>版式相关</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">快捷键 (Windows/Linux)</th>
<th>快捷键 (macOS)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Strong</td>
<td align="left">Ctrl + B</td>
<td>Command + B</td>
</tr>
<tr>
<td align="left">Emphasis</td>
<td align="left">Ctrl + I</td>
<td>Command + I</td>
</tr>
<tr>
<td align="left">Underline</td>
<td align="left">Ctrl + U</td>
<td>Command + U</td>
</tr>
<tr>
<td align="left">Code</td>
<td align="left">Ctrl + Shift + `</td>
<td>Command + Shift + `</td>
</tr>
<tr>
<td align="left">Strike</td>
<td align="left">Alt + Shift + 5</td>
<td>Control + Shift + `</td>
</tr>
<tr>
<td align="left">Hyperlink</td>
<td align="left">Ctrl + K</td>
<td>Command + K</td>
</tr>
<tr>
<td align="left">Image</td>
<td align="left">Ctrl + Shift + I</td>
<td>Command + Control + I</td>
</tr>
<tr>
<td align="left">Clear Format</td>
<td align="left">Ctrl + \</td>
<td>Command + \</td>
</tr>
</tbody></table>
<h3 id="视图相关"><a href="#视图相关" class="headerlink" title="视图相关"></a>视图相关</h3><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">快捷键 (Windows/Linux)</th>
<th>快捷键 (macOS)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Toggle Sidebar</td>
<td align="left">Ctrl + Shift + L</td>
<td>Command + Shift + L</td>
</tr>
<tr>
<td align="left">Outline</td>
<td align="left">Ctrl + Shift + 1</td>
<td>Command + Control + 1</td>
</tr>
<tr>
<td align="left">Articles</td>
<td align="left">Ctrl + Shift + 2</td>
<td>Command + Control + 2</td>
</tr>
<tr>
<td align="left">File Tree</td>
<td align="left">Ctrl + Shift + 3</td>
<td>Command + Control + 3</td>
</tr>
<tr>
<td align="left">Source Code Mode</td>
<td align="left">Ctrl + /</td>
<td>Command + /</td>
</tr>
<tr>
<td align="left">Focus Mode</td>
<td align="left">F8</td>
<td>F8</td>
</tr>
<tr>
<td align="left">Typewriter Mode</td>
<td align="left">F9</td>
<td>F9</td>
</tr>
<tr>
<td align="left">Toggle Fullscreen</td>
<td align="left">F11</td>
<td>Command + Option + F</td>
</tr>
<tr>
<td align="left">Actual Size</td>
<td align="left">Ctrl + Shift + 0</td>
<td><em>(Not Supported)</em></td>
</tr>
<tr>
<td align="left">Zoom In</td>
<td align="left">Ctrl + Shift + =</td>
<td><em>(Not Supported)</em></td>
</tr>
<tr>
<td align="left">Zoom Out</td>
<td align="left">Ctrl + Shift + -</td>
<td><em>(Not Supported)</em></td>
</tr>
<tr>
<td align="left">Switch Between Opened Documents</td>
<td align="left">Ctrl + Tab</td>
<td>Command + `</td>
</tr>
<tr>
<td align="left">Toggle DevTools</td>
<td align="left">Ctrl + Shift + I</td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="自定义快捷键"><a href="#自定义快捷键" class="headerlink" title="自定义快捷键"></a>自定义快捷键</h2><p>用户可以在 Typora 的菜单栏中为命令设置或重新分配快捷键。本文将展示如何做到这一点。</p>
<h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>We use macOS’s system feature to customize Typora’s key binding on macOS.</p>
<ol>
<li><p>Open <code>System Preference</code> → <code>Keyboard</code>, select tab <code>Shortcuts</code>. Select <code>App Shortcuts</code> in its left panel.</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/Snip20160814_1.png" alt="Snip20160814_1"></p>
</li>
<li><p>Click the “+” button, a dialog sheet would pop up. Select “Typora.app” from field <code>Application</code>, then enter the exact name of the menu command you want to add, and then type the shortcut key combination you want to assign.</p>
<p>For example, assume you want to add/change the shortcut key to pin Typora’s window, you can fill the dialog box as follows:</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/Snip20160814_5.png" alt="Snip20160814_5"></p>
<p>Then <code>Command+Shift+P</code> will be the shortcut key for menu command “always On Top”</p>
</li>
</ol>
<h3 id="Windows-Linux"><a href="#Windows-Linux" class="headerlink" title="Windows / Linux"></a>Windows / Linux</h3><blockquote>
<p>Tip: This requires a version of Typora ≥ v0.9.16.</p>
</blockquote>
<ol>
<li><p>Open <code>Menu</code> → <code>Preference</code> in Typora, then click “Open Advanced Settings”.</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/sshot-1.png" alt="sshot-1"></p>
</li>
<li><p>Open and edit <code>conf.user.json</code> from opened “File Explore”. If there’s no such file, create one.</p>
</li>
<li><p>Set or add JSON object which represents a key binding, for example:</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/Snip20160814_7.png" alt="Snip20160814_7"></p>
</li>
<li><p>Restart Typora, and the new key binding will be applied.</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/sshot-2.png" alt="sshot-2"></p>
</li>
</ol>
<p>You can set or change shortcut keys for menu items in the menu bar in native window style.</p>
]]></content>
      <categories>
        <category>教程</category>
        <category>typora</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>typora</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归和逻辑回归</title>
    <url>//2023/05/09/Linear-Regression-And-Logistic-Regression/</url>
    <content><![CDATA[<h1 id="线性回归和逻辑回归"><a href="#线性回归和逻辑回归" class="headerlink" title="线性回归和逻辑回归"></a>线性回归和逻辑回归</h1><h2 id="1-线性回归-Linear-Regression"><a href="#1-线性回归-Linear-Regression" class="headerlink" title="1. 线性回归(Linear Regression)"></a>1. 线性回归(Linear Regression)</h2><h3 id="什么是回归（Regression）"><a href="#什么是回归（Regression）" class="headerlink" title="什么是回归（Regression）"></a>什么是回归（Regression）</h3><p><strong>回归分析</strong>是一种统计方法,于对具有一个或多个自变量的因变量(目标变量)和自变量(预测变量)之间的关系进行建模。具体地说，回归分析有助于我们理解在其他自变量保持固定的情况下，自变量的值对应于自变量的变化方式。它可以预测连续/实际值,例如温度,年龄,工资,价格等。</p>
<p>通俗理解：越来越接近期望值的过程，回归于事物本来的面目。</p>
<p>回归是一种有监督的学习技术，有助于发现变量之间的相关性,并使我们能够基于一个或多个预测变量来预测连续输出变量。它主要用于预测，时间序列建模以及确定变量之间的因果关系。</p>
<p>在回归中，我们在最适合给定数据点的变量之间绘制图形,使用此图形，机器学习模型可以对数据进行预测。用简单的话说，回归显示一条线或曲线， 它穿过目标预测图上的所有数据点，以使数据点和回归线之间的垂直距离最小。数据点和线之间的距离表明模型是否已捕获牢固的关系。</p>
<p>主要用于预测数值型数据，典型的回归例子：数据拟合曲线</p>
<h3 id="什么是线性回归（Linear-Regression）"><a href="#什么是线性回归（Linear-Regression）" class="headerlink" title="什么是线性回归（Linear Regression）"></a>什么是线性回归（Linear Regression）</h3><p>在统计学中，线性回归（Linear Regression）是利用称为线性回归方程的最小平方函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。只有一个自变量的情况称为<strong>简单回归</strong>，大于一个自变量情况的叫做<strong>多元回归</strong>。（这反过来又应当由多个相关的因变量预测的多元线性回归区别，而不是一个单一的标量变量。）</p>
<p>在线性回归中，数据使用线性预测函数来建模，并且未知的模型参数也是通过数据来估计。这些模型被叫做<strong>线性模型</strong>。最常用的线性回归建模是给定X值的y的条件均值是X的仿射函数。不太一般的情况，线性回归模型可以是一个中位数或一些其他的给定X的条件下y的条件分布的分位数作为X的线性函数表示。像所有形式的回归分析一样，线性回归也把焦点放在给定X值的y的条件概率分布，而不是X和y的联合概率分布（多元分析领域）。</p>
<p>线性回归是回归分析中第一种经过严格研究并在实际应用中广泛使用的类型。这是因为线性依赖于其未知参数的模型比非线性依赖于其未知参数的模型更容易拟合，而且产生的估计的统计特性也更容易确定。</p>
<p>线性回归模型经常用<strong>最小二乘</strong>逼近来拟合，但他们也可能用别的方法来拟合，比如用最小化“拟合缺陷”在一些其他规范里（比如最小绝对误差回归），或者在桥回归中最小化最小二乘损失函数的惩罚.相反,最小二乘逼近可以用来拟合那些非线性的模型.因此，尽管“最小二乘法”和“线性模型”是紧密相连的，但他们是不能划等号的。</p>
<blockquote>
<p>最小二乘法（又称最小平方法）是一种数学优化技术。它通过最小化误差的平方和寻找数据的最佳函数匹配。利用最小二乘法可以简便地求得未知的数据，并使得这些求得的数据与实际数据之间误差的平方和为最小。</p>
<p>最小二乘法还可用于曲线拟合，其他一些优化问题也可通过最小化能量或最大化熵用最小二乘法来表达 。</p>
</blockquote>
<p>线性回归假设输出变量是若干输出变量的线性组合，并根据这一关系求解线性组合中的最优系数。</p>
<p>通俗理解：输出一个线性函数，例如</p>
<img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20230511231459904.png" alt="image-20230511231459904" style="zoom:100%;" />

<p>假定一个实例可以用列向量表示，每个代表实例在第i个属性上的取值，线性回归就是都求出一组参数，使预测输出可以表示为以这组参数为权重的实例属性的线性组合。例如引入常量，线性回归试图学习的模型就是</p>
<ul>
<li>当实例只有一个属性时，输入输出之间关系就是二维平面的一条直线</li>
<li>当实例属性数目较多时，得到的是n+1维空间的一个超平面，对应一个维度等于于n的线性子空间</li>
</ul>
<h3 id="什么是一元线性回归（Unary-Linear-Regression）"><a href="#什么是一元线性回归（Unary-Linear-Regression）" class="headerlink" title="什么是一元线性回归（Unary Linear Regression）"></a>什么是一元线性回归（Unary Linear Regression）</h3><p>一元线性回归也叫单变量线性回归，一元线性回归是分析只有一个自变量。从一个输入值预测一个输出值，输入/输出的对应关系就是一个线性函数。例如：一个经济指标的数值往往受许多因素影响，若其中只有一个因素是主要的，起决定性作用，则可用一元线性回归进行预测分析。</p>
<img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20230511231831139.png" alt="image-20230511231831139" style="zoom:100%;" />

<h3 id="什么是多元线性回归（Multiple-Linear-Regression）"><a href="#什么是多元线性回归（Multiple-Linear-Regression）" class="headerlink" title="什么是多元线性回归（Multiple Linear Regression）"></a>什么是多元线性回归（Multiple Linear Regression）</h3><p>在回归分析中，如果有两个或两个以上的自变量，就称为多元回归。当样本的描述涉及多个属性时，这类问题就被称为多元线性回归。。事实上，一种现象常常是与多个因素相联系的，由多个自变量的最优组合共同来预测或估计因变量，比只用一个自变量进行预测或估计更有效，更符合实际。因此多元线性回归比一元线性回归的实用意义更大。例如，肌肉是睡眠、饮食、训练多种因素共同作用的结果。</p>
<img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20230511232444558.png" alt="image-20230511232444558" style="zoom:100%;" />

<h2 id="2-逻辑回归-Logistic-Regression"><a href="#2-逻辑回归-Logistic-Regression" class="headerlink" title="2. 逻辑回归(Logistic Regression)"></a>2. 逻辑回归(Logistic Regression)</h2><h3 id="什么是逻辑回归（Logistic-Regression）"><a href="#什么是逻辑回归（Logistic-Regression）" class="headerlink" title="什么是逻辑回归（Logistic Regression）"></a>什么是逻辑回归（Logistic Regression）</h3><p>线性回归能对连续值进行预测，而现实中学常见的另一类问题是分类，逻辑回归解决的就是分类问题。逻辑回归输出的实例属于每个类别的似然概率，似然概率最大的类别就是分类结果。通俗理解：逻辑就是True或False，判断出是True还是False，相当于分类了。在二分类任务中，逻辑回归可以视为在平面直角坐标系上划定一条数据分类的判定边界。</p>
<p>逻辑回归就是这样的一个过程：面对一个回归或者分类问题，建立代价函数，然后通过优化方法迭代求解出最优的模型参数，然后测试验证我们这个求解的模型的好坏。Logistic回归虽然名字里带“回归”，但是它实际上是一种分类方法，主要用于两分类问题（即输出只有两种，分别代表两个类别）回归模型中，y是一个定性变量，比如y=0或1，逻辑回归方法主要应用于研究某些事件发生的概率。</p>
<img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20230511233440196.png" alt="image-20230511233440196" style="zoom:100%;" />



<h2 id="3-线性回归和逻辑回归的区别"><a href="#3-线性回归和逻辑回归的区别" class="headerlink" title="3. 线性回归和逻辑回归的区别"></a>3. 线性回归和逻辑回归的区别</h2><p>线性回归和逻辑回归的性质不同、任务定位不同、输出值不同、损失函数不同等。下面简单描述两种机器学习方法的不同点。</p>
<h3 id="性质不同"><a href="#性质不同" class="headerlink" title="性质不同"></a>性质不同</h3><ol>
<li>线性回归模型一般用于预测，用于对连续值进行预测，例如预测房价走势。逻辑回归一般用于分类，用于对离散值进行预测，例如：是否是乳腺癌预测</li>
<li>逻辑回归是一种广义的线性回归分析模型；线性回归是利用数理统计中回归分析，来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。</li>
<li>逻辑回归常用于数据挖掘，疾病自动诊断，经济预测等领域；线性回归常运用于数学、金融、趋势线、经济学等领域。</li>
</ol>
<h3 id="任务定位不同"><a href="#任务定位不同" class="headerlink" title="任务定位不同"></a>任务定位不同</h3><ol>
<li>线性回归用于回归任务；逻辑回归用于分类任务。</li>
</ol>
<h3 id="输出值不同"><a href="#输出值不同" class="headerlink" title="输出值不同"></a>输出值不同</h3><ol>
<li>线性回归输出连续值；</li>
<li>逻辑回归输出概率值；</li>
</ol>
<h3 id="损失函数不同"><a href="#损失函数不同" class="headerlink" title="损失函数不同"></a>损失函数不同</h3><ol>
<li>线性回归一般采用Mean Square Error Loss(均方误差损失)函数</li>
<li>逻辑回归采用Cross Entropy Loss(交叉熵损失)函数</li>
</ol>
<h2 id="4-线性回归和逻辑回归的联系"><a href="#4-线性回归和逻辑回归的联系" class="headerlink" title="4. 线性回归和逻辑回归的联系"></a>4. 线性回归和逻辑回归的联系</h2><p>本质上，逻辑回归是将线性回归的结果通过 <code>sigmod</code> 函数进行了映射，将值域映射到(0,1)，在二类任务中，若大于0.5，则为某个类，小于0.5，为另一类。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>线性回归和逻辑回归都是总要的机器学习方法，两种方法既有区别又有联系。它们适用于不同的任务，有不同的效果。但是本质上两种回归方法是一致的，只是逻辑回归方法在线性回归方法的基础上，对线性回归方法的结果进行了映射。</p>
]]></content>
      <categories>
        <category>Educoder</category>
        <category>ML</category>
      </categories>
      <tags>
        <tag>Educoder</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmd Markdown 公式指导手册</title>
    <url>//2023/05/10/MarkDown-Formula-Guide-Manual/</url>
    <content><![CDATA[<h1 id="一、公式使用参考"><a href="#一、公式使用参考" class="headerlink" title="一、公式使用参考"></a>一、公式使用参考</h1><h2 id="1．如何插入公式"><a href="#1．如何插入公式" class="headerlink" title="1．如何插入公式"></a>1．如何插入公式</h2><p>$\TeX$ 可使用行中公式放在文中与其它文字混编，或单独成行的独立公式。</p>
<p>行中公式可以用如下方法表示：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> 表达式 <span class="symbol">$</span></span><br></pre></td></tr></table></figure>

<p>独立公式可以用如下方法表示：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> 表达式 <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure>

<dl><dt>自动编号的公式可以用如下方法表示：</dt><dd>若需要手动编号，可在公式后使用 <code>\tag&#123;编号&#125;</code> 语句。</dd></dl><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\begin</span><span class="template-variable">&#123;equation&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    表达式</span></span><br><span class="line"><span class="language-xml">    \label</span><span class="template-variable">&#123;<span class="keyword">eq</span>:当前公式名&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\end</span><span class="template-variable">&#123;equation&#125;</span></span><br></pre></td></tr></table></figure>

<p>: 自动编号后的公式可在全文任意处使用 <code>\eqref&#123;eq:公式名&#125;</code> 语句引用。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$ J_<span class="string">\alpha(x)</span> = <span class="string">\sum_&#123;m=0&#125;^\infty</span> <span class="string">\frac&#123;(-1)^m&#125;&#123;m!</span> <span class="string">\Gamma</span> (m + <span class="string">\alpha</span> + <span class="number">1</span>)&#125; &#123;<span class="string">\left(&#123;</span> <span class="string">\frac&#123;x&#125;&#123;2&#125;</span> &#125;<span class="string">\right)&#125;^&#123;2m</span> + <span class="string">\alpha&#125;</span> <span class="string">\text</span> &#123;，行内公式示例&#125; $</span><br></pre></td></tr></table></figure>

<ul>
<li><p>显示： $ J<em>\alpha(x) = \sum</em>{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，行内公式示例} $</p>
</li>
<li><p>例子：</p>
</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$$ J_<span class="string">\alpha(x)</span> = <span class="string">\sum_&#123;m=0&#125;^\infty</span> <span class="string">\frac&#123;(-1)^m&#125;&#123;m!</span> <span class="string">\Gamma</span> (m + <span class="string">\alpha</span> + <span class="number">1</span>)&#125; &#123;<span class="string">\left(&#123;</span> <span class="string">\frac&#123;x&#125;&#123;2&#125;</span> &#125;<span class="string">\right)&#125;^&#123;2m</span> + <span class="string">\alpha&#125;</span> <span class="string">\text&#123;，独立公式示例，使用</span> <span class="string">\tag</span> 手动编号&#125; <span class="string">\tag&#123;0.1&#125;</span> $$</span><br></pre></td></tr></table></figure>

<ul>
<li><p>显示： $$ J<em>\alpha(x) = \sum</em>{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text{，独立公式示例，使用 \tag 手动编号} \tag{0.1} $$</p>
</li>
<li><p>例子：</p>
</li>
</ul>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">$$ 在公式 \eqref</span><span class="template-variable">&#123;<span class="keyword">eq</span>:sample&#125;</span><span class="language-xml"> 中，我们看到了这个被自动编号的公式。$$</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\begin</span><span class="template-variable">&#123;equation&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    E=mc^2 \text</span><span class="template-variable">&#123;，自动编号公式示例&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    \label</span><span class="template-variable">&#123;<span class="keyword">eq</span>:sample&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\end</span><span class="template-variable">&#123;equation&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示：</li>
</ul>
<p>$$ 在公式 \eqref{eq:sample} 中，我们看到了这个被自动编号的公式。$$</p>
<p>$$<br>\begin{equation}<br>    E=mc^2 \text{，自动编号公式示例}<br>    \label{eq:sample}<br>\end{equation}<br>$$</p>
<p>不自动编号的公式可以用如下方法表示：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">\<span class="keyword">begin</span>&#123;equation*&#125;</span><br><span class="line">    表达式</span><br><span class="line">\<span class="keyword">end</span>&#123;equation*&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2．如何输入上下标"><a href="#2．如何输入上下标" class="headerlink" title="2．如何输入上下标"></a>2．如何输入上下标</h2><p><code>^</code> 表示上标，<code>_</code> 表示下标。如果上下标的内容多于一个字符，需要用 <code>&#123;&#125;</code> 将这些内容括成一个整体。<br>上下标可以嵌套，也可以同时使用。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> x^&#123;y^z&#125;=(<span class="number">1</span>+&#123;\rm e&#125;^x)^&#123;<span class="number">-2</span>xy^w&#125; <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示：$$ x^{y^z}=(1+{\rm e}^x)^{-2xy^w} $$</li>
</ul>
<p>如果要在左右两边都有上下标，可以使用 <code>\sideset</code> 命令；也可以简单地在符号前面多打一个上下标，此时会以行内公式渲染。<br>本例内 <code>\quad</code> 均为空格符号，为方便公式格式对比而添加，请注意辨别。详见<a href="#3%E5%9C%A8%E5%AD%97%E7%AC%A6%E9%97%B4%E5%8A%A0%E5%85%A5%E7%A9%BA%E6%A0%BC">在字符间加入空格</a>。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">$$ \sideset</span><span class="template-variable">&#123;^1_2&#125;</span><span class="template-variable">&#123;^3_4&#125;</span><span class="language-xml">\bigotimes \quad or \quad </span><span class="template-variable">&#123;^1_2&#125;</span><span class="language-xml">\bigotimes </span><span class="template-variable">&#123;^3_4&#125;</span><span class="language-xml"> $$</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示：<br>$$<br>\sideset{^1_2}{^3_4}\bigotimes \quad or \quad {^1_2}\bigotimes {^3_4}<br>$$</li>
</ul>
<p>##3．如何输入括号和分隔符</p>
<p><code>()</code>、<code>[]</code> 和 <code>|</code> 表示符号本身，使用 <code>\&#123;\&#125;</code> 来表示 <code>&#123;&#125;</code> 。当要显示大号的括号或分隔符时，要用 <code>\left</code> 和 <code>\right</code> 命令。</p>
<p>一些特殊的括号：</p>
<table>
<thead>
<tr>
<th align="right">输入</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="left">显示</th>
</tr>
</thead>
<tbody><tr>
<td align="right">\langle</td>
<td align="left">$\langle$</td>
<td align="right">\rangle</td>
<td align="left">$\rangle$</td>
</tr>
<tr>
<td align="right">\lceil</td>
<td align="left">$\lceil$</td>
<td align="right">\rceil</td>
<td align="left">$\rceil$</td>
</tr>
<tr>
<td align="right">\lfloor</td>
<td align="left">$\lfloor$</td>
<td align="right">\rfloor</td>
<td align="left">$\rfloor$</td>
</tr>
<tr>
<td align="right">\lbrace</td>
<td align="left">$\lbrace$</td>
<td align="right">\rbrace</td>
<td align="left">$\rbrace$</td>
</tr>
<tr>
<td align="right">\lvert</td>
<td align="left">$\lvert$</td>
<td align="right">\rvert</td>
<td align="left">$\rvert$</td>
</tr>
<tr>
<td align="right">\lVert</td>
<td align="left">$\lVert$</td>
<td align="right">\rVert</td>
<td align="left">$\rVert$</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>@lymd</strong> 有时，我们需要在行内使用两个竖杠表示向量间的某种空间距离，可以这样写<br><span style="text-align: center; display: block"> <code>\lVert \boldsymbol&#123;X&#125;_i - \boldsymbol&#123;S&#125;_j \rVert^2</code> → $\lVert \boldsymbol{X}_i - \boldsymbol{S}_j \rVert^2$ </span></p>
</blockquote>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> f(x,y,z) = <span class="number">3</span>y^<span class="number">2</span>z \left( <span class="number">3</span>+\<span class="built_in">frac</span>&#123;<span class="number">7</span>x+<span class="number">5</span>&#125;&#123;<span class="number">1</span>+y^<span class="number">2</span>&#125; \right) <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示：<br>$$<br>  f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right)<br>$$</li>
</ul>
<p>有时要用 <code>\left.</code> 或 <code>\right.</code> 进行匹配而不显示本身。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">$$</span></span><br><span class="line"><span class="language-xml">  \left. \frac</span><span class="template-variable">&#123;&#123;\<span class="name">rm</span> d&#125;u&#125;&#123;&#123;\rm d&#125;x&#125; \right| _&#123;<span class="attr">x</span>=<span class="number">0</span>&#125;</span></span><br><span class="line"><span class="template-variable">$$</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示：</li>
</ul>
<p>$$<br> \left. \frac{ { \rm d } u }{ { \rm d } x } \right| _{ x=0 }<br>$$</p>
<h2 id="4．如何输入分数"><a href="#4．如何输入分数" class="headerlink" title="4．如何输入分数"></a>4．如何输入分数</h2><p>通常使用 <code>\frac &#123;分子&#125; &#123;分母&#125;</code> 来生成一个分数，分数可多层嵌套。<br>若分数只有一层，也可使用 <code>分子 \over 分母</code> 命令。<br>例内 <code>\quad</code> <code>\mid</code> <code>\,</code> 等均为空格或分隔符号，为方便公式格式对比而添加，请注意辨别。详见<a href="#3%E5%9C%A8%E5%AD%97%E7%AC%A6%E9%97%B4%E5%8A%A0%E5%85%A5%E7%A9%BA%E6%A0%BC">在字符间加入空格</a>。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> \<span class="built_in">frac</span>&#123;a<span class="number">-1</span>&#125;&#123;b<span class="number">-1</span>&#125; \quad <span class="keyword">or</span> \quad &#123;a+<span class="number">1</span> \over b+<span class="number">1</span>&#125; <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示：$$ \frac{a-1}{b-1} \quad or \quad {a+1 \over b+1} $$</li>
</ul>
<p>当分式 <strong>仅有两个字符时</strong> 可直接输入 <code>\frac ab</code> 来快速生成一个 $\Large\frac ab$ 。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$$ <span class="string">\frac</span> <span class="number">12</span>,<span class="string">\frac</span> <span class="number">1a</span>,<span class="string">\frac</span> a2 <span class="string">\quad</span> <span class="string">\mid</span> <span class="string">\quad</span> <span class="string">\text&#123;2</span> letters only:&#125; <span class="string">\quad</span> <span class="string">\frac</span> <span class="number">12a</span> <span class="string">\,,</span> k<span class="string">\frac</span> q&#123;r^<span class="number">2</span>&#125; $$</span><br></pre></td></tr></table></figure>

<ul>
<li>显示：$$ \frac 12,\frac 1a,\frac a2 \quad \mid \quad \text{2 letters only:} \quad \frac 12a ,, k\frac q{r^2} $$</li>
</ul>
<h2 id="5．如何输入开方"><a href="#5．如何输入开方" class="headerlink" title="5．如何输入开方"></a>5．如何输入开方</h2><p>使用 <code>\sqrt [根指数，省略时为2] &#123;被开方数&#125;</code> 命令输入开方。<br>本例内 <code>\quad</code> 均为空格符号，为方便公式格式对比而添加，请注意辨别。详见<a href="#3%E5%9C%A8%E5%AD%97%E7%AC%A6%E9%97%B4%E5%8A%A0%E5%85%A5%E7%A9%BA%E6%A0%BC">在字符间加入空格</a>。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> \<span class="built_in">sqrt</span>&#123;<span class="number">2</span>&#125; \quad <span class="keyword">or</span> \quad \<span class="built_in">sqrt</span>[n]&#123;<span class="number">3</span>&#125; <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示：$$ \sqrt{2} \quad or \quad \sqrt[n]{3} $$</li>
</ul>
<h2 id="6．如何输入省略号"><a href="#6．如何输入省略号" class="headerlink" title="6．如何输入省略号"></a>6．如何输入省略号</h2><p>数学公式中常见的省略号有两种，<code>\ldots</code> 表示与 <strong>文本底线</strong> 对齐的省略号，<code>\cdots</code> 表示与 <strong>文本中线</strong> 对齐的省略号。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">$$ f(x_1,x_2,\underbrace</span><span class="template-variable">&#123;\ldots&#125;</span><span class="language-xml">_</span><span class="template-variable">&#123;\rm ldots&#125;</span><span class="language-xml"> ,x_n) = x_1^2 + x_2^2 + \underbrace</span><span class="template-variable">&#123;\cdots&#125;</span><span class="language-xml">_</span><span class="template-variable">&#123;\rm cdots&#125;</span><span class="language-xml"> + x_n^2 $$</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示：$$ f(x<em>1,x_2,\underbrace{\ldots}</em>{\rm ldots} ,x<em>n) = x_1^2 + x_2^2 + \underbrace{\cdots}</em>{\rm cdots} + x_n^2 $$</li>
</ul>
<h2 id="7．如何输入向量"><a href="#7．如何输入向量" class="headerlink" title="7．如何输入向量"></a>7．如何输入向量</h2><p>使用 <code>\vec&#123;向量&#125;</code> 来自动产生一个向量。也可以使用 <code>\overrightarrow</code> 等命令自定义字母上方的符号。<br>例内 <code>\quad</code> <code>\mid</code> <code>\,</code> 等均为空格或分隔符号，为方便公式格式对比而添加，请注意辨别。详见<a href="#3%E5%9C%A8%E5%AD%97%E7%AC%A6%E9%97%B4%E5%8A%A0%E5%85%A5%E7%A9%BA%E6%A0%BC">在字符间加入空格</a>。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> \vec&#123;a&#125; \cdot \vec&#123;b&#125;=<span class="number">0</span> <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>显示：$$ \vec{a} \cdot \vec{b}=0 $$</p>
</li>
<li><p>例子：</p>
</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$$ xy <span class="string">\text&#123;</span> <span class="keyword">with</span> arrows:&#125; <span class="string">\quad</span> <span class="string">\overleftarrow&#123;xy&#125;</span> <span class="string">\;</span> <span class="string">\mid</span> <span class="string">\;</span> <span class="string">\overleftrightarrow&#123;xy&#125;</span> <span class="string">\;</span> <span class="string">\mid</span> <span class="string">\;</span> <span class="string">\overrightarrow&#123;xy&#125;</span> $$</span><br></pre></td></tr></table></figure>

<ul>
<li>显示：$$ xy \text{ with arrows:} \quad \overleftarrow{xy} ; \mid ; \overleftrightarrow{xy} ; \mid ; \overrightarrow{xy} $$</li>
</ul>
<h2 id="8．如何输入积分"><a href="#8．如何输入积分" class="headerlink" title="8．如何输入积分"></a>8．如何输入积分</h2><p>使用 <code>\int_积分下限^积分上限 &#123;被积表达式&#125;</code> 来输入一个积分。</p>
<p>例子：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> \int_0^<span class="number">1</span> &#123;x^<span class="number">2</span>&#125; \,&#123;\rm d&#125;x <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure>

<p>显示：$$ \int_0^1 {x^2} ,{\rm d}x $$</p>
<p>本例中 <code>\,</code> 和 <code>&#123;\rm d&#125;</code> 部分可省略，但加入能使式子更美观，详见<a href="#3%E5%9C%A8%E5%AD%97%E7%AC%A6%E9%97%B4%E5%8A%A0%E5%85%A5%E7%A9%BA%E6%A0%BC">在字符间加入空格</a>及<a href="#13%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%AD%97%E4%BD%93%E8%BD%AC%E6%8D%A2">如何进行字体转换</a>。</p>
<h2 id="9．如何输入极限运算"><a href="#9．如何输入极限运算" class="headerlink" title="9．如何输入极限运算"></a>9．如何输入极限运算</h2><p>使用 <code>\lim_&#123;变量 \to 表达式&#125; 表达式</code> 来输入一个极限。如有需求，可以更改 <code>\to</code> 符号至任意符号。</p>
<p>例子：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$$ <span class="string">\lim_&#123;n</span> <span class="string">\to</span> <span class="string">\infty&#125;</span> <span class="string">\frac&#123;1&#125;&#123;n(n+1)&#125;</span> <span class="string">\quad</span> <span class="keyword">and</span> <span class="string">\quad</span> <span class="string">\lim_&#123;x\leftarrow&#123;示例&#125;&#125;</span> <span class="string">\frac&#123;1&#125;&#123;n(n+1)&#125;</span> $$</span><br></pre></td></tr></table></figure>

<p>显示：$$ \lim*{n \to \infty} \frac{1}{n(n+1)} \quad and \quad \lim*{x\leftarrow{示例}} \frac{1}{n(n+1)} $$</p>
<h2 id="10．如何输入累加、累乘运算"><a href="#10．如何输入累加、累乘运算" class="headerlink" title="10．如何输入累加、累乘运算"></a>10．如何输入累加、累乘运算</h2><p>使用 <code>\sum_&#123;下标表达式&#125;^&#123;上标表达式&#125; &#123;累加表达式&#125;</code> 来输入一个累加。与之类似，使用 <code>\prod</code> <code>\bigcup</code> <code>\bigcap</code> 来分别输入累乘、并集和交集，更多符号可参考“<a href="#12%E5%A6%82%E4%BD%95%E8%BE%93%E5%85%A5%E5%85%B6%E5%AE%83%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">其它特殊字符</a>”。</p>
<p>此类符号在行内显示时上下标表达式将会移至右上角和右下角，如 <code>\sum_&#123;i=1&#125;^n \frac&#123;1&#125;&#123;i^2&#125;</code> 显示为 $\sum_{i=1}^n \frac{1}{i^2}$ ；</p>
<p>或：</p>
<blockquote>
<p><strong>@woria</strong> 在行内可使用 <code>\sum\limits_&#123;下标表达式&#125;^&#123;上标表达式&#125; &#123;累加表达式&#125;</code> 使上下标仍在正上正下方。<br><span style="text-align: center; display: block;"> 如 <code>\sum\limits_&#123;i=1&#125;^n \frac&#123;1&#125;&#123;i^2&#125;</code> 显示为 $\sum\limits_{i=1}^n \frac{1}{i^2}$ 。</span></p>
</blockquote>
<p>本例内 <code>\quad</code> 均为空格符号，为方便公式格式对比而添加，请注意辨别。详见<a href="#3%E5%9C%A8%E5%AD%97%E7%AC%A6%E9%97%B4%E5%8A%A0%E5%85%A5%E7%A9%BA%E6%A0%BC">在字符间加入空格</a>。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$$ <span class="string">\sum_&#123;i=1&#125;^n</span> <span class="string">\frac&#123;1&#125;&#123;i^2&#125;</span> <span class="string">\quad</span> <span class="keyword">and</span> <span class="string">\quad</span> <span class="string">\prod_&#123;i=1&#125;^n</span> <span class="string">\frac&#123;1&#125;&#123;i^2&#125;</span> <span class="string">\quad</span> <span class="keyword">and</span> <span class="string">\quad</span> <span class="string">\bigcup_&#123;i=1&#125;^&#123;2&#125;</span> <span class="string">\Bbb&#123;R&#125;</span> $$</span><br></pre></td></tr></table></figure>

<ul>
<li>显示：$$ \sum*{i=1}^n \frac{1}{i^2} \quad and \quad \prod*{i=1}^n \frac{1}{i^2} \quad and \quad \bigcup_{i=1}^{2} \Bbb{R} $$</li>
</ul>
<h2 id="11．如何输入希腊字母"><a href="#11．如何输入希腊字母" class="headerlink" title="11．如何输入希腊字母"></a>11．如何输入希腊字母</h2><p>输入 <code>\小写希腊字母英文全称</code> 和 <code>\首字母大写希腊字母英文全称</code> 来分别输入小写和大写希腊字母。<br><strong>对于大写希腊字母与现有字母相同的，直接输入大写字母即可。</strong></p>
<table>
<thead>
<tr>
<th align="right">输入</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="left">显示</th>
</tr>
</thead>
<tbody><tr>
<td align="right">\alpha</td>
<td align="left">$\alpha$</td>
<td align="right">A</td>
<td align="left">$A$</td>
<td align="right">\beta</td>
<td align="left">$\beta$</td>
<td align="right">B</td>
<td align="left">$B$</td>
</tr>
<tr>
<td align="right">\gamma</td>
<td align="left">$\gamma$</td>
<td align="right">\Gamma</td>
<td align="left">$\Gamma$</td>
<td align="right">\delta</td>
<td align="left">$\delta$</td>
<td align="right">\Delta</td>
<td align="left">$\Delta$</td>
</tr>
<tr>
<td align="right">\epsilon</td>
<td align="left">$\epsilon$</td>
<td align="right">E</td>
<td align="left">$E$</td>
<td align="right">\zeta</td>
<td align="left">$\zeta$</td>
<td align="right">Z</td>
<td align="left">$Z$</td>
</tr>
<tr>
<td align="right">\eta</td>
<td align="left">$\eta$</td>
<td align="right">H</td>
<td align="left">$H$</td>
<td align="right">\theta</td>
<td align="left">$\theta$</td>
<td align="right">\Theta</td>
<td align="left">$\Theta$</td>
</tr>
<tr>
<td align="right">\iota</td>
<td align="left">$\iota$</td>
<td align="right">I</td>
<td align="left">$I$</td>
<td align="right">\kappa</td>
<td align="left">$\kappa$</td>
<td align="right">K</td>
<td align="left">$K$</td>
</tr>
<tr>
<td align="right">\lambda</td>
<td align="left">$\lambda$</td>
<td align="right">\Lambda</td>
<td align="left">$\Lambda$</td>
<td align="right">\mu</td>
<td align="left">$\mu$</td>
<td align="right">M</td>
<td align="left">$M$</td>
</tr>
<tr>
<td align="right">\nu</td>
<td align="left">$\nu$</td>
<td align="right">N</td>
<td align="left">$N$</td>
<td align="right">\xi</td>
<td align="left">$\xi$</td>
<td align="right">\Xi</td>
<td align="left">$\Xi$</td>
</tr>
<tr>
<td align="right">o</td>
<td align="left">$o$</td>
<td align="right">O</td>
<td align="left">$O$</td>
<td align="right">\pi</td>
<td align="left">$\pi$</td>
<td align="right">\Pi</td>
<td align="left">$\Pi$</td>
</tr>
<tr>
<td align="right">\rho</td>
<td align="left">$\rho$</td>
<td align="right">P</td>
<td align="left">$P$</td>
<td align="right">\sigma</td>
<td align="left">$\sigma$</td>
<td align="right">\Sigma</td>
<td align="left">$\Sigma$</td>
</tr>
<tr>
<td align="right">\tau</td>
<td align="left">$\tau$</td>
<td align="right">T</td>
<td align="left">$T$</td>
<td align="right">\upsilon</td>
<td align="left">$\upsilon$</td>
<td align="right">\Upsilon</td>
<td align="left">$\Upsilon$</td>
</tr>
<tr>
<td align="right">\phi</td>
<td align="left">$\phi$</td>
<td align="right">\Phi</td>
<td align="left">$\Phi$</td>
<td align="right">\chi</td>
<td align="left">$\chi$</td>
<td align="right">X</td>
<td align="left">$X$</td>
</tr>
<tr>
<td align="right">\psi</td>
<td align="left">$\psi$</td>
<td align="right">\Psi</td>
<td align="left">$\Psi$</td>
<td align="right">\omega</td>
<td align="left">$\omega$</td>
<td align="right">\Omega</td>
<td align="left">$\Omega$</td>
</tr>
</tbody></table>
<p><strong>部分字母有变量专用形式，以 <code>\var-</code> 开头。</strong></p>
<table>
<thead>
<tr>
<th align="center">小写形式</th>
<th align="center">大写形式</th>
<th align="center">变量形式</th>
<th align="center">显示</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\epsilon</td>
<td align="center">E</td>
<td align="center">\varepsilon</td>
<td align="center">$\epsilon \mid E \mid \varepsilon$</td>
</tr>
<tr>
<td align="center">\theta</td>
<td align="center">\Theta</td>
<td align="center">\vartheta</td>
<td align="center">$\theta \mid \Theta \mid \vartheta$</td>
</tr>
<tr>
<td align="center">\rho</td>
<td align="center">P</td>
<td align="center">\varrho</td>
<td align="center">$\rho \mid P \mid \varrho$</td>
</tr>
<tr>
<td align="center">\sigma</td>
<td align="center">\Sigma</td>
<td align="center">\varsigma</td>
<td align="center">$\sigma \mid \Sigma \mid \varsigma$</td>
</tr>
<tr>
<td align="center">\phi</td>
<td align="center">\Phi</td>
<td align="center">\varphi</td>
<td align="center">$\phi \mid \Phi \mid \varphi$</td>
</tr>
</tbody></table>
<h2 id="12．如何输入其它特殊字符"><a href="#12．如何输入其它特殊字符" class="headerlink" title="12．如何输入其它特殊字符"></a>12．如何输入其它特殊字符</h2><blockquote>
<p><strong>完整的 $\LaTeX$ 可用符号列表可以在 <a href="https://mirror.its.dal.ca/ctan/info/symbols/comprehensive/symbols-a4.pdf">这份文档</a> 中查阅（极长，共 348 页），大部分常用符号可以参阅 <a href="https://pic.plover.com/MISC/symbols.pdf">这份精简版文档</a> 查询。</strong>需要注意的是，$\LaTeX$ 符号并不保证在 MathJax v2.2 中可用，即在 Cmd Markdown 编辑阅读器中可能并不支持所输入的特定命令。</p>
</blockquote>
<blockquote>
<p>若需要显示更大或更小的字符，在符号前插入 <code>\large</code> 或 <code>\small</code> 命令。<br>MathJax 针对任意元素均提供从小至大 <code>\tiny</code> <code>\Tiny</code> <code>\scriptsize</code> <code>\small</code> <code>*默认值 \normalsize</code> <code>\large</code> <code>\Large</code> <code>\LARGE</code> <code>\huge</code> <code>\Huge</code> 共十种渲染大小，详见<a href="http://docs.mathjax.org/en/latest/input/tex/extensions/textmacros.html#size-control">官方文档</a>。</p>
</blockquote>
<blockquote>
<p><a href="http://detexify.kirelabs.org/classify.html">若找不到需要的符号，推荐使用 $\large\rm{Detexify}$ 来画出想要的符号</a> &gt; <span style="text-align: center; display: block"> &gt; <img src="https://cdn.ericp.cn/img/202009/b0fe4b234a3fc.png" alt="detexify_t"></span></p>
</blockquote>
<h3 id="1-．关系运算符"><a href="#1-．关系运算符" class="headerlink" title="(1)．关系运算符"></a>(1)．关系运算符</h3><table>
<thead>
<tr>
<th align="right">输入</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="left">显示</th>
</tr>
</thead>
<tbody><tr>
<td align="right">\pm</td>
<td align="left">$\pm$</td>
<td align="right">\times</td>
<td align="left">$\times$</td>
<td align="right">\div</td>
<td align="left">$\div$</td>
<td align="right">\mid</td>
<td align="left">$\mid$</td>
</tr>
<tr>
<td align="right">\nmid</td>
<td align="left">$\nmid$</td>
<td align="right">\cdot</td>
<td align="left">$\cdot$</td>
<td align="right">\circ</td>
<td align="left">$\circ$</td>
<td align="right">\ast</td>
<td align="left">$\ast$</td>
</tr>
<tr>
<td align="right">\odot</td>
<td align="left">$\odot$</td>
<td align="right">\otimes</td>
<td align="left">$\otimes$</td>
<td align="right">\oplus</td>
<td align="left">$\oplus$</td>
<td align="right">\leq</td>
<td align="left">$\leq$</td>
</tr>
<tr>
<td align="right">\geq</td>
<td align="left">$\geq$</td>
<td align="right">\neq</td>
<td align="left">$\neq$</td>
<td align="right">\approx</td>
<td align="left">$\approx$</td>
<td align="right">\equiv</td>
<td align="left">$\equiv$</td>
</tr>
<tr>
<td align="right">\sum</td>
<td align="left">$\sum$</td>
<td align="right">\prod</td>
<td align="left">$\prod$</td>
<td align="right">\coprod</td>
<td align="left">$\coprod$</td>
<td align="right">\backslash</td>
<td align="left">$\backslash$</td>
</tr>
</tbody></table>
<h3 id="2-．集合运算符"><a href="#2-．集合运算符" class="headerlink" title="(2)．集合运算符"></a>(2)．集合运算符</h3><table>
<thead>
<tr>
<th align="right">输入</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="left">显示</th>
</tr>
</thead>
<tbody><tr>
<td align="right">\emptyset</td>
<td align="left">$\emptyset$</td>
<td align="right">\in</td>
<td align="left">$\in$</td>
<td align="right">\notin</td>
<td align="left">$\notin$</td>
</tr>
<tr>
<td align="right">\subset</td>
<td align="left">$\subset$</td>
<td align="right">\supset</td>
<td align="left">$\supset$</td>
<td align="right">\subseteq</td>
<td align="left">$\subseteq$</td>
</tr>
<tr>
<td align="right">\supseteq</td>
<td align="left">$\supseteq$</td>
<td align="right">\cap</td>
<td align="left">$\cap$</td>
<td align="right">\cup</td>
<td align="left">$\cup$</td>
</tr>
<tr>
<td align="right">\vee</td>
<td align="left">$\vee$</td>
<td align="right">\wedge</td>
<td align="left">$\wedge$</td>
<td align="right">\uplus</td>
<td align="left">$\uplus$</td>
</tr>
<tr>
<td align="right">\top</td>
<td align="left">$\top$</td>
<td align="right">\bot</td>
<td align="left">$\bot$</td>
<td align="right">\complement</td>
<td align="left">$\complement$</td>
</tr>
</tbody></table>
<h3 id="3-．对数运算符"><a href="#3-．对数运算符" class="headerlink" title="(3)．对数运算符"></a>(3)．对数运算符</h3><table>
<thead>
<tr>
<th align="right">输入</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="left">显示</th>
</tr>
</thead>
<tbody><tr>
<td align="right">\log</td>
<td align="left">$\log$</td>
<td align="right">\lg</td>
<td align="left">$\lg$</td>
<td align="right">\ln</td>
<td align="left">$\ln$</td>
</tr>
</tbody></table>
<h3 id="4-．三角运算符"><a href="#4-．三角运算符" class="headerlink" title="(4)．三角运算符"></a>(4)．三角运算符</h3><table>
<thead>
<tr>
<th align="right">输入</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="left">显示</th>
</tr>
</thead>
<tbody><tr>
<td align="right">\backsim</td>
<td align="left">$\backsim$</td>
<td align="right">\cong</td>
<td align="left">$\cong$</td>
<td align="right">\angle A</td>
<td align="left">$\angle A$</td>
</tr>
<tr>
<td align="right">\sin</td>
<td align="left">$\sin$</td>
<td align="right">\cos</td>
<td align="left">$\cos$</td>
<td align="right">\tan</td>
<td align="left">$\tan$</td>
</tr>
<tr>
<td align="right">\csc</td>
<td align="left">$\csc$</td>
<td align="right">\sec</td>
<td align="left">$\sec$</td>
<td align="right">\cot</td>
<td align="left">$\cot$</td>
</tr>
</tbody></table>
<h3 id="5-．微积分运算符"><a href="#5-．微积分运算符" class="headerlink" title="(5)．微积分运算符"></a>(5)．微积分运算符</h3><table>
<thead>
<tr>
<th align="right">输入</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="left">显示</th>
</tr>
</thead>
<tbody><tr>
<td align="right">\int</td>
<td align="left">$\int$</td>
<td align="right">\iint</td>
<td align="left">$\iint$</td>
<td align="right">\iiint</td>
<td align="left">$\iiint$</td>
</tr>
<tr>
<td align="right">\partial</td>
<td align="left">$\partial$</td>
<td align="right">\oint</td>
<td align="left">$\oint$</td>
<td align="right">\prime</td>
<td align="left">$\prime$</td>
</tr>
<tr>
<td align="right">\lim</td>
<td align="left">$\lim$</td>
<td align="right">\infty</td>
<td align="left">$\infty$</td>
<td align="right">\nabla</td>
<td align="left">$\nabla$</td>
</tr>
</tbody></table>
<h3 id="6-．逻辑运算符"><a href="#6-．逻辑运算符" class="headerlink" title="(6)．逻辑运算符"></a>(6)．逻辑运算符</h3><table>
<thead>
<tr>
<th align="right">输入</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="left">显示</th>
</tr>
</thead>
<tbody><tr>
<td align="right">\because</td>
<td align="left">$\because$</td>
<td align="right">\therefore</td>
<td align="left">$\therefore$</td>
<td align="right">\neg</td>
<td align="left">$\neg$</td>
</tr>
<tr>
<td align="right">\forall</td>
<td align="left">$\forall$</td>
<td align="right">\exists</td>
<td align="left">$\exists$</td>
<td align="right">\not\subset</td>
<td align="left">$\not\subset$</td>
</tr>
<tr>
<td align="right">\not&lt;</td>
<td align="left">$\not&lt;$</td>
<td align="right">\not&gt;</td>
<td align="left">$\not&gt;$</td>
<td align="right">\not=</td>
<td align="left">$\not=$</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>@xiaobanni</strong><br><span style="text-align: center; display: block"> <code>\vdash</code> 显示为 $\vdash$ </span></p>
</blockquote>
<h3 id="7-．戴帽符号"><a href="#7-．戴帽符号" class="headerlink" title="(7)．戴帽符号"></a>(7)．戴帽符号</h3><table>
<thead>
<tr>
<th align="right">输入</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="left">显示</th>
</tr>
</thead>
<tbody><tr>
<td align="right">\hat{xy}</td>
<td align="left">$\hat{xy}$</td>
<td align="right">\widehat{xyz}</td>
<td align="left">$\widehat{xyz}$</td>
<td align="right">\bar{y}</td>
<td align="left">$\bar{y}$</td>
</tr>
<tr>
<td align="right">\tilde{xy}</td>
<td align="left">$\tilde{xy}$</td>
<td align="right">\widetilde{xyz}</td>
<td align="left">$\widetilde{xyz}$</td>
<td align="right">\acute{y}</td>
<td align="left">$\acute{y}$</td>
</tr>
<tr>
<td align="right">\breve{y}</td>
<td align="left">$\breve{y}$</td>
<td align="right">\check{y}</td>
<td align="left">$\check{y}$</td>
<td align="right">\grave{y}</td>
<td align="left">$\grave{y}$</td>
</tr>
<tr>
<td align="right">\dot{x}</td>
<td align="left">$\dot{x}$</td>
<td align="right">\ddot{x}</td>
<td align="left">$\ddot{x}$</td>
<td align="right">\dddot{x}</td>
<td align="left">$\dddot{x}$</td>
</tr>
</tbody></table>
<p>若需要在特定文字顶部\底部放置内容，可使用 <code>\overset&#123;顶部内容&#125;&#123;正常内容&#125;</code> 和 <code>\underset&#123;底部内容&#125;&#123;正常内容&#125;</code> 命令。<br>例内 <code>\qquad</code> <code>\quad</code> <code>\mid</code> <code>\;</code> <code>\,</code> 等均为空格或分隔符号，为方便公式格式对比而添加，请注意辨别。详见<a href="#3%E5%9C%A8%E5%AD%97%E7%AC%A6%E9%97%B4%E5%8A%A0%E5%85%A5%E7%A9%BA%E6%A0%BC">在字符间加入空格</a>。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$$ <span class="string">\verb+\overset&#123;above&#125;&#123;level&#125;+</span> <span class="string">\qquad</span> <span class="string">\overset&#123;xx&#125;&#123;ABC&#125;</span> <span class="string">\;\;</span> <span class="string">\mid</span> <span class="string">\quad</span> <span class="string">\overset&#123;x^2&#125;&#123;\longmapsto&#125;\</span> <span class="string">\,</span> <span class="string">\mid</span> <span class="string">\quad</span> <span class="string">\overset&#123;\bullet\circ\circ\bullet&#125;&#123;T&#125;</span> $$</span><br></pre></td></tr></table></figure>

<ul>
<li><p>显示：<br>$$ \verb+\overset{above}{level}+ \qquad \overset{xx}{ABC} ;; \mid \quad \overset{x^2}{\longmapsto}\ , \mid \quad \overset{\bullet\circ\circ\bullet}{T} $$</p>
</li>
<li><p>例子：</p>
</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$$ <span class="string">\verb+\underset&#123;below&#125;&#123;level&#125;+</span> <span class="string">\qquad</span> <span class="string">\underset&#123;xx&#125;&#123;ABC&#125;</span> <span class="string">\;\;</span> <span class="string">\mid</span> <span class="string">\quad</span> <span class="string">\underset&#123;x^2&#125;&#123;\longmapsto&#125;\</span> <span class="string">\,</span> <span class="string">\mid</span> <span class="string">\quad</span> <span class="string">\underset&#123;\bullet\circ\circ\bullet&#125;&#123;T&#125;</span> $$</span><br></pre></td></tr></table></figure>

<ul>
<li>显示：<br>$$ \verb+\underset{below}{level}+ \qquad \underset{xx}{ABC} ;; \mid \quad \underset{x^2}{\longmapsto}\ , \mid \quad \underset{\bullet\circ\circ\bullet}{T} $$</li>
</ul>
<p>此命令可叠加嵌套使用，生成类似化学反应式的多重条件符号，<br>如 <code>\overset&#123;H_2&#125;&#123;\underset&#123;1300℃&#125;&#123;\Longleftrightarrow&#125;&#125;</code>：<br>$$ \rm{SrO+V^{&#39;&#39;}<em>{Sr} \overset{H_2}{\underset{1300℃}{\Longleftrightarrow}} Sr^{\times}_{Sr}+2e^{&#39;}+\frac 12O<em>2(g)} $$ 和 <code>\overset&#123;Surface/bulk&#125;&#123;\underset&#123;diffusion&#125;&#123;\longleftrightarrow&#125;&#125;</code>：<br>$$ \rm{2OH^{\circ}</em>{O(STN)}+2O^{\times}</em>{O(YSZ)} ; \overset{Surface/bulk}{\underset{diffusion}{\longleftrightarrow}} ;; 2OH^{\circ}<em>{O(YSZ)}+2O^{\times}\</em>{O(STN)}} $$</p>
<p>在书写化学方程式时可声明 <code>\require&#123;AMDcd&#125;</code> 语句，使用 MathJax 内置的交换图表功能，具体例子可<a href="#1%E5%A6%82%E4%BD%95%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E4%BA%A4%E6%8D%A2%E5%9B%BE%E8%A1%A8">参见下文</a>。</p>
<h3 id="8-．连线符号"><a href="#8-．连线符号" class="headerlink" title="(8)．连线符号"></a>(8)．连线符号</h3><p>其它可用的文字修饰符可参见官方文档 <a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference#answer-13081">&quot;Additional decorations&quot;</a>。</p>
<table>
<thead>
<tr>
<th align="center">输入</th>
<th align="center">显示</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\fbox{a+b+c+d} <span style="display: block"><strong>高级框选需<a href="#5%E6%B7%BB%E5%8A%A0%E5%88%A0%E9%99%A4%E7%BA%BF">声明 <code>enclose</code> 标签</a></strong></span></td>
<td align="center">$\fbox{a+b+c+d}$</td>
</tr>
<tr>
<td align="center">\overleftarrow{a+b+c+d}</td>
<td align="center">$\overleftarrow{a+b+c+d}$</td>
</tr>
<tr>
<td align="center">\overrightarrow{a+b+c+d}</td>
<td align="center">$\overrightarrow{a+b+c+d}$</td>
</tr>
<tr>
<td align="center">\overleftrightarrow{a+b+c+d}</td>
<td align="center">$\overleftrightarrow{a+b+c+d}$</td>
</tr>
<tr>
<td align="center">\underleftarrow{a+b+c+d}</td>
<td align="center">$\underleftarrow{a+b+c+d}$</td>
</tr>
<tr>
<td align="center">\underrightarrow{a+b+c+d}</td>
<td align="center">$\underrightarrow{a+b+c+d}$</td>
</tr>
<tr>
<td align="center">\underleftrightarrow{a+b+c+d}</td>
<td align="center">$\underleftrightarrow{a+b+c+d}$</td>
</tr>
<tr>
<td align="center">\overline{a+b+c+d}</td>
<td align="center">$\overline{a+b+c+d}$</td>
</tr>
<tr>
<td align="center">\underline{a+b+c+d}</td>
<td align="center">$\underline{a+b+c+d}$</td>
</tr>
<tr>
<td align="center">\overbrace{a+b+c+d}^{Sample}</td>
<td align="center">$\overbrace{a+b+c+d}^{Sample}$</td>
</tr>
<tr>
<td align="center">\underbrace{a+b+c+d}_{Sample}</td>
<td align="center">$\underbrace{a+b+c+d}_{Sample}$</td>
</tr>
<tr>
<td align="center">\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}</td>
<td align="center">$\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$</td>
</tr>
<tr>
<td align="center">\underbrace{a\cdot a\cdots a}_{b\text{ times}}</td>
<td align="center">$\underbrace{a\cdot a\cdots a}_{b\text{ times}}$</td>
</tr>
</tbody></table>
<h3 id="9-．箭头符号"><a href="#9-．箭头符号" class="headerlink" title="(9)．箭头符号"></a>(9)．箭头符号</h3><ul>
<li>推荐使用符号：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">输入</th>
<th align="center">显示</th>
<th align="center">输入</th>
<th align="center">显示</th>
<th align="center">输入</th>
<th align="center">显示</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\to</td>
<td align="center">$\to$</td>
<td align="center">\mapsto</td>
<td align="center">$\mapsto$</td>
<td align="center">\underrightarrow{1℃/min}</td>
<td align="center">$\underrightarrow{1℃/min}$</td>
</tr>
<tr>
<td align="center">\implies</td>
<td align="center">$\implies$</td>
<td align="center">\iff</td>
<td align="center">$\iff$</td>
<td align="center">\impliedby</td>
<td align="center">$\impliedby$</td>
</tr>
</tbody></table>
<ul>
<li>其它可用符号：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">输入</th>
<th align="center">显示</th>
<th align="center">输入</th>
<th align="center">显示</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\uparrow</td>
<td align="center">$\uparrow$</td>
<td align="center">\Uparrow</td>
<td align="center">$\Uparrow$</td>
</tr>
<tr>
<td align="center">\downarrow</td>
<td align="center">$\downarrow$</td>
<td align="center">\Downarrow</td>
<td align="center">$\Downarrow$</td>
</tr>
<tr>
<td align="center">\leftarrow</td>
<td align="center">$\leftarrow$</td>
<td align="center">\Leftarrow</td>
<td align="center">$\Leftarrow$</td>
</tr>
<tr>
<td align="center">\rightarrow</td>
<td align="center">$\rightarrow$</td>
<td align="center">\Rightarrow</td>
<td align="center">$\Rightarrow$</td>
</tr>
<tr>
<td align="center">\leftrightarrow</td>
<td align="center">$\leftrightarrow$</td>
<td align="center">\Leftrightarrow</td>
<td align="center">$\Leftrightarrow$</td>
</tr>
<tr>
<td align="center">\longleftarrow</td>
<td align="center">$\longleftarrow$</td>
<td align="center">\Longleftarrow</td>
<td align="center">$\Longleftarrow$</td>
</tr>
<tr>
<td align="center">\longrightarrow</td>
<td align="center">$\longrightarrow$</td>
<td align="center">\Longrightarrow</td>
<td align="center">$\Longrightarrow$</td>
</tr>
<tr>
<td align="center">\longleftrightarrow</td>
<td align="center">$\longleftrightarrow$</td>
<td align="center">\Longleftrightarrow</td>
<td align="center">$\Longleftrightarrow$</td>
</tr>
</tbody></table>
<h2 id="13．如何进行字体转换"><a href="#13．如何进行字体转换" class="headerlink" title="13．如何进行字体转换"></a>13．如何进行字体转换</h2><p>若要对公式的某一部分字符进行字体转换，可以用 <code>&#123;\字体 &#123;需转换的部分字符&#125;&#125;</code> 命令，其中 <code>\字体</code> 部分可以参照下表选择合适的字体。一般情况下，公式默认为斜体字 $italic$ 。</p>
<p>示例中 <strong>全部大写</strong> 的字体仅大写可用。</p>
<table>
<thead>
<tr>
<th align="right">输入</th>
<th align="center">全字母可用</th>
<th align="left">显示</th>
<th align="right">输入</th>
<th align="center">仅大写可用</th>
<th align="left">显示</th>
</tr>
</thead>
<tbody><tr>
<td align="right">\rm</td>
<td align="center">罗马体</td>
<td align="left">$\rm{Sample}$</td>
<td align="right"><strong>\mathcal</strong></td>
<td align="center"><strong>花体（数学符号等）</strong></td>
<td align="left">$\mathcal{SAMPLE}$</td>
</tr>
<tr>
<td align="right">\it</td>
<td align="center">斜体</td>
<td align="left">$\it{Sample}$</td>
<td align="right"><strong>\mathbb</strong></td>
<td align="center"><strong>黑板粗体（定义域等）</strong></td>
<td align="left">$\mathbb{SAMPLE}$</td>
</tr>
<tr>
<td align="right">\bf</td>
<td align="center">粗体</td>
<td align="left">$\bf{Sample}$</td>
<td align="right">\mit</td>
<td align="center">数学斜体</td>
<td align="left">$\mit{SAMPLE}$</td>
</tr>
<tr>
<td align="right">\sf</td>
<td align="center">等线体</td>
<td align="left">$\sf{Sample}$</td>
<td align="right">\scr</td>
<td align="center">手写体</td>
<td align="left">$\scr{SAMPLE}$</td>
</tr>
<tr>
<td align="right">\tt</td>
<td align="center">打字机体</td>
<td align="left">$\tt{Sample}$</td>
<td align="right">\cal</td>
<td align="center">等同于 <code>\mathcal</code></td>
<td align="left">$\cal{ABCXYZ}$</td>
</tr>
<tr>
<td align="right">\frak</td>
<td align="center">旧德式字体</td>
<td align="left">$\frak{Sample}$</td>
<td align="right">\Bbb</td>
<td align="center">等同于 <code>\mathbb</code></td>
<td align="left">$\Bbb{ABCXYZ}$</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>@lymd</strong> <code>\boldsymbol&#123;\alpha&#125;</code> 用来表示向量或者矩阵的加粗斜体，如向量 $\boldsymbol{\vec\alpha}$ 。</p>
</blockquote>
<p>转换字体十分常用，例如在积分中：</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\begin&#123;array&#125;&#123;cc&#125;</span></span><br><span class="line">    <span class="string">\mathrm&#123;Bad&#125;</span> &amp; <span class="string">\mathrm&#123;Better&#125;</span> <span class="string">\\</span></span><br><span class="line">    <span class="string">\hline</span> <span class="string">\\</span></span><br><span class="line">    <span class="string">\int_0^1</span> x^<span class="number">2</span> dx &amp; <span class="string">\int_0^1</span> x^<span class="number">2</span> <span class="string">\,&#123;\rm</span> d&#125;x</span><br><span class="line"><span class="string">\end&#123;array&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示：<br>$$<br>\begin{array}{cc}<br>  \mathrm{Bad} &amp; \mathrm{Better} \<br>  \hline \<br>  \int_0^1 x^2 dx &amp; \int_0^1 x^2 ,{\rm d}x<br>\end{array}<br>$$</li>
</ul>
<p>注意比较两个式子间 $dx$ 与 ${\rm d} x$ 的不同。<br>使用 <code>\operatorname</code> 命令也可以达到相同的效果，详见<a href="#1%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6-operatorname">定义新的运算符</a>。</p>
<h2 id="14．如何高亮一行公式"><a href="#14．如何高亮一行公式" class="headerlink" title="14．如何高亮一行公式"></a>14．如何高亮一行公式</h2><p>使用 <code>\bbox[底色, (可选)边距, (可选)边框 border: 框宽度 框类型 框颜色]</code> 命令来高亮一行公式。<br>底色和框颜色支持详见“<a href="#4%E6%9B%B4%E6%94%B9%E6%96%87%E5%AD%97%E9%A2%9C%E8%89%B2-color">更改文字颜色</a>”，边距及框宽度支持 <code>绝对像素 px</code> 或 <code>相对大小 em</code>，框类型支持 <code>实线 solid</code> 或 <code>虚线 dashed</code>。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line"><span class="string">\bbox[yellow]&#123;</span></span><br><span class="line">    e^x=<span class="string">\lim_&#123;n\to\infty&#125;</span> <span class="string">\left(</span> <span class="number">1</span>+<span class="string">\frac&#123;x&#125;&#123;n&#125;</span> <span class="string">\right)^n</span> <span class="string">\qquad</span> (<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<ul>
<li>显示：</li>
</ul>
<p>$$<br>\bbox[yellow]{<br>    e^x=\lim_{n\to\infty} \left( 1+\frac{x}{n} \right)^n \qquad (1)<br>}<br>$$</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line"><span class="string">\bbox[#9ff,</span> <span class="number">5px</span>]&#123; % 此处向外添加 <span class="number">5</span> 像素的边距</span><br><span class="line">    e^x=<span class="string">\lim_&#123;n\to\infty&#125;</span> <span class="string">\left(</span> <span class="number">1</span>+<span class="string">\frac&#123;x&#125;&#123;n&#125;</span> <span class="string">\right)^n</span> <span class="string">\qquad</span> (<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<ul>
<li>显示：</li>
</ul>
<p>$$<br>\bbox[#9ff, 5px]{<br>    e^x=\lim_{n\to\infty} \left( 1+\frac{x}{n} \right)^n \qquad (1)<br>}<br>$$</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span><span class="variable">$</span></span><br><span class="line">% 此处使用 <span class="number">0.5</span> 倍行高作为边距，附加 <span class="number">2</span> 像素的实线边框（Ctrl+Alt+Y 可见）</span><br><span class="line">\bbox[<span class="comment">#2f3542, 0.5em, border:2px solid #f1f2f6]&#123;</span></span><br><span class="line">    \<span class="type">color</span>&#123; <span class="comment">#f1f2f6&#125;&#123;e^x=\lim_&#123;n\to\infty&#125; \left( 1+\frac&#123;x&#125;&#123;n&#125; \right)^n \qquad (1)&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$</span><span class="variable">$</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示：</li>
</ul>
<p>$$<br>\bbox[#2f3542, 0.5em, border:2px solid #f1f2f6]{<br>    \color{ #f1f2f6 }{<br>        e^x=\lim_{n\to\infty} \left( 1+\frac{x}{n} \right)^n \qquad (1)<br>    }<br>}<br>$$</p>
<h2 id="15．大括号和行标的使用"><a href="#15．大括号和行标的使用" class="headerlink" title="15．大括号和行标的使用"></a>15．大括号和行标的使用</h2><p>在 <code>\left</code> 和 <code>\right</code> 之后加上要使用的括号来创建自动匹配高度的圆括号 <code>(</code> <code>)</code>，方括号 <code>[</code> <code>]</code> 和花括号 <code>\&#123;</code> <code>\&#125;</code>。<br>在每个公式末尾前使用 <code>\tag &#123;行标&#125;</code> 来实现行标。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">f<span class="keyword">\left</span>(</span><br><span class="line">   <span class="keyword">\left</span>[</span><br><span class="line">     <span class="keyword">\frac</span>&#123;</span><br><span class="line">       1+<span class="keyword">\left</span><span class="keyword">\&#123;</span>x,y<span class="keyword">\right</span><span class="keyword">\&#125;</span></span><br><span class="line">     &#125;&#123;</span><br><span class="line">       <span class="keyword">\left</span>(</span><br><span class="line">          <span class="keyword">\frac</span> xy + <span class="keyword">\frac</span> yx</span><br><span class="line">       <span class="keyword">\right</span>)</span><br><span class="line">       (u+1)</span><br><span class="line">     &#125;+a</span><br><span class="line">   <span class="keyword">\right</span>]<span class="built_in">^</span>&#123;3/2&#125;</span><br><span class="line"><span class="keyword">\right</span>)</span><br><span class="line"><span class="keyword">\tag</span> &#123;行标&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示：</li>
</ul>
<p>$$<br>f\left(<br>   \left[<br>     \frac{<br>       1+\left{x,y\right}<br>     }{<br>       \left(<br>          \frac xy + \frac yx<br>       \right)<br>       (u+1)<br>     }+a<br>   \right]^{3/2}<br>\right)<br>\tag {行标}<br>$$</p>
<p>如果你需要在不同的行显示对应括号，可以在每一行对应处使用 <code>\left.</code> 或 <code>\right.</code> 来放一个“不存在的括号”。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align*&#125;</span><br><span class="line">    a=<span class="built_in">&amp;</span><span class="keyword">\left</span>(1+2+3+ <span class="keyword">\cdots</span> <span class="keyword">\right</span>. <span class="keyword">\\</span></span><br><span class="line">      <span class="built_in">&amp;</span><span class="keyword">\cdots</span>+<span class="keyword">\left</span>. <span class="keyword">\infty</span>-2+<span class="keyword">\infty</span>-1+<span class="keyword">\infty</span><span class="keyword">\right</span>)</span><br><span class="line"><span class="keyword">\end</span>&#123;align*&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示：</li>
</ul>
<p>$$<br>\begin{align*}<br>    a=&amp;\left(1+2+3+ \cdots \right. \<br>      &amp;\cdots+\left. \infty-2+\infty-1+\infty\right)<br>\end{align*}<br>$$</p>
<p>如果你需要将大括号里面显示的分隔符也变大，可以使用 <code>\middle</code> 命令，此处分别使用单竖线 <code>|</code> 和双竖线 <code>\\|</code> 。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\left</span><span class="keyword">\langle</span></span><br><span class="line">    q <span class="keyword">\;</span> <span class="keyword">\middle</span>|</span><br><span class="line">        <span class="keyword">\frac</span>&#123;<span class="keyword">\frac</span> xy&#125;&#123;<span class="keyword">\frac</span> uv&#125;</span><br><span class="line">    <span class="keyword">\middle</span><span class="keyword">\|</span> p</span><br><span class="line"><span class="keyword">\right</span><span class="keyword">\rangle</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示：</li>
</ul>
<p>$$<br>\left\langle<br>    q ; \middle|<br>        \frac{\frac xy}{\frac uv}<br>    \middle| p<br>\right\rangle<br>$$</p>
<h2 id="16．其它命令"><a href="#16．其它命令" class="headerlink" title="16．其它命令"></a>16．其它命令</h2><h3 id="1-．定义新的运算符-operatorname"><a href="#1-．定义新的运算符-operatorname" class="headerlink" title="(1)．定义新的运算符 \operatorname"></a>(1)．定义新的运算符 \operatorname</h3><p>当需要使用的运算符不在 MathJax 的内置库中时，程序可能会报错或产生错误的渲染结果。此时可以使用 <code>\operatorname</code> 命令定义一个新的运算符号。</p>
<ul>
<li><strong>反例：</strong></li>
</ul>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\begin&#123;array&#125;&#123;c|c&#125;</span></span><br><span class="line">    <span class="string">\mathrm&#123;Error&#125;</span> &amp; <span class="string">\text&#123;Wrong</span> rendering&#125; <span class="string">\\</span></span><br><span class="line">    <span class="string">\hline</span> <span class="string">\\</span></span><br><span class="line">    <span class="string">\arsinh(x)</span> &amp; arsinh(x) <span class="string">\\</span></span><br><span class="line">    <span class="string">\Res_&#123;z=1&#125;</span> &amp; Res_&#123;z=<span class="number">1</span>&#125;&#123;<span class="string">\frac&#123;1&#125;&#123;z^2-z&#125;=1&#125;</span> <span class="string">\\</span></span><br><span class="line"><span class="string">\end&#123;array&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示：<br>$$<br>\begin{array}{c|c}<pre><code>\mathrm&#123;Error&#125; &amp; \text&#123;Wrong rendering&#125; \\
\hline \\
\arsinh(x) &amp; arsinh(x) \\
\Res_&#123;z=1&#125; &amp; Res_&#123;z=1&#125;&#123;\frac&#123;1&#125;&#123;z^2-z&#125;=1&#125; \\
</code></pre>
\end{array}<br>$$</li>
</ul>
<p>使用 <code>\operatorname&#123;运算符&#125;&#123;式子&#125;</code> 来生成一个普通运算，或使用 <code>\operatorname*&#123;运算符&#125;_&#123;下标&#125;^&#123;上标&#125;&#123;式子&#125;</code> 来生成一个含上下标的自定义运算。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">\begin</span><span class="template-variable">&#123;array&#125;</span><span class="template-variable">&#123;c|c&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    \text</span><span class="template-variable">&#123;Normal Operator&#125;</span><span class="language-xml"> &amp; \text</span><span class="template-variable">&#123;Operator with label above and below&#125;</span><span class="language-xml"> \\</span></span><br><span class="line"><span class="language-xml">    \hline \\</span></span><br><span class="line"><span class="language-xml">    \scriptsize\text</span><span class="template-variable">&#123;\operatorname&#123;arsinh&#125;</span><span class="template-variable">&#123;x&#125;</span><span class="language-xml">&#125; &amp; \scriptsize\text</span><span class="template-variable">&#123;\operatorname*&#123;Res&#125;</span><span class="language-xml">_</span><span class="template-variable">&#123;z=1&#125;</span><span class="template-variable">&#123;\frac&#123;1&#125;</span><span class="template-variable">&#123;z^2-z&#125;</span><span class="language-xml">=1&#125;&#125; \\</span></span><br><span class="line"><span class="language-xml">    \operatorname</span><span class="template-variable">&#123;arsinh&#125;</span><span class="template-variable">&#123;x&#125;</span><span class="language-xml"> &amp; \operatorname*</span><span class="template-variable">&#123;Res&#125;</span><span class="language-xml">_</span><span class="template-variable">&#123;z=1&#125;</span><span class="template-variable">&#123;\frac&#123;1&#125;</span><span class="template-variable">&#123;z^2-z&#125;</span><span class="language-xml">=1&#125; \\</span></span><br><span class="line"><span class="language-xml">\end</span><span class="template-variable">&#123;array&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示：<br>$$<br>\begin{array}{c|c}<br>  \text{Normal Operator} &amp; \text{Operator with label above and below} \<br>  \scriptsize\text{\operatorname{arsinh}{x}} &amp; \scriptsize\text{\operatorname*{Res}<em>{z=1}{\frac{1}{z^2-z}=1}} \[2ex]<br>  \hline \<br>  \operatorname{arsinh}{x} &amp; \operatorname*{Res}</em>{z=1}{\frac{1}{z^2-z}=1}<br>\end{array}<br>$$</li>
</ul>
<p>查询<a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference/15077#15077">关于此命令的定义</a>和<a href="http://meta.math.stackexchange.com/search?q=operatorname">关于此命令的讨论</a>来进一步了解此命令。</p>
<h3 id="2-．添加注释文字-text"><a href="#2-．添加注释文字-text" class="headerlink" title="(2)．添加注释文字 \text"></a>(2)．添加注释文字 \text</h3><p>在 <code>\text &#123;文字&#125;</code> 中仍可以使用 <code>$公式$</code> 插入其它公式。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> f(n)= \begin&#123;cases&#125; n/<span class="number">2</span>, &amp; \text &#123;<span class="keyword">if</span> <span class="symbol">$</span>n<span class="symbol">$</span> is even&#125; \\ <span class="number">3</span>n+<span class="number">1</span>, &amp; \text&#123;<span class="keyword">if</span> <span class="symbol">$</span>n<span class="symbol">$</span> is odd&#125; \end&#123;cases&#125; <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示：<br>$$<br>f(n)= \begin{cases} n/2, &amp; \text {if $n$ is even} \ 3n+1, &amp; \text{if $n$ is odd} \end{cases}<br>$$</li>
</ul>
<h3 id="3-．在字符间加入空格"><a href="#3-．在字符间加入空格" class="headerlink" title="(3)．在字符间加入空格"></a>(3)．在字符间加入空格</h3><p>有四种宽度的空格可以使用： <code>\,</code>、<code>\;</code>、<code>\quad</code> 和 <code>\qquad</code>，灵活使用 <code>\text&#123;n个空格&#125;</code> 也可以在任意位置实现空格。<br>同时存在一种负空格 <code>\!</code> 用来减小字符间距，一般在物理单位中使用。<br><strong>重复使用 <code>\!</code> 命令能够实现不同元素的叠加渲染，如$\wedge!!!!!!!!;\bigcirc$ 和 $ }!!!!!\div $</strong></p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\begin&#123;array&#125;&#123;c|c&#125;</span></span><br><span class="line">    <span class="string">\text&#123;Spaces&#125;</span> &amp; <span class="string">\text&#123;Negative</span> Space <span class="keyword">in</span> Units&#125; <span class="string">\\</span></span><br><span class="line">    <span class="string">\hline</span> <span class="string">\\</span></span><br><span class="line">    <span class="string">\overbrace&#123;a</span> <span class="string">\!</span> b&#125;^&#123;<span class="string">\text&#123;\!&#125;&#125;</span> <span class="string">\mid</span> <span class="string">\underbrace&#123;ab&#125;_&#123;\rm&#123;default&#125;&#125;</span> <span class="string">\mid</span> <span class="string">\overbrace&#123;a</span> <span class="string">\,</span> b&#125;^&#123;<span class="string">\text&#123;\,&#125;&#125;</span> <span class="string">\mid</span> <span class="string">\underbrace&#123;a</span> <span class="string">\;</span> b&#125;_&#123;<span class="string">\text&#123;\;&#125;&#125;</span> <span class="string">\mid</span> <span class="string">\overbrace&#123;a</span> <span class="string">\quad</span> b&#125;^&#123;<span class="string">\text&#123;\quad&#125;&#125;</span> <span class="string">\mid</span> <span class="string">\underbrace&#123;a</span> <span class="string">\qquad</span> b&#125;_&#123;<span class="string">\text&#123;\qquad&#125;&#125;</span> &amp; <span class="string">\mathrm&#123;N&#125;\!\cdot\!\mathrm&#123;m&#125;</span> <span class="string">\mid</span> <span class="string">\mathrm&#123;s&#125;\!\cdot\!\mathrm&#123;A&#125;</span> <span class="string">\mid</span> <span class="string">\mathrm&#123;kg&#125;\!\cdot\!\mathrm&#123;m&#125;^2</span> <span class="string">\\</span></span><br><span class="line"><span class="string">\end&#123;array&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示：<br>$$<br>\begin{array}{c|c}<pre><code>\text&#123;Spaces&#125; &amp; \text&#123;Negative Space in Units&#125; \\
\hline \\
\overbrace&#123;a \! b&#125;^&#123;\text&#123;\!&#125;&#125; \mid \underbrace&#123;ab&#125;_&#123;\rm&#123;default&#125;&#125; \mid \overbrace&#123;a \, b&#125;^&#123;\text&#123;\,&#125;&#125; \mid \underbrace&#123;a \; b&#125;_&#123;\text&#123;\;&#125;&#125; \mid \overbrace&#123;a \quad b&#125;^&#123;\text&#123;\quad&#125;&#125; \mid \underbrace&#123;a \qquad b&#125;_&#123;\text&#123;\qquad&#125;&#125; &amp; \mathrm&#123;N&#125;\!\cdot\!\mathrm&#123;m&#125; \mid \mathrm&#123;s&#125;\!\cdot\!\mathrm&#123;A&#125; \mid \mathrm&#123;kg&#125;\!\cdot\!\mathrm&#123;m&#125;^2 \\
</code></pre>
  \end{array}<br>$$</li>
</ul>
<p>一些常见的公式单位可表达如下：</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> \mu_0=<span class="number">4</span>\<span class="built_in">pi</span>\times10^&#123;<span class="number">-7</span>&#125; \ \left.\mathrm&#123;\mathrm&#123;T&#125;\!\cdot\!\mathrm&#123;m&#125;&#125;\middle/\mathrm&#123;A&#125;\right. <span class="symbol">$</span><span class="symbol">$</span></span><br><span class="line"><span class="symbol">$</span><span class="symbol">$</span> <span class="number">180</span>^\circ=\<span class="built_in">pi</span> \ \mathrm&#123;rad&#125; <span class="symbol">$</span><span class="symbol">$</span></span><br><span class="line"><span class="symbol">$</span><span class="symbol">$</span> \mathrm&#123;N_A&#125; = <span class="number">6.022</span>\times10^&#123;<span class="number">23</span>&#125; \ \mathrm&#123;mol&#125;^&#123;<span class="number">-1</span>&#125; <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示：<br>$$ \mu_0=4\pi\times10^{-7} \ \left.\mathrm{\mathrm{T}!\cdot!\mathrm{m}}\middle/\mathrm{A}\right. $$ $$ 180^\circ=\pi \ \mathrm{rad} $$ $$ \mathrm{N_A} = 6.022\times10^{23} \ \mathrm{mol}^{-1} $$</li>
</ul>
<h3 id="4-．更改文字颜色-color"><a href="#4-．更改文字颜色-color" class="headerlink" title="(4)．更改文字颜色 \color"></a>(4)．更改文字颜色 \color</h3><p>使用 <code>\color&#123;颜色&#125;&#123;文字&#125;</code> 来更改特定的文字颜色。</p>
<p>更改文字颜色需要浏览器支持 ，如果浏览器不知道你所需的颜色，那么文字将被渲染为黑色。对于较旧的浏览器（HTML4 &amp; CSS2），以下颜色是被支持的：</p>
<table>
<thead>
<tr>
<th align="center">输入</th>
<th align="center">显示</th>
<th align="center">输入</th>
<th align="center">显示</th>
</tr>
</thead>
<tbody><tr>
<td align="center">black</td>
<td align="center">$\color{black}{text}$</td>
<td align="center">grey</td>
<td align="center">$\color{grey}{text}$</td>
</tr>
<tr>
<td align="center">silver</td>
<td align="center">$\color{silver}{text}$</td>
<td align="center">white</td>
<td align="center">$\color{white}{text}$</td>
</tr>
<tr>
<td align="center">maroon</td>
<td align="center">$\color{maroon}{text}$</td>
<td align="center">red</td>
<td align="center">$\color{red}{text}$</td>
</tr>
<tr>
<td align="center">yellow</td>
<td align="center">$\color{yellow}{text}$</td>
<td align="center">lime</td>
<td align="center">$\color{lime}{text}$</td>
</tr>
<tr>
<td align="center">olive</td>
<td align="center">$\color{olive}{text}$</td>
<td align="center">green</td>
<td align="center">$\color{green}{text}$</td>
</tr>
<tr>
<td align="center">teal</td>
<td align="center">$\color{teal}{text}$</td>
<td align="center">auqa</td>
<td align="center">$\color{auqa}{text}$</td>
</tr>
<tr>
<td align="center">blue</td>
<td align="center">$\color{blue}{text}$</td>
<td align="center">navy</td>
<td align="center">$\color{navy}{text}$</td>
</tr>
<tr>
<td align="center">purple</td>
<td align="center">$\color{purple}{text}$</td>
<td align="center">fuchsia</td>
<td align="center">$\color{fuchsia}{text}$</td>
</tr>
</tbody></table>
<p>对于较新的浏览器（HTML5 &amp; CSS3），HEX 颜色将被支持：</p>
<p>输入 <code>\color &#123; #rgb&#125; &#123;text&#125;</code> 来自定义更多的颜色，其中 <code>#rgb</code> 或 <code>#rrggbb</code> 的 <code>r</code> <code>g</code> <code>b</code> 可输入 <code>0-9</code> 和 <code>a-f</code> 来表示红色、绿色和蓝色的纯度（饱和度）。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">\begin&#123;array&#125;&#123;|rrrrrrrr|&#125;\hline</span></span><br><span class="line">    <span class="string">\verb+#000+</span> &amp; <span class="string">\color&#123;</span> <span class="comment">#000&#125;&#123;text&#125; &amp; &amp; &amp;</span></span><br><span class="line">    <span class="string">\verb+#00F+</span> &amp; <span class="string">\color&#123;</span> <span class="comment">#00F&#125;&#123;text&#125; &amp; &amp; \\</span></span><br><span class="line">    &amp; &amp; <span class="string">\verb+#0F0+</span> &amp; <span class="string">\color&#123;</span> <span class="comment">#0F0&#125;&#123;text&#125; &amp;</span></span><br><span class="line">    &amp; &amp; <span class="string">\verb+#0FF+</span> &amp; <span class="string">\color&#123;</span> <span class="comment">#0FF&#125;&#123;text&#125; \\</span></span><br><span class="line">    <span class="string">\verb+#F00+</span> &amp; <span class="string">\color&#123;</span> <span class="comment">#F00&#125;&#123;text&#125; &amp; &amp; &amp;</span></span><br><span class="line">    <span class="string">\verb+#F0F+</span> &amp; <span class="string">\color&#123;</span> <span class="comment">#F0F&#125;&#123;text&#125; &amp; &amp; \\</span></span><br><span class="line">    &amp; &amp; <span class="string">\verb+#FF0+</span> &amp; <span class="string">\color&#123;</span> <span class="comment">#FF0&#125;&#123;text&#125; &amp;</span></span><br><span class="line">    &amp; &amp; <span class="string">\verb+#FFF+</span> &amp; <span class="string">\color&#123;</span> <span class="comment">#FFF&#125;&#123;text&#125; \\</span></span><br><span class="line"><span class="string">\hline\end&#123;array&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>显示：</p>
<p>$$<br>\begin{array}{|rrrrrrrr|}\hline</p>
<pre><code>\verb+#000+ &amp; \color&#123; #000&#125;&#123;text&#125; &amp; &amp; &amp;
\verb+#00F+ &amp; \color&#123; #00F&#125;&#123;text&#125; &amp; &amp; \\
&amp; &amp; \verb+#0F0+ &amp; \color&#123; #0F0&#125;&#123;text&#125; &amp;
&amp; &amp; \verb+#0FF+ &amp; \color&#123; #0FF&#125;&#123;text&#125; \\
\verb+#F00+ &amp; \color&#123; #F00&#125;&#123;text&#125; &amp; &amp; &amp;
\verb+#F0F+ &amp; \color&#123; #F0F&#125;&#123;text&#125; &amp; &amp; \\
&amp; &amp; \verb+#FF0+ &amp; \color&#123; #FF0&#125;&#123;text&#125; &amp;
&amp; &amp; \verb+#FFF+ &amp; \color&#123; #FFF&#125;&#123;text&#125; \\
</code></pre>
<p>  \hline\end{array}<br>$$</p>
</li>
<li><p>例子：</p>
</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;|rrrrrrrr|&#125;<span class="keyword">\hline</span></span><br><span class="line">    <span class="keyword">\verb</span>+<span class="string">#000</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#0</span>00&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#005</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#0</span>05&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#00A</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#0</span>0A&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#00F</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#0</span>0F&#125;&#123;text&#125;  <span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\verb</span>+<span class="string">#500</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#5</span>00&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#505</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#5</span>05&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#50A</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#5</span>0A&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#50F</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#5</span>0F&#125;&#123;text&#125;  <span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\verb</span>+<span class="string">#A00</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>A00&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#A05</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>A05&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#A0A</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>A0A&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#A0F</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>A0F&#125;&#123;text&#125;  <span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\verb</span>+<span class="string">#F00</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>F00&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#F05</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>F05&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#F0A</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>F0A&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#F0F</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>F0F&#125;&#123;text&#125;  <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">    <span class="keyword">\verb</span>+<span class="string">#080</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#0</span>80&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#085</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#0</span>85&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#08A</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#0</span>8A&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#08F</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#0</span>8F&#125;&#123;text&#125;  <span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\verb</span>+<span class="string">#580</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#5</span>80&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#585</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#5</span>85&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#58A</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#5</span>8A&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#58F</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#5</span>8F&#125;&#123;text&#125;  <span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\verb</span>+<span class="string">#A80</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>A80&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#A85</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>A85&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#A8A</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>A8A&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#A8F</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>A8F&#125;&#123;text&#125;  <span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\verb</span>+<span class="string">#F80</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>F80&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#F85</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>F85&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#F8A</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>F8A&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#F8F</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>F8F&#125;&#123;text&#125;  <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">    <span class="keyword">\verb</span>+<span class="string">#0F0</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#0</span>F0&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#0F5</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#0</span>F5&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#0FA</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#0</span>FA&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#0FF</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#0</span>FF&#125;&#123;text&#125;  <span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\verb</span>+<span class="string">#5F0</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#5</span>F0&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#5F5</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#5</span>F5&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#5FA</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#5</span>FA&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#5FF</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#5</span>FF&#125;&#123;text&#125;  <span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\verb</span>+<span class="string">#AF0</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>AF0&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#AF5</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>AF5&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#AFA</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>AFA&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#AFF</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>AFF&#125;&#123;text&#125;  <span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\verb</span>+<span class="string">#FF0</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>FF0&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#FF5</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>FF5&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#FFA</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>FFA&#125;&#123;text&#125; <span class="built_in">&amp;</span> <span class="keyword">\verb</span>+<span class="string">#FFF</span>+ <span class="built_in">&amp;</span> <span class="keyword">\color</span>&#123; <span class="params">#</span>FFF&#125;&#123;text&#125;  <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span><span class="keyword">\end</span>&#123;array&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>显示：</li>
</ul>
<p>$$<br>\begin{array}{|rrrrrrrr|}\hline<br>    \verb+#000+ &amp; \color{ #000}{text} &amp; \verb+#005+ &amp; \color{ #005}{text} &amp; \verb+#00A+ &amp; \color{ #00A}{text} &amp; \verb+#00F+ &amp; \color{ #00F}{text}  \<br>    \verb+#500+ &amp; \color{ #500}{text} &amp; \verb+#505+ &amp; \color{ #505}{text} &amp; \verb+#50A+ &amp; \color{ #50A}{text} &amp; \verb+#50F+ &amp; \color{ #50F}{text}  \<br>    \verb+#A00+ &amp; \color{ #A00}{text} &amp; \verb+#A05+ &amp; \color{ #A05}{text} &amp; \verb+#A0A+ &amp; \color{ #A0A}{text} &amp; \verb+#A0F+ &amp; \color{ #A0F}{text}  \<br>    \verb+#F00+ &amp; \color{ #F00}{text} &amp; \verb+#F05+ &amp; \color{ #F05}{text} &amp; \verb+#F0A+ &amp; \color{ #F0A}{text} &amp; \verb+#F0F+ &amp; \color{ #F0F}{text}  \<br>  \hline<br>    \verb+#080+ &amp; \color{ #080}{text} &amp; \verb+#085+ &amp; \color{ #085}{text} &amp; \verb+#08A+ &amp; \color{ #08A}{text} &amp; \verb+#08F+ &amp; \color{ #08F}{text}  \<br>    \verb+#580+ &amp; \color{ #580}{text} &amp; \verb+#585+ &amp; \color{ #585}{text} &amp; \verb+#58A+ &amp; \color{ #58A}{text} &amp; \verb+#58F+ &amp; \color{ #58F}{text}  \<br>    \verb+#A80+ &amp; \color{ #A80}{text} &amp; \verb+#A85+ &amp; \color{ #A85}{text} &amp; \verb+#A8A+ &amp; \color{ #A8A}{text} &amp; \verb+#A8F+ &amp; \color{ #A8F}{text}  \<br>    \verb+#F80+ &amp; \color{ #F80}{text} &amp; \verb+#F85+ &amp; \color{ #F85}{text} &amp; \verb+#F8A+ &amp; \color{ #F8A}{text} &amp; \verb+#F8F+ &amp; \color{ #F8F}{text}  \<br>  \hline<br>    \verb+#0F0+ &amp; \color{ #0F0}{text} &amp; \verb+#0F5+ &amp; \color{ #0F5}{text} &amp; \verb+#0FA+ &amp; \color{ #0FA}{text} &amp; \verb+#0FF+ &amp; \color{ #0FF}{text}  \<br>    \verb+#5F0+ &amp; \color{ #5F0}{text} &amp; \verb+#5F5+ &amp; \color{ #5F5}{text} &amp; \verb+#5FA+ &amp; \color{ #5FA}{text} &amp; \verb+#5FF+ &amp; \color{ #5FF}{text}  \<br>    \verb+#AF0+ &amp; \color{ #AF0}{text} &amp; \verb+#AF5+ &amp; \color{ #AF5}{text} &amp; \verb+#AFA+ &amp; \color{ #AFA}{text} &amp; \verb+#AFF+ &amp; \color{ #AFF}{text}  \<br>    \verb+#FF0+ &amp; \color{ #FF0}{text} &amp; \verb+#FF5+ &amp; \color{ #FF5}{text} &amp; \verb+#FFA+ &amp; \color{ #FFA}{text} &amp; \verb+#FFF+ &amp; \color{ #FFF}{text}  \<br>  \hline\end{array}<br>$$</p>
<h3 id="5-．添加删除线"><a href="#5-．添加删除线" class="headerlink" title="(5)．添加删除线"></a>(5)．添加删除线</h3><p>使用删除线功能必须声明 <code>$$</code> 符号。</p>
<p>在公式内使用 <code>\require&#123;cancel&#125;</code> 来允许<strong>片段删除线</strong>的显示。<br>声明片段删除线后，使用 <code>\cancel&#123;字符&#125;</code>、<code>\bcancel&#123;字符&#125;</code>、<code>\xcancel&#123;字符&#125;</code> 和 <code>\cancelto&#123;字符&#125;</code> 来实现各种片段删除线效果。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line"><span class="string">\require&#123;cancel&#125;</span></span><br><span class="line"><span class="string">\begin&#123;array&#125;&#123;rl&#125;</span></span><br><span class="line">    <span class="string">\verb|y+\cancel&#123;x&#125;|</span> &amp; y+<span class="string">\cancel&#123;x&#125;</span> <span class="string">\\</span></span><br><span class="line">    <span class="string">\verb|\cancel&#123;y+x&#125;|</span> &amp; <span class="string">\cancel&#123;y+x&#125;</span> <span class="string">\\</span></span><br><span class="line">    <span class="string">\verb|y+\bcancel&#123;x&#125;|</span> &amp; y+<span class="string">\bcancel&#123;x&#125;</span> <span class="string">\\</span></span><br><span class="line">    <span class="string">\verb|y+\xcancel&#123;x&#125;|</span> &amp; y+<span class="string">\xcancel&#123;x&#125;</span> <span class="string">\\</span></span><br><span class="line">    <span class="string">\verb|y+\cancelto&#123;0&#125;&#123;x&#125;|</span> &amp; y+<span class="string">\cancelto&#123;0&#125;&#123;x&#125;</span> <span class="string">\\</span></span><br><span class="line">    <span class="string">\verb+\frac&#123;1\cancel9&#125;&#123;\cancel95&#125;</span> = <span class="string">\frac15+&amp;</span> <span class="string">\frac&#123;1\cancel9&#125;&#123;\cancel95&#125;</span> = <span class="string">\frac15</span> <span class="string">\\</span></span><br><span class="line"><span class="string">\end&#123;array&#125;</span></span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<ul>
<li>显示：</li>
</ul>
<p>$$<br>\require{cancel}<br>\begin{array}{rl}<br>    \verb|y+\cancel{x}| &amp; y+\cancel{x} \<br>    \verb|\cancel{y+x}| &amp; \cancel{y+x} \<br>    \verb|y+\bcancel{x}| &amp; y+\bcancel{x} \<br>    \verb|y+\xcancel{x}| &amp; y+\xcancel{x} \<br>    \verb|y+\cancelto{0}{x}| &amp; y+\cancelto{0}{x} \<br>    \verb+\frac{1\cancel9}{\cancel95} = \frac15+&amp; \frac{1\cancel9}{\cancel95} = \frac15 \<br>\end{array}<br>$$</p>
<p>使用 <code>\require&#123;enclose&#125;</code> 来允许<strong>整段删除线</strong>的显示。<br>声明整段删除线后，使用 <code>\enclose&#123;删除线效果&#125;&#123;字符&#125;</code> 来实现各种整段删除线效果。<br>其中，删除线效果有 <code>horizontalstrike</code>、<code>verticalstrike</code>、<code>updiagonalstrike</code> 和 <code>downdiagonalstrike</code>，可叠加使用。</p>
<ul>
<li>例子：</li>
</ul>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">$$</span></span><br><span class="line"><span class="language-xml">\require</span><span class="template-variable">&#123;enclose&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\begin</span><span class="template-variable">&#123;array&#125;</span><span class="template-variable">&#123;rl&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    \verb|\enclose</span><span class="template-variable">&#123;horizontalstrike&#125;</span><span class="template-variable">&#123;x+y&#125;</span><span class="language-xml">| &amp; \enclose</span><span class="template-variable">&#123;horizontalstrike&#125;</span><span class="template-variable">&#123;x+y&#125;</span><span class="language-xml"> \\</span></span><br><span class="line"><span class="language-xml">    \verb|\enclose</span><span class="template-variable">&#123;verticalstrike&#125;</span><span class="template-variable">&#123;\frac xy&#125;</span><span class="language-xml">| &amp; \enclose</span><span class="template-variable">&#123;verticalstrike&#125;</span><span class="template-variable">&#123;\frac xy&#125;</span><span class="language-xml"> \\</span></span><br><span class="line"><span class="language-xml">    \verb|\enclose</span><span class="template-variable">&#123;updiagonalstrike&#125;</span><span class="template-variable">&#123;x+y&#125;</span><span class="language-xml">| &amp; \enclose</span><span class="template-variable">&#123;updiagonalstrike&#125;</span><span class="template-variable">&#123;x+y&#125;</span><span class="language-xml"> \\</span></span><br><span class="line"><span class="language-xml">    \verb|\enclose</span><span class="template-variable">&#123;downdiagonalstrike&#125;</span><span class="template-variable">&#123;x+y&#125;</span><span class="language-xml">| &amp; \enclose</span><span class="template-variable">&#123;downdiagonalstrike&#125;</span><span class="template-variable">&#123;x+y&#125;</span><span class="language-xml"> \\</span></span><br><span class="line"><span class="language-xml">    \verb|\enclose</span><span class="template-variable">&#123;horizontalstrike,updiagonalstrike&#125;</span><span class="template-variable">&#123;x+y&#125;</span><span class="language-xml">| &amp; \enclose</span><span class="template-variable">&#123;horizontalstrike,updiagonalstrike&#125;</span><span class="template-variable">&#123;x+y&#125;</span><span class="language-xml"> \\</span></span><br><span class="line"><span class="language-xml">\end</span><span class="template-variable">&#123;array&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">$$</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示：</li>
</ul>
<p>$$<br>\require{enclose}<br>\begin{array}{rl}<br>    \verb|\enclose{horizontalstrike}{x+y}| &amp; \enclose{horizontalstrike}{x+y} \<br>    \verb|\enclose{verticalstrike}{\frac xy}| &amp; \enclose{verticalstrike}{\frac xy} \<br>    \verb|\enclose{updiagonalstrike}{x+y}| &amp; \enclose{updiagonalstrike}{x+y} \<br>    \verb|\enclose{downdiagonalstrike}{x+y}| &amp; \enclose{downdiagonalstrike}{x+y} \<br>    \verb|\enclose{horizontalstrike,updiagonalstrike}{x+y}| &amp; \enclose{horizontalstrike,updiagonalstrike}{x+y} \<br>\end{array}<br>$$</p>
<p>此外， <code>\enclose</code> 命令还可以产生包围的边框和圆等，参见 <a href="https://developer.mozilla.org/en-US/docs/Web/MathML/Element/menclose">MathML Menclose Documentation</a> 以查看更多效果。</p>
<ul>
<li>例子：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">分别使用 <code>circle</code> 和 <code>roundedbox</code> 包围的公式</th>
</tr>
</thead>
</table>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line"><span class="string">\require&#123;enclose&#125;</span></span><br><span class="line"><span class="string">\begin&#123;array&#125;&#123;c&#125;</span></span><br><span class="line">    <span class="string">\enclose&#123;circle&#125;&#123;f(\top),\,</span> f^<span class="number">2</span>(<span class="string">\top),\,</span> f^<span class="number">3</span>(<span class="string">\top)</span> <span class="string">\,\cdots\,</span> f^n(<span class="string">\top)&#125;</span> <span class="string">\\</span></span><br><span class="line">    <span class="string">\enclose&#123;roundedbox&#125;&#123;f(\bot),\,</span> f^<span class="number">2</span>(<span class="string">\bot),\,</span> f^<span class="number">3</span>(<span class="string">\bot)</span> <span class="string">\,\cdots\,</span> f^n(<span class="string">\bot)&#125;</span> <span class="string">\\</span></span><br><span class="line"><span class="string">\end&#123;array&#125;</span></span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">使用 <code>box</code> 框住所有公式</th>
</tr>
</thead>
</table>
<p>$$<br>\require{enclose}<br>\begin{array}{c}<br>    \enclose{circle}{f(\top),, f^2(\top),, f^3(\top) ,\cdots, f^n(\top)} \<br>    \enclose{roundedbox}{f(\bot),, f^2(\bot),, f^3(\bot) ,\cdots, f^n(\bot)} \<br>\end{array}<br>$$</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line"><span class="string">\require&#123;enclose&#125;</span></span><br><span class="line"><span class="string">\enclose&#123;box&#125;&#123;</span></span><br><span class="line">    <span class="string">\begin&#123;array&#125;&#123;c&#125;</span></span><br><span class="line">        f(<span class="string">\top),\,</span> f^<span class="number">2</span>(<span class="string">\top),\,</span> f^<span class="number">3</span>(<span class="string">\top)</span> <span class="string">\,\cdots\,</span> f^n(<span class="string">\top)</span> <span class="string">\\</span></span><br><span class="line">        f(<span class="string">\bot),\,</span> f^<span class="number">2</span>(<span class="string">\bot),\,</span> f^<span class="number">3</span>(<span class="string">\bot)</span> <span class="string">\,\cdots\,</span> f^n(<span class="string">\bot)</span> <span class="string">\\</span></span><br><span class="line">    <span class="string">\end&#123;array&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<ul>
<li>显示：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">分别使用 <code>circle</code> 和 <code>roundedbox</code> 包围的公式</th>
<th align="center">使用 <code>box</code> 框住所有公式</th>
</tr>
</thead>
</table>
<p>|$$<br>    \require{enclose}<br>    \begin{array}{c}<br>        \enclose{circle}{f(\top),, f^2(\top),, f^3(\top) ,\cdots, f^n(\top)} \<br>        \enclose{roundedbox}{f(\bot),, f^2(\bot),, f^3(\bot) ,\cdots, f^n(\bot)} \<br>    \end{array}<br>$$|<br>$$<br>\require{enclose}<br>    \enclose{box}{<br>    \begin{array}{c}<br>    f(\top),, f^2(\top),, f^3(\top) ,\cdots, f^n(\top) \<br>    f(\bot),, f^2(\bot),, f^3(\bot) ,\cdots, f^n(\bot) \<br>    \end{array}<br>    }<br>$$|</p>
<p>此例语法可参见<a href="#%E4%BA%94%E6%95%B0%E7%BB%84%E4%B8%8E%E8%A1%A8%E6%A0%BC%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">如何输入一个数组或表格</a>。</p>
<p>#二、矩阵使用参考</p>
<p>##1．如何输入无框矩阵</p>
<p>在开头使用 <code>\begin&#123;matrix&#125;</code>，在结尾使用 <code>\end&#123;matrix&#125;</code>，在中间插入矩阵元素，每个元素之间插入 <code>&amp;</code> ，并在每行结尾处使用 <code>\\</code> 。<br>使用矩阵时必须声明 <code>$</code> 或 <code>$$</code> 符号。</p>
<ul>
<li>例子：<br>$$<br>\begin{matrix}<br>1 &amp; x &amp; x^2 \<br>1 &amp; y &amp; y^2 \<br>1 &amp; z &amp; z^2 \<br>\end{matrix}<br>$$<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line"><span class="number">1</span> &amp; x &amp; x^<span class="number">2</span> \\</span><br><span class="line"><span class="number">1</span> &amp; y &amp; y^<span class="number">2</span> \\</span><br><span class="line"><span class="number">1</span> &amp; z &amp; z^<span class="number">2</span> \\</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">$$</span><br><span class="line">##<span class="number">2</span>．如何输入边框矩阵</span><br><span class="line"></span><br><span class="line">在开头将 `matrix` 替换为 `pmatrix` `bmatrix` `Bmatrix` `vmatrix` `Vmatrix` 。</span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$ \begin{matrix} 1 &amp; 2 \ 3 &amp; 4 \ \end{matrix} $<br>$ \begin{pmatrix} 1 &amp; 2 \ 3 &amp; 4 \ \end{pmatrix} $<br>$ \begin{bmatrix} 1 &amp; 2 \ 3 &amp; 4 \ \end{bmatrix} $<br>$ \begin{Bmatrix} 1 &amp; 2 \ 3 &amp; 4 \ \end{Bmatrix} $<br>$ \begin{vmatrix} 1 &amp; 2 \ 3 &amp; 4 \ \end{vmatrix} $<br>$ \begin{Vmatrix} 1 &amp; 2 \ 3 &amp; 4 \ \end{Vmatrix} $<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line"></span><br><span class="line">|                      matrix                       |                       pmatrix                       |                       bmatrix                       |                       <span class="title class_">Bmatrix</span>                       |                       vmatrix                       |                       <span class="title class_">Vmatrix</span>                       |</span><br><span class="line">| <span class="symbol">:-----------------------------------------------</span>: | <span class="symbol">:-------------------------------------------------</span>: | <span class="symbol">:-------------------------------------------------</span>: | <span class="symbol">:-------------------------------------------------</span>: | <span class="symbol">:-------------------------------------------------</span>: | <span class="symbol">:-------------------------------------------------</span>: |</span><br><span class="line">| <span class="variable">$ </span>\begin&#123;matrix&#125; <span class="number">1</span> &amp; <span class="number">2</span> \\ <span class="number">3</span> &amp; <span class="number">4</span> \\ \<span class="keyword">end</span>&#123;matrix&#125; <span class="variable">$ </span>| <span class="variable">$ </span>\begin&#123;pmatrix&#125; <span class="number">1</span> &amp; <span class="number">2</span> \\ <span class="number">3</span> &amp; <span class="number">4</span> \\ \<span class="keyword">end</span>&#123;pmatrix&#125; <span class="variable">$ </span>| <span class="variable">$ </span>\begin&#123;bmatrix&#125; <span class="number">1</span> &amp; <span class="number">2</span> \\ <span class="number">3</span> &amp; <span class="number">4</span> \\ \<span class="keyword">end</span>&#123;bmatrix&#125; <span class="variable">$ </span>| <span class="variable">$ </span>\begin&#123;<span class="title class_">Bmatrix</span>&#125; <span class="number">1</span> &amp; <span class="number">2</span> \\ <span class="number">3</span> &amp; <span class="number">4</span> \\ \<span class="keyword">end</span>&#123;<span class="title class_">Bmatrix</span>&#125; <span class="variable">$ </span>| <span class="variable">$ </span>\begin&#123;vmatrix&#125; <span class="number">1</span> &amp; <span class="number">2</span> \\ <span class="number">3</span> &amp; <span class="number">4</span> \\ \<span class="keyword">end</span>&#123;vmatrix&#125; <span class="variable">$ </span>| <span class="variable">$ </span>\begin&#123;<span class="title class_">Vmatrix</span>&#125; <span class="number">1</span> &amp; <span class="number">2</span> \\ <span class="number">3</span> &amp; <span class="number">4</span> \\ \<span class="keyword">end</span>&#123;<span class="title class_">Vmatrix</span>&#125; <span class="variable">$ </span>|</span><br><span class="line"></span><br><span class="line"><span class="comment">##3．如何输入带省略符号的矩阵</span></span><br><span class="line"></span><br><span class="line">使用 `\cdots` <span class="variable">$\</span>cdots<span class="variable">$ </span>, `\ddots` <span class="variable">$\</span>ddots<span class="variable">$ </span>, `\vdots` <span class="variable">$\</span>vdots<span class="variable">$ </span>来输入省略符号。</span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$$</li>
</ul>
<p>\begin{pmatrix}<br>1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n \<br>1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^n \<br>\end{pmatrix}</p>
<p>$$</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line"><span class="string">\begin&#123;pmatrix&#125;</span></span><br><span class="line"><span class="number">1</span> &amp; a_1 &amp; a_1^<span class="number">2</span> &amp; <span class="string">\cdots</span> &amp; a_1^n <span class="string">\\</span></span><br><span class="line"><span class="number">1</span> &amp; a_2 &amp; a_2^<span class="number">2</span> &amp; <span class="string">\cdots</span> &amp; a_2^n <span class="string">\\</span></span><br><span class="line"><span class="string">\vdots</span> &amp; <span class="string">\vdots</span> &amp; <span class="string">\vdots</span> &amp; <span class="string">\ddots</span> &amp; <span class="string">\vdots</span> <span class="string">\\</span></span><br><span class="line"><span class="number">1</span> &amp; a_m &amp; a_m^<span class="number">2</span> &amp; <span class="string">\cdots</span> &amp; a_m^n <span class="string">\\</span></span><br><span class="line"><span class="string">\end&#123;pmatrix&#125;</span></span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line"><span class="comment">##4．如何输入带分割符号的矩阵</span></span><br><span class="line"></span><br><span class="line">详见[数组使用参考](<span class="comment">#五数组与表格使用参考)。</span></span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$$</p>
<p>\left[<br>\begin{array}{cc|c}<br>1 &amp; 2 &amp; 3 \<br>4 &amp; 5 &amp; 6 \<br>\end{array}<br>\right]</p>
<p>$$</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line"><span class="string">\left[</span></span><br><span class="line"><span class="string">\begin&#123;array&#125;&#123;cc|c&#125;</span></span><br><span class="line"><span class="number">1</span> &amp; <span class="number">2</span> &amp; <span class="number">3</span> <span class="string">\\</span></span><br><span class="line"><span class="number">4</span> &amp; <span class="number">5</span> &amp; <span class="number">6</span> <span class="string">\\</span></span><br><span class="line"><span class="string">\end&#123;array&#125;</span></span><br><span class="line"><span class="string">\right]</span></span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">其中 `cc|c` 代表在一个三列矩阵中的第二和第三列之间插入分割线。</span><br><span class="line"></span><br><span class="line"><span class="comment">##5．如何输入行中矩阵</span></span><br><span class="line"></span><br><span class="line">若想在一行内显示矩阵，可使用 `<span class="string">\bigl(\begin&#123;smallmatrix&#125;</span> 表达式 <span class="string">\end&#123;smallmatrix&#125;\bigr)`</span></span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是一个行中矩阵的示例 $\bigl(\begin{smallmatrix} a &amp; b \ c &amp; d \end{smallmatrix}\bigr)$</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：这是一个行中矩阵的示例 $\bigl(\begin&#123;smallmatrix&#125; a &amp; b \\ c &amp; d \end&#123;smallmatrix&#125;\bigr)$ 。</span><br><span class="line"></span><br><span class="line">#三、方程式序列使用参考</span><br><span class="line"></span><br><span class="line">##<span class="number">1</span>．如何输入一个方程式序列</span><br><span class="line"></span><br><span class="line">人们经常想要一列整齐且居中的方程式序列。使用 `\begin&#123;align&#125;…\end&#123;align&#125;` 来创造一列方程式，其中在每行结尾处使用 `\\` 。使用方程式序列无需声明公式符号 `$` 或 `$$` 。</span><br><span class="line"></span><br><span class="line">**请注意 `&#123;align&#125;` 语句是自动编号的，使用 `&#123;align*&#125;` 声明不自动编号。**</span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>\begin{align}<br>    \sqrt{37} &amp; = \sqrt{\frac{73^2-1}{12^2}} \<br>              &amp; = \sqrt{\frac{73^2}{12^2}\cdot\frac{73^2-1}{73^2}} \<br>              &amp; = \sqrt{\frac{73^2}{12^2}}\sqrt{\frac{73^2-1}{73^2}} \<br>              &amp; = \frac{73}{12}\sqrt{1-\frac{1}{73^2}} \<br>              &amp; \approx \frac{73}{12}\left(1-\frac{1}{2\cdot73^2}\right) \<br>\end{align}</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">- 显示：</span></span><br><span class="line"><span class="language-xml">$$</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\begin</span><span class="template-variable">&#123;align&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">\sqrt</span><span class="template-variable">&#123;37&#125;</span><span class="language-xml"> &amp; = \sqrt</span><span class="template-variable">&#123;\frac&#123;73^2-1&#125;</span><span class="template-variable">&#123;12^2&#125;</span><span class="language-xml">&#125; \\</span></span><br><span class="line"><span class="language-xml">&amp; = \sqrt</span><span class="template-variable">&#123;\frac&#123;73^2&#125;</span><span class="template-variable">&#123;12^2&#125;</span><span class="language-xml">\cdot\frac</span><span class="template-variable">&#123;73^2-1&#125;</span><span class="template-variable">&#123;73^2&#125;</span><span class="language-xml">&#125; \\</span></span><br><span class="line"><span class="language-xml">&amp; = \sqrt</span><span class="template-variable">&#123;\frac&#123;73^2&#125;</span><span class="template-variable">&#123;12^2&#125;</span><span class="language-xml">&#125;\sqrt</span><span class="template-variable">&#123;\frac&#123;73^2-1&#125;</span><span class="template-variable">&#123;73^2&#125;</span><span class="language-xml">&#125; \\</span></span><br><span class="line"><span class="language-xml">&amp; = \frac</span><span class="template-variable">&#123;73&#125;</span><span class="template-variable">&#123;12&#125;</span><span class="language-xml">\sqrt</span><span class="template-variable">&#123;1-\frac&#123;1&#125;</span><span class="template-variable">&#123;73^2&#125;</span><span class="language-xml">&#125; \\</span></span><br><span class="line"><span class="language-xml">&amp; \approx \frac</span><span class="template-variable">&#123;73&#125;</span><span class="template-variable">&#123;12&#125;</span><span class="language-xml">\left(1-\frac</span><span class="template-variable">&#123;1&#125;</span><span class="template-variable">&#123;2\cdot73^2&#125;</span><span class="language-xml">\right) \\</span></span><br><span class="line"><span class="language-xml">\end</span><span class="template-variable">&#123;align&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">$$</span></span><br><span class="line"><span class="language-xml">本例中每行公式的编号续自“[如何插入公式](#1如何插入公式)”中的自动编号公式\eqref</span><span class="template-variable">&#123;<span class="keyword">eq</span>:sample&#125;</span><span class="language-xml"> 。</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">##2．在一个方程式序列的每一行中注明原因</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">在 `</span><span class="template-variable">&#123;align&#125;</span><span class="language-xml">` 中后添加 `&amp;` 符号来自动对齐后面的内容，可灵活组合 `\text` 和 `\tag` 语句。`\tag` 语句编号优先级高于自动编号。</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">- 例子：</span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></table></figure>
<p>\begin{align}<br>    v + w &amp; = 0  &amp; \text{Given} \tag 1 \<br>       -w &amp; = -w + 0 &amp; \text{additive identity} \tag 2 \<br>   -w + 0 &amp; = -w + (v + w) &amp; \text{equations $(1)$ and $(2)$} \<br>\end{align}</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line">  $$<span class="string">\begin&#123;align&#125;</span></span><br><span class="line">    v + w &amp; = <span class="number">0</span>  &amp; <span class="string">\text&#123;Given&#125;</span> <span class="string">\tag</span> <span class="number">1</span> <span class="string">\\</span></span><br><span class="line">       -w &amp; = -w + <span class="number">0</span> &amp; <span class="string">\text&#123;additive</span> identity&#125; <span class="string">\tag</span> <span class="number">2</span> <span class="string">\\</span></span><br><span class="line">   -w + <span class="number">0</span> &amp; = -w + (v + w) &amp; <span class="string">\text&#123;equations</span> $(<span class="number">1</span>)$ <span class="keyword">and</span> $(<span class="number">2</span>)$&#125; <span class="string">\\</span></span><br><span class="line">  <span class="string">\end&#123;align&#125;</span></span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">本例中第一、第二行的自动编号被 `<span class="string">\tag`</span> 语句覆盖，第三行的编号为自动编号。</span><br><span class="line"></span><br><span class="line">&gt; **@joyphys** 如何引用 `<span class="string">\tag`</span> 标记的公式？</span><br><span class="line">&gt; &lt;span style=<span class="string">&quot;text-align: center; display: block;&quot;</span>&gt; 使用 `<span class="string">\tag&#123;yourtag&#125;`</span> 来标记公式，然后在 `<span class="string">\tag`</span> 之后加上 `<span class="string">\label&#123;yourlabel&#125;`</span> &lt;/span&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#四、条件表达式使用参考</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##1．如何输入一个条件表达式</span></span><br><span class="line"></span><br><span class="line">使用 `<span class="string">\begin&#123;cases&#125;…\end&#123;cases&#125;`</span> 来创造一组条件表达式，在每一行条件中插入 `&amp;` 来指定需要对齐的内容，并在每一行结尾处使用 `<span class="string">\\`。</span></span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$$<br>    f(n) =<br>        \begin{cases}<br>            n/2,  &amp; \text{if $n$ is even} \<br>            3n+1, &amp; \text{if $n$ is odd} \<br>        \end{cases}<br>$$</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">f(n) =</span><br><span class="line">        <span class="string">\begin&#123;cases&#125;</span></span><br><span class="line">            n/<span class="number">2</span>,  &amp; <span class="string">\text&#123;if</span> $n$ <span class="keyword">is</span> even&#125; <span class="string">\\</span></span><br><span class="line">            <span class="number">3n</span>+<span class="number">1</span>, &amp; <span class="string">\text&#123;if</span> $n$ <span class="keyword">is</span> odd&#125; <span class="string">\\</span></span><br><span class="line">        <span class="string">\end&#123;cases&#125;</span></span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">&gt; **@Sherlockk** 用 markdown+math 编辑时 `<span class="string">\text`</span> 内需用 `<span class="string">\(equation\)`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##2．如何输入一个左侧对齐的条件表达式</span></span><br><span class="line"></span><br><span class="line">若想让文字在**左侧对齐显示**，则有如下方式：</span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$$<br>    \left.<br>        \begin{array}{l}<br>            \text{if $n$ is even:} &amp; n/2 \<br>            \text{if $n$ is odd:} &amp; 3n+1 \<br>        \end{array}<br>    \right}<br>    =f(n)<br>$$</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line"><span class="string">\left.</span></span><br><span class="line">        <span class="string">\begin&#123;array&#125;&#123;l&#125;</span></span><br><span class="line">            <span class="string">\text&#123;if</span> $n$ <span class="keyword">is</span> even:&#125; &amp; n/<span class="number">2</span> <span class="string">\\</span></span><br><span class="line">            <span class="string">\text&#123;if</span> $n$ <span class="keyword">is</span> odd:&#125; &amp; <span class="number">3n</span>+<span class="number">1</span> <span class="string">\\</span></span><br><span class="line">        <span class="string">\end&#123;array&#125;</span></span><br><span class="line">    <span class="string">\right\&#125;</span></span><br><span class="line">    =f(n)</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line"><span class="comment">##3．如何使条件表达式适配行高</span></span><br><span class="line"></span><br><span class="line">在一些情况下，条件表达式中某些行的行高为非标准高度，此时使用 `<span class="string">\\[2ex]`</span> 语句代替该行末尾的 `<span class="string">\\`</span> 来让编辑器适配。</span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line">  |不适配[<span class="number">2ex</span>]|</span><br><span class="line">  |:--:|</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$$<br>f(n) =<br>    \begin{cases}<br>        \frac{n}{2}, &amp; \text{if $n$ is even} \<br>        3n+1,        &amp; \text{if $n$ is odd} \<br>    \end{cases}<br>$$</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">| 适配[<span class="number">2</span>ex] |</span><br><span class="line">| <span class="symbol">:-------</span>: |</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$$<br>f(n) =<br>    \begin{cases}<br>        \frac{n}{2}, &amp; \text{if $n$ is even} \[2ex]<br>        3n+1,        &amp; \text{if $n$ is odd} \<br>    \end{cases}<br>$$</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line">  |不适配[<span class="number">2</span>ex]|适配[<span class="number">2</span>ex]|</span><br><span class="line"><span class="title">  |:--:|:--:</span>|</span><br><span class="line">  |$$</span><br><span class="line">  f(n) = </span><br><span class="line">    \begin&#123;cases&#125;</span><br><span class="line">        \frac&#123;n&#125;&#123;<span class="number">2</span>&#125;, &amp; \text&#123;if $n$ is even&#125; \\</span><br><span class="line">  <span class="number">3</span>n+<span class="number">1</span>, &amp; \text&#123;if $n$ is odd&#125; \\</span><br><span class="line">  \end&#123;cases&#125;</span><br><span class="line">  $$</span><br><span class="line">  |</span><br><span class="line">  $$</span><br><span class="line">  f(n) =</span><br><span class="line">  \begin&#123;cases&#125;</span><br><span class="line">  \frac&#123;n&#125;&#123;<span class="number">2</span>&#125;, &amp; \text&#123;if $n$ is even&#125; \\[<span class="number">2</span>ex]</span><br><span class="line">  <span class="number">3</span>n+<span class="number">1</span>, &amp; \text&#123;if $n$ is odd&#125; \\</span><br><span class="line">  \end&#123;cases&#125;</span><br><span class="line">  $$|</span><br><span class="line"></span><br><span class="line">**一个 `[ex]` 指一个 <span class="string">&quot;X-Height&quot;</span>，即 x 字母高度。可以根据情况指定多个 `[ex]`，如 `[<span class="number">3</span>ex]`、`[<span class="number">4</span>ex]` 等。**</span><br><span class="line">其实可以在任意换行处使用 `\\[<span class="number">2</span>ex]` 语句，只要你觉得合适。</span><br><span class="line"></span><br><span class="line">#五、数组与表格使用参考</span><br><span class="line"></span><br><span class="line">##<span class="number">1</span>．如何输入一个数组或表格</span><br><span class="line"></span><br><span class="line">通常，一个格式化后的表格比单纯的文字或排版后的文字更具有可读性。</span><br><span class="line">数组和表格均以 `\begin&#123;array&#125;` 开头，并在其后定义列数及每一列的文本对齐属性，`c` `l` `r` 分别代表居中、左对齐及右对齐。若需要插入垂直分割线，在定义式中插入 `|` ，若要插入水平分割线，在下一行输入前插入 `\hline` 。</span><br><span class="line">与矩阵相似，每行元素间均须要插入 `&amp;` ，每行元素以 `\\` 结尾，最后以 `\ end&#123;array&#125;` 结束数组。</span><br><span class="line">使用单个数组或表格时无需声明 `$` 或 `$$` 符号。</span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>\begin{array}{c|lcr}<br>    n &amp; \text{左对齐} &amp; \text{居中对齐} &amp; \text{右对齐} \<br>    \hline<br>    1 &amp; 0.24 &amp; 1 &amp; 125 \<br>    2 &amp; -1 &amp; 189 &amp; -8 \<br>    3 &amp; -20 &amp; 2000 &amp; 1+10i \<br>\end{array}</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line">  $$</span><br><span class="line">  <span class="string">\begin&#123;array&#125;&#123;c|lcr&#125;</span></span><br><span class="line">    n &amp; <span class="string">\text&#123;左对齐&#125;</span> &amp; <span class="string">\text&#123;居中对齐&#125;</span> &amp; <span class="string">\text&#123;右对齐&#125;</span> <span class="string">\\</span></span><br><span class="line">    <span class="string">\hline</span></span><br><span class="line">    <span class="number">1</span> &amp; <span class="number">0.24</span> &amp; <span class="number">1</span> &amp; <span class="number">125</span> <span class="string">\\</span></span><br><span class="line">    <span class="number">2</span> &amp; -<span class="number">1</span> &amp; <span class="number">189</span> &amp; -<span class="number">8</span> <span class="string">\\</span></span><br><span class="line">    <span class="number">3</span> &amp; -<span class="number">20</span> &amp; <span class="number">2000</span> &amp; <span class="number">1</span>+<span class="number">10i</span> <span class="string">\\</span></span><br><span class="line">  <span class="string">\end&#123;array&#125;</span></span><br><span class="line">  $$</span><br><span class="line"></span><br><span class="line"><span class="comment">##2．如何输入一个嵌套的数组或表格</span></span><br><span class="line"></span><br><span class="line">多个数组<span class="string">\表格可</span> **互相嵌套** 并组成一组数组或表格。</span><br><span class="line">使用嵌套前必须声明 `$$` 符号。</span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$$<br>\begin{array}{c} % 总表格<br>    \begin{array}{cc} % 第一行内分成两列<br>        \begin{array}{c|cccc} % 第一列&quot;最小值&quot;数组<br>            \text{min} &amp; 0 &amp; 1 &amp; 2 &amp; 3 \<br>            \hline<br>            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \<br>            1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \<br>            2 &amp; 0 &amp; 1 &amp; 2 &amp; 2 \<br>            3 &amp; 0 &amp; 1 &amp; 2 &amp; 3 \<br>        \end{array}<br>        &amp;<br>        \begin{array}{c|cccc} % 第二列&quot;最大值&quot;数组<br>            \text{max} &amp; 0 &amp; 1 &amp; 2 &amp; 3 \<br>            \hline<br>            0 &amp; 0 &amp; 1 &amp; 2 &amp; 3 \<br>            1 &amp; 1 &amp; 1 &amp; 2 &amp; 3 \<br>            2 &amp; 2 &amp; 2 &amp; 2 &amp; 3 \<br>            3 &amp; 3 &amp; 3 &amp; 3 &amp; 3 \<br>        \end{array}<br>    \end{array} % 第一行表格组结束<br>    \<br>    \begin{array}{c|cccc} % 第二行 Delta 值数组<br>        \Delta &amp; 0 &amp; 1 &amp; 2 &amp; 3 \<br>        \hline<br>        0 &amp; 0 &amp; 1 &amp; 2 &amp; 3 \<br>        1 &amp; 1 &amp; 0 &amp; 1 &amp; 2 \<br>        2 &amp; 2 &amp; 1 &amp; 0 &amp; 1 \<br>        3 &amp; 3 &amp; 2 &amp; 1 &amp; 0 \<br>    \end{array} % 第二行表格结束<br>\end{array} % 总表格结束<br>$$</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">\begin&#123;array&#125;&#123;c&#125; % 总表格</span><br><span class="line">    \begin&#123;array&#125;&#123;cc&#125; % 第一行内分成两列</span><br><span class="line">        \begin&#123;array&#125;&#123;c|cccc&#125; % 第一列&quot;最小值&quot;数组</span><br><span class="line">            \text&#123;min&#125; &amp;<span class="number"> 0 </span>&amp;<span class="number"> 1 </span>&amp;<span class="number"> 2 </span>&amp;<span class="number"> 3 </span>\\</span><br><span class="line">            \hline</span><br><span class="line">           <span class="number"> 0 </span>&amp;<span class="number"> 0 </span>&amp;<span class="number"> 0 </span>&amp;<span class="number"> 0 </span>&amp;<span class="number"> 0 </span>\\</span><br><span class="line">           <span class="number"> 1 </span>&amp;<span class="number"> 0 </span>&amp;<span class="number"> 1 </span>&amp;<span class="number"> 1 </span>&amp;<span class="number"> 1 </span>\\</span><br><span class="line">           <span class="number"> 2 </span>&amp;<span class="number"> 0 </span>&amp;<span class="number"> 1 </span>&amp;<span class="number"> 2 </span>&amp;<span class="number"> 2 </span>\\</span><br><span class="line">           <span class="number"> 3 </span>&amp;<span class="number"> 0 </span>&amp;<span class="number"> 1 </span>&amp;<span class="number"> 2 </span>&amp;<span class="number"> 3 </span>\\</span><br><span class="line">        \end&#123;array&#125;</span><br><span class="line">        &amp;</span><br><span class="line">        \begin&#123;array&#125;&#123;c|cccc&#125; % 第二列&quot;最大值&quot;数组</span><br><span class="line">            \text&#123;max&#125; &amp;<span class="number"> 0 </span>&amp;<span class="number"> 1 </span>&amp;<span class="number"> 2 </span>&amp;<span class="number"> 3 </span>\\</span><br><span class="line">            \hline</span><br><span class="line">           <span class="number"> 0 </span>&amp;<span class="number"> 0 </span>&amp;<span class="number"> 1 </span>&amp;<span class="number"> 2 </span>&amp;<span class="number"> 3 </span>\\</span><br><span class="line">           <span class="number"> 1 </span>&amp;<span class="number"> 1 </span>&amp;<span class="number"> 1 </span>&amp;<span class="number"> 2 </span>&amp;<span class="number"> 3 </span>\\</span><br><span class="line">           <span class="number"> 2 </span>&amp;<span class="number"> 2 </span>&amp;<span class="number"> 2 </span>&amp;<span class="number"> 2 </span>&amp;<span class="number"> 3 </span>\\</span><br><span class="line">           <span class="number"> 3 </span>&amp;<span class="number"> 3 </span>&amp;<span class="number"> 3 </span>&amp;<span class="number"> 3 </span>&amp;<span class="number"> 3 </span>\\</span><br><span class="line">        \end&#123;array&#125;</span><br><span class="line">    \end&#123;array&#125; % 第一行表格组结束</span><br><span class="line">    \\</span><br><span class="line">    \begin&#123;array&#125;&#123;c|cccc&#125; % 第二行 Delta 值数组</span><br><span class="line">        \Delta &amp;<span class="number"> 0 </span>&amp;<span class="number"> 1 </span>&amp;<span class="number"> 2 </span>&amp;<span class="number"> 3 </span>\\</span><br><span class="line">        \hline</span><br><span class="line">       <span class="number"> 0 </span>&amp;<span class="number"> 0 </span>&amp;<span class="number"> 1 </span>&amp;<span class="number"> 2 </span>&amp;<span class="number"> 3 </span>\\</span><br><span class="line">       <span class="number"> 1 </span>&amp;<span class="number"> 1 </span>&amp;<span class="number"> 0 </span>&amp;<span class="number"> 1 </span>&amp;<span class="number"> 2 </span>\\</span><br><span class="line">       <span class="number"> 2 </span>&amp;<span class="number"> 2 </span>&amp;<span class="number"> 1 </span>&amp;<span class="number"> 0 </span>&amp;<span class="number"> 1 </span>\\</span><br><span class="line">       <span class="number"> 3 </span>&amp;<span class="number"> 3 </span>&amp;<span class="number"> 2 </span>&amp;<span class="number"> 1 </span>&amp;<span class="number"> 0 </span>\\</span><br><span class="line">    \end&#123;array&#125; % 第二行表格结束</span><br><span class="line">\end&#123;array&#125; % 总表格结束</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line"><span class="comment">##3．如何输入一个方程组</span></span><br><span class="line"></span><br><span class="line">可以使用 `\begin&#123;array&#125; … \end&#123;array&#125;` 和 `\left\&#123; … \right.` 来创建一个方程组：</span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$$<br>  \left{<br>    \begin{array}{c}<br>        a_1x+b_1y+c_1z=d_1 \<br>        a_2x+b_2y+c_2z=d_2 \<br>        a_3x+b_3y+c_3z=d_3 \<br>    \end{array}<br>  \right.<br>$$</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line"><span class="string">\left\&#123;</span></span><br><span class="line">    <span class="string">\begin&#123;array&#125;&#123;c&#125;</span></span><br><span class="line">        a_1x+b_1y+c_1z=d_1 <span class="string">\\</span></span><br><span class="line">        a_2x+b_2y+c_2z=d_2 <span class="string">\\</span></span><br><span class="line">        a_3x+b_3y+c_3z=d_3 <span class="string">\\</span></span><br><span class="line">    <span class="string">\end&#123;array&#125;</span></span><br><span class="line"><span class="string">\right.</span></span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">或使用条件表达式组 `<span class="string">\begin&#123;cases&#125;</span> … <span class="string">\end&#123;cases&#125;`</span> 来实现相同效果：</span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>\begin{cases}<br>    a_1x+b_1y+c_1z=d_1 \<br>    a_2x+b_2y+c_2z=d_2 \<br>    a_3x+b_3y+c_3z=d_3 \<br>\end{cases}</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line">  $$</span><br><span class="line">    <span class="string">\begin&#123;cases&#125;</span></span><br><span class="line">      a_1x+b_1y+c_1z=d_1 <span class="string">\\</span></span><br><span class="line">      a_2x+b_2y+c_2z=d_2 <span class="string">\\</span></span><br><span class="line">      a_3x+b_3y+c_3z=d_3 <span class="string">\\</span></span><br><span class="line">    <span class="string">\end&#123;cases&#125;</span></span><br><span class="line">  $$</span><br><span class="line"></span><br><span class="line"><span class="comment">#六、连分数使用参考</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##1．如何输入一个连分式</span></span><br><span class="line"></span><br><span class="line">就像输入分式时使用 `<span class="string">\frac`</span> 一样，使用 `<span class="string">\cfrac`</span> 来创建一个连分数。</span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$$<br>x = a_0 + \cfrac{1^2}{a_1 +<br>            \cfrac{2^2}{a_2 +<br>              \cfrac{3^2}{a_3 +<br>                \cfrac{4^4}{a_4 +<br>                  \cdots<br>                }<br>              }<br>            }<br>          }<br>$$</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">x = <span class="built_in">a_0</span> + \cfrac&#123;<span class="number">1</span>^<span class="number">2</span>&#125;&#123;<span class="built_in">a_1</span> +</span><br><span class="line">            \cfrac&#123;<span class="number">2</span>^<span class="number">2</span>&#125;&#123;<span class="built_in">a_2</span> +</span><br><span class="line">              \cfrac&#123;<span class="number">3</span>^<span class="number">2</span>&#125;&#123;<span class="built_in">a_3</span> +</span><br><span class="line">                \cfrac&#123;<span class="number">4</span>^<span class="number">4</span>&#125;&#123;<span class="built_in">a_4</span> +</span><br><span class="line">                  \cdots</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">不要使用普通的 `\frac` 或 `\over` 来生成连分数，看起来会很奇怪。</span><br><span class="line"></span><br><span class="line">- **反例：**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$$<br>x = a_0 + \frac{1^2}{a_1 +<br>            \frac{2^2}{a_2 +<br>              \frac{3^2}{a_3 +<br>                \frac{4^4}{a_4 +<br>                  \cdots<br>                }<br>              }<br>            }<br>          }<br>$$</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line"></span><br><span class="line"><span class="symbol">$</span><span class="symbol">$</span></span><br><span class="line">x = a_0 + \<span class="built_in">frac</span>&#123;<span class="number">1</span>^<span class="number">2</span>&#125;&#123;a_1 +</span><br><span class="line">            \<span class="built_in">frac</span>&#123;<span class="number">2</span>^<span class="number">2</span>&#125;&#123;a_2 +</span><br><span class="line">              \<span class="built_in">frac</span>&#123;<span class="number">3</span>^<span class="number">2</span>&#125;&#123;a_3 +</span><br><span class="line">                \<span class="built_in">frac</span>&#123;<span class="number">4</span>^<span class="number">4</span>&#125;&#123;a_4 +</span><br><span class="line">                  \cdots</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"><span class="symbol">$</span><span class="symbol">$</span></span><br><span class="line"></span><br><span class="line">当然，你可以使用 `\<span class="built_in">frac</span>` 来表达连分数的**紧缩记法**。</span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$$<br>x = a_0 + \frac{1^2}{a_1 +}<br>          \frac{2^2}{a_2 +}<br>          \frac{3^2}{a_3 +}<br>          \frac{4^4}{a_4 +}<br>          \cdots<br>$$</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">x = <span class="built_in">a_0</span> + \frac&#123;<span class="number">1</span>^<span class="number">2</span>&#125;&#123;<span class="built_in">a_1</span> +&#125;</span><br><span class="line">          \frac&#123;<span class="number">2</span>^<span class="number">2</span>&#125;&#123;<span class="built_in">a_2</span> +&#125;</span><br><span class="line">          \frac&#123;<span class="number">3</span>^<span class="number">2</span>&#125;&#123;<span class="built_in">a_3</span> +&#125;</span><br><span class="line">          \frac&#123;<span class="number">4</span>^<span class="number">4</span>&#125;&#123;<span class="built_in">a_4</span> +&#125;</span><br><span class="line">          \cdots</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">连分数通常都太大以至于不易排版，所以建议在连分数前后声明 `$$` 符号，或使用像 `[a0,a1,a2,a3,…]` 一样的紧缩记法。</span><br><span class="line"></span><br><span class="line">#七、交换图表使用参考</span><br><span class="line"></span><br><span class="line">##<span class="number">1</span>．如何输入一个交换图表</span><br><span class="line"></span><br><span class="line"><span class="title">&gt; 推荐使用 Cmd Markdown 自带的各种图功能，详见 [Cmd Markdown 高阶语法手册](https://www.zybuluo.com/mdeditor?url=https:</span>//www.zybuluo.com/static/editor/md-help.markdown#<span class="number">7</span>-<span class="variable">%E6%</span>B5<span class="variable">%81%</span>E7<span class="variable">%A8%</span><span class="number">8</span>B<span class="variable">%E5%</span><span class="number">9</span>B%BE)。</span><br><span class="line"></span><br><span class="line">使用一行 `\require&#123;AMScd&#125;` 语句来允许交换图表的显示。</span><br><span class="line">声明交换图表后，语法与矩阵相似，在开头使用 `\begin&#123;CD&#125;`，在结尾使用 `\ end&#123;CD&#125;`，在中间插入图表元素，每个元素之间插入 `&amp;` ，并在每行结尾处使用 `\\`。</span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$$<br>\require{AMScd}<br>\begin{CD}<br>    A @&gt;a&gt;&gt; B \<br>    @V b V V# @VV c V \<br>    C @&gt;&gt;d&gt; D \<br>\end{CD}<br>$$</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">\require&#123;AMScd&#125;</span><br><span class="line">\begin&#123;CD&#125;</span><br><span class="line">    A @&gt;a&gt;&gt; B \\</span><br><span class="line">    @V b V V\# @VV c V \\</span><br><span class="line">    C @&gt;&gt;d&gt; D \\</span><br><span class="line">\end&#123;CD&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">其中，`@&gt;&gt;&gt;` 代表右箭头、`@&lt;&lt;&lt;` 代表左箭头、`@VVV` 代表下箭头、`@AAA` 代表上箭头、`@=` 代表水平双实线、`@|` 代表竖直双实线、`@.`代表没有箭头。</span><br><span class="line">在 `@&gt;&gt;&gt;` 的 `&gt;&gt;&gt;` 之间任意插入文字即代表该箭头的注释文字。</span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$$<br>\require{AMDcd}<br>\begin{CD}<br>    A @&gt;&gt;&gt; B @&gt;{\text{very long label}}&gt;&gt; C \<br>    @. @AAA @| \<br>    D @= E @&lt;&lt;&lt; F \<br>\end{CD}<br>$$</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">\require&#123;AMDcd&#125;</span><br><span class="line">\begin&#123;CD&#125;</span><br><span class="line">    A @&gt;&gt;&gt; B @&gt;&#123;\<span class="keyword">text</span>&#123;very long label&#125;&#125;&gt;&gt; C \\</span><br><span class="line">    @. @AAA @| \\</span><br><span class="line">    D @= E @&lt;&lt;&lt; F \\</span><br><span class="line">\end&#123;CD&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">在本例中，<span class="string">`very long label`</span> 自动延长了它所在箭头以及对应箭头的长度，因而交换图表十分适合进行化学反应式的书写。</span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$$<br>\require{AMDcd}<br>\begin{CD}<br>    \rm{RCOHR^{&#39;}SO_3Na} @&gt;{\large\text{Hydrolysis, $\Delta$, Dil.HCl}}&gt;&gt; \rm{(RCOR^{&#39;})+NaCl+SO_2+ H_2O}<br>\end{CD}<br>$$</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line"></span><br><span class="line"><span class="variable">$$</span></span><br><span class="line">\<span class="keyword">require</span>&#123;<span class="title class_">AMDcd</span>&#125;</span><br><span class="line">\begin&#123;<span class="title class_">CD</span>&#125;</span><br><span class="line">    \rm&#123;<span class="title class_">RCOHR</span>^&#123;<span class="string">&#x27;&#125;SO_3Na&#125; @&gt;&#123;\large\text&#123;Hydrolysis, $\Delta$, Dil.HCl&#125;&#125;&gt;&gt; \rm&#123;(RCOR^&#123;&#x27;</span>&#125;)+<span class="title class_">NaCl</span>+<span class="title class_">SO_2</span>+ <span class="title class_">H_2O</span>&#125;</span><br><span class="line">\<span class="keyword">end</span>&#123;<span class="title class_">CD</span>&#125;</span><br><span class="line"><span class="variable">$$</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#八、一些特殊的注意事项</span></span><br><span class="line"></span><br><span class="line">| **!! 本段内容为个人翻译，可能有不准确之处 !!** |</span><br><span class="line">| <span class="symbol">:--------------------------------------------</span>: |</span><br><span class="line"></span><br><span class="line"><span class="title class_">These</span> are issues that won<span class="string">&#x27;t affect the correctness of formulas, but might make them look significantly better or worse. Beginners should feel free to ignore this advice; someone else will correct it for them, or more likely nobody will care.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">现在指出的小问题并不会影响公式的正确显示，但能让它们看起来明显更好看。初学者可无视这些建议，自然会有强迫症患者替你们改掉它的，或者更可能地，不会有人在意这些细节。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Don&#x27;</span>t <span class="keyword">use</span> `\frac` <span class="keyword">in</span> exponents <span class="keyword">or</span> limits of integrals; it looks bad <span class="keyword">and</span> can be confusing, which is why it is rarely done <span class="keyword">in</span> professional mathematical typesetting. <span class="title class_">Write</span> the fraction horizontally, <span class="keyword">with</span> a <span class="symbol">slash:</span></span><br><span class="line"></span><br><span class="line">在以 <span class="variable">$e</span><span class="variable">$ </span>为底的指数函数、极限和积分中尽量不要使用 `\frac` 符号——它会使整段函数看起来很奇怪并可能产生歧义，因此它在专业数学排版中几乎从不出现。可试着横着写这些分式，中间使用斜线间隔 `/` （用斜线代替分数线）。</span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>\begin{array}{cc}<br>    \mathrm{Bad} &amp; \mathrm{Better} \<br>    \hline \<br>    \large e^{i\frac{\pi}2} \quad e^{\frac{i\pi}2}&amp; \large e^{i\pi/2} \[2ex]<br>    \int_{-\frac\pi2}^\frac\pi2 \sin x,dx &amp; \int_{-\pi/2}^{\pi/2}\sin x,dx \<br>\end{array}</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line">  $$</span><br><span class="line">  <span class="string">\begin&#123;array&#125;&#123;cc&#125;</span></span><br><span class="line">      <span class="string">\mathrm&#123;Bad&#125;</span> &amp; <span class="string">\mathrm&#123;Better&#125;</span> <span class="string">\\</span></span><br><span class="line">      <span class="string">\hline</span> <span class="string">\\</span></span><br><span class="line">      <span class="string">\large</span> e^&#123;i<span class="string">\frac&#123;\pi&#125;2&#125;</span> <span class="string">\quad</span> e^&#123;<span class="string">\frac&#123;i\pi&#125;2&#125;&amp;</span> <span class="string">\large</span> e^&#123;i<span class="string">\pi/2&#125;</span> <span class="string">\\[2ex]</span></span><br><span class="line">      <span class="string">\int_&#123;-\frac\pi2&#125;^\frac\pi2</span> <span class="string">\sin</span> x<span class="string">\,dx</span> &amp; <span class="string">\int_&#123;-\pi/2&#125;^&#123;\pi/2&#125;\sin</span> x<span class="string">\,dx</span> <span class="string">\\</span></span><br><span class="line">    <span class="string">\end&#123;array&#125;</span></span><br><span class="line">  $$</span><br><span class="line"></span><br><span class="line">使用 `|` 符号作为分隔符时会产生错误的间距，因此在需要分隔时最好使用 `<span class="string">\mid`</span> 来代替它。</span><br><span class="line"></span><br><span class="line">- 例子:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>\begin{array}{cc}<br>    \mathrm{Bad} &amp; \mathrm{Better} \<br>    \hline \<br>    {x|x^2\in\Bbb Z} &amp; {x\mid x^2\in\Bbb Z} \<br>\end{array}</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">-</span> 显示：</span><br><span class="line">  $$</span><br><span class="line">  \begin&#123;array&#125;&#123;cc&#125;</span><br><span class="line"><span class="code">      \mathrm&#123;Bad&#125; &amp; \mathrm&#123;Better&#125; \\</span></span><br><span class="line"><span class="code">      \hline \\</span></span><br><span class="line"><span class="code">      \&#123;x|x^2\in\Bbb Z\&#125; &amp; \&#123;x\mid x^2\in\Bbb Z\&#125; \\</span></span><br><span class="line"><span class="code">    \end&#123;array&#125;</span></span><br><span class="line"><span class="code">  $$</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">For double and triple integrals, don&#x27;t use <span class="code">`\int\int`</span> or <span class="code">`\int\int\int`</span>. Instead use the special forms <span class="code">`\iint`</span> and <span class="code">`\iiint`</span>:</span><br><span class="line"></span><br><span class="line">使用多重积分符号时，不要多次使用 <span class="code">`\int`</span> 来声明，直接使用 <span class="code">`\iint`</span> 来表示二重积分或 <span class="code">`\iiint`</span> 来表示三重积分。</span><br><span class="line">在表示面积分和体积分时下标建议使用 <span class="code">`\boldsymbol&#123;S&#125;`</span> 和 <span class="code">`\boldsymbol&#123;V&#125;`</span> 符号；对于多维函数的超体积，可使用 <span class="code">`\idotsint`</span>，如下面的例子所示。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>\begin{array}{cc}<br>    \mathrm{Bad} &amp; \mathrm{Better} \<br>    \hline \<br>    \int\int_S f(x),dy,dx &amp; \iint_{\boldsymbol{S}} f(x),{\rm d}y,{\rm d}x \<br>    \int\int\int_V f(x),dz,dy,dx &amp; \iiint_{\boldsymbol{V}} f(x),{\rm d}z,{\rm d}y,{\rm d}x \[3ex]<br>    \hline \<br>    \text{多重积分示例} &amp; \idotsint_{\boldsymbol{D}} f(x_1,x_2,,\cdots, ,x_n),{\rm d}x_1\cdots{\rm d}x_n<br>\end{array}</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显示：</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line"><span class="string">\require&#123;AMSmath&#125;</span></span><br><span class="line"><span class="string">\begin&#123;array&#125;&#123;cc&#125;</span></span><br><span class="line">    <span class="string">\mathrm&#123;Bad&#125;</span> &amp; <span class="string">\mathrm&#123;Better&#125;</span> <span class="string">\\</span></span><br><span class="line">    <span class="string">\hline</span> <span class="string">\\</span></span><br><span class="line">    <span class="string">\int\int_S</span> f(x)<span class="string">\,dy\,dx</span> &amp; <span class="string">\iint_&#123;\boldsymbol&#123;S&#125;&#125;</span> f(x)<span class="string">\,&#123;\rm</span> d&#125;y<span class="string">\,&#123;\rm</span> d&#125;x <span class="string">\\</span></span><br><span class="line">    <span class="string">\int\int\int_V</span> f(x)<span class="string">\,dz\,dy\,dx</span> &amp; <span class="string">\iiint_&#123;\boldsymbol&#123;V&#125;&#125;</span> f(x)<span class="string">\,&#123;\rm</span> d&#125;z<span class="string">\,&#123;\rm</span> d&#125;y<span class="string">\,&#123;\rm</span> d&#125;x <span class="string">\\[3ex]</span></span><br><span class="line">    <span class="string">\hline</span> <span class="string">\\</span></span><br><span class="line">    <span class="string">\text&#123;多重积分示例&#125;</span> &amp; <span class="string">\idotsint_&#123;\boldsymbol&#123;D&#125;&#125;</span> f(x_1,x_2,<span class="string">\,\cdots\,</span> ,x_n)<span class="string">\,&#123;\rm</span> d&#125;x_1<span class="string">\cdots&#123;\rm</span> d&#125;x_n</span><br><span class="line"><span class="string">\end&#123;array&#125;</span></span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">Use `<span class="string">\,`,</span> <span class="keyword">to</span> insert a thin space before differentials; without this $<span class="string">\TeX$</span> will mash them together:</span><br><span class="line"></span><br><span class="line">使用多重积分时，在被积变量后加入 `<span class="string">\,`</span> （或在微分符号 $&#123;<span class="string">\rm</span> d&#125;$ 之前）来插入一个小的间距，否则各种被积变量将会挤成一团。注意比较 $&#123;<span class="string">\rm</span> d&#125;z&#123;<span class="string">\rm</span> d&#125; y&#123;<span class="string">\rm</span> d&#125; x$ 的不同。</span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>\begin{array}{cc}<br>    \mathrm{Bad} &amp; \mathrm{Better} \<br>    \hline \<br>    \iiint_V f(x){\rm d}z {\rm d}y {\rm d}x &amp; \iiint_{\boldsymbol{V}} f(x),{\rm d}z,{\rm d}y,{\rm d}x \<br>\end{array}</p>
<pre><code>
- 显示：
  $$
  \begin&#123;array&#125;&#123;cc&#125;
      \mathrm&#123;Bad&#125; &amp; \mathrm&#123;Better&#125; \\
      \hline \\
      \iiint_V f(x)&#123;\rm d&#125;z &#123;\rm d&#125;y &#123;\rm d&#125;x &amp; \iiint_&#123;\boldsymbol&#123;V&#125;&#125; f(x)\,&#123;\rm d&#125;z\,&#123;\rm d&#125;y\,&#123;\rm d&#125;x \\
    \end&#123;array&#125;
  $$

---

感谢您花费时间阅读这份指导手册，本手册内容可能有疏漏之处，欢迎更改指正。
更多语法请参见：[Cmd Markdown 简明语法手册](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown)，[Cmd Markdown 高阶语法手册](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册)。
祝您记录、阅读、分享愉快！

Drafted &amp; Translated by [Eric P.](https://ericp.cn)
2015-10-02
</code></pre>
]]></content>
      <categories>
        <category>教程</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>头歌 - 机器学习 - 逻辑回归</title>
    <url>//2023/05/11/educoder-ml-homework/</url>
    <content><![CDATA[<h1 id="【educoder】-机器学习-逻辑回归"><a href="#【educoder】-机器学习-逻辑回归" class="headerlink" title="【educoder】 机器学习 --- 逻辑回归"></a>【educoder】 机器学习 --- 逻辑回归</h1><h2 id="第-1-关：逻辑回归核心思想"><a href="#第-1-关：逻辑回归核心思想" class="headerlink" title="第 1 关：逻辑回归核心思想"></a>第 1 关：逻辑回归核心思想</h2><h3 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：根据本节课所学知识完成本关所设置的编程题。</p>
<h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握：</p>
<ul>
<li>什么是逻辑回归；</li>
<li><code>sigmoid</code>函数。</li>
</ul>
<h3 id="什么是逻辑回归"><a href="#什么是逻辑回归" class="headerlink" title="什么是逻辑回归"></a>什么是逻辑回归</h3><p>当一看到“回归”这两个字，可能会认为逻辑回归是一种解决回归问题的算法，然而逻辑回归是通过回归的思想来解决<strong>二分类</strong>问题的算法。</p>
<p>那么问题来了，回归的算法怎样解决分类问题呢？其实很简单，逻辑回归是将样本特征和样本所属类别的概率联系在一起，假设现在已经训练好了一个逻辑回归的模型为 <em>f</em>(<em>x</em>) ，模型的输出是样本 x 的标签是 1 的概率，则该模型可以表示，$\widehat{p}=f(x)$ 。若得到了样本 x 属于标签 1 的概率后，很自然的就能想到当$\widehat{p}&gt;0.5$ 时 x 属于标签 1 ，否则属于标签 0 。所以就有</p>
<p>$$<br>\widehat{y} =<br>\begin{cases}<br>0, &amp; \widehat{p}&lt;0.5 \[2ex]<br>1, &amp; \widehat{p}&gt;0.5 \<br>\end{cases}<br>$$</p>
<p>(其中 _y_^ 为样本 x 根据模型预测出的标签结果，标签 0 和标签 1 所代表的含义是根据业务决定的，比如在癌细胞识别中可以使 0 代表良性肿瘤， 1 代表恶性肿瘤)。</p>
<p><strong>由于概率是 0 到 1 的实数，所以逻辑回归若只需要计算出样本所属标签的概率就是一种回归算法，若需要计算出样本所属标签，则就是一种二分类算法。</strong></p>
<p>那么逻辑回归中样本所属标签的概率怎样计算呢？其实和线性回归有关系，学习了线性回归的同学肯定知道线性回归无非就是训练出一组参数 <em>W**T</em> 和 <em>b</em> 来拟合样本数据，线性回归的输出为$\widehat{y}=W^{T}+b$。不过 $\widehat{y}$的值域是 (−∞,+∞) ，如果能够将值域为 (−∞,+∞) 的实数转换成 (0,1) 的概率值的话问题就解决了。<strong>要解决这个问题很自然地就能想到将线性回归的输出作为输入，输入到另一个函数中，这个函数能够进行转换工作，假设函数为 *σ* ，转换后的概率为 $\widehat{p}$ ，则逻辑回归在预测时可以看成$\widehat{p}=\sigma{\left( W^{T}+b \right)}$ 。</strong> <em>σ</em> 其实就是接下来要介绍的<code>sigmoid</code>函数。</p>
<h5 id="sigmoid-函数"><a href="#sigmoid-函数" class="headerlink" title="sigmoid 函数"></a>sigmoid 函数</h5><p><code>sigmoid</code>函数的公式为：</p>
<p>$$<br>\sigma{(t)}= \frac{1}{1+e^{-t}} \label(<br>$$</p>
<p>函数图像如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/313532" alt="sigmoid 函数"></p>
<p>从<code>sigmoid</code>函数的图像可以看出当 t 趋近于 −∞ 时函数值趋近于 0 ，当 t 趋近于 +∞ 时函数值趋近于 1 。可见<code>sigmoid</code>函数的值域是 (0,1) ，满足我们要将 (−∞,+∞) 的实数转换成 (0,1) 的概率值的需求。因此逻辑回归在预测时可以看成</p>
<p>$$<br>\widehat{p}=\frac{1}{1+e^{-W^{t}x+b}}<br>$$</p>
<h3 id="编程要求"><a href="#编程要求" class="headerlink" title="编程要求"></a>编程要求</h3><p>根据提示，在右侧编辑器补充 Python 代码，实现<code>sigmoid</code>函数。底层代码会调用您实现的<code>sigmoid</code>函数来进行测试。(<strong>提示: <code>numpy.exp()</code>函数可以实现 e 的幂运算</strong>)</p>
<h3 id="测试说明"><a href="#测试说明" class="headerlink" title="测试说明"></a>测试说明</h3><p>测试用例：</p>
<p>输入：<code>1</code></p>
<p>预期输出：<code>0.73105857863</code></p>
<p>输入：<code>-2</code></p>
<p>预期输出：<code>0.119202922022</code></p>
<h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding=utf8</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        完成sigmoid函数计算</span></span><br><span class="line"><span class="string">        :param t: 负无穷到正无穷的实数</span></span><br><span class="line"><span class="string">        :return: 转换后的概率值</span></span><br><span class="line"><span class="string">        :可以考虑使用np.exp()函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># ********** Begin **********#</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / (<span class="number">1</span> + np.exp(-t))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ********** End **********#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第-2-关：逻辑回归的损失函数"><a href="#第-2-关：逻辑回归的损失函数" class="headerlink" title="第 2 关：逻辑回归的损失函数"></a>第 2 关：逻辑回归的损失函数</h2><h3 id="任务描述-1"><a href="#任务描述-1" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：根据本节课所学知识完成本关所设置的选择题。</p>
<h3 id="相关知识-1"><a href="#相关知识-1" class="headerlink" title="相关知识"></a>相关知识</h3><h4 id="为什么需要损失函数"><a href="#为什么需要损失函数" class="headerlink" title="为什么需要损失函数"></a>为什么需要损失函数</h4><p>训练逻辑回归模型的过程其实与之前学习的线性回归一样，就是去寻找合适的 <em>W**T</em> 和 <em>b</em> 使得模型的预测结果与真实结果尽可能一致。<strong>所以就需要一个函数能够衡量模型拟合程度的好坏，也就是说当模型拟合误差越大的时候，函数值应该比较大，反之应该比较小，这就是损失函数。</strong></p>
<h4 id="逻辑回归的损失函数"><a href="#逻辑回归的损失函数" class="headerlink" title="逻辑回归的损失函数"></a>逻辑回归的损失函数</h4><p>根据上一关中所学习到的知识，我们已经知道了逻辑回归计算出的样本所属类别的概率 $\widehat{p} = \sigma{W^{T}+b}$ ，样本所属列表的判定条件为</p>
<p>$$<br>\widehat{y} =<br>    \begin{cases}<br>        0, &amp; \widehat{p}&lt;0.5 \[2ex]<br>        1, &amp; \widehat{p}&gt;0.5<br>    \end{cases}<br>$$</p>
<p>很明显，在预测样本属于哪个类别时取决于算出来的<em>p</em>^。从另外一个角度来说，假设现在有一个样本的真实类别为 1 ，模型预测样本为类别 1 的概率为 0.9 的话，就意味着这个模型认为当前样本的类别有 90% 的可能性为 1 ，有 10% 的可能性为<code>0</code>。所以从这个角度来看，逻辑回归的损失函数与 _p_^ 有关。</p>
<p>当然逻辑回归的损失函数不仅仅与 _p_^ 有关，它还与真实类别有关。假设现在有两种情况，情况 A：现在有个样本的真实类别是 0 ，但是模型预测出来该样本是类别 1 的概率是 0.7 （也就是说类别 0 的概率为 0.3 ）；情况 B：现在有个样本的真实类别是 0 ，但是模型预测出来该样本是类别 1 的概率是 0.6 （也就是说类别 0 的概率为 0.4 ）；请你思考 2 秒钟，AB 两种情况哪种情况的误差更大？很显然，情况 A 的误差更大！因为情况 A 中模型认为样本是类别 0 的可能性只有 30% ，而 B 有 40% 。</p>
<p>假设现在又有两种情况，<strong>情况 A：</strong>现在有个样本的真实类别是 0 ，但是模型预测出来该样本是类别 1 的概率是 0.7 （也就是说类别 0 的概率为 0.3 ）；<strong>情况 B：</strong>现在有个样本的真实类别是 1 ，但是模型预测出来该样本是类别 1 的概率是 0.3 （也就是说类别 0 的概率为 0.7 ）；请你再思考 2 秒钟，AB 两种情况哪种情况的误差更大？很显然，<strong>一样大！</strong></p>
<p>所以逻辑回归的损失函数如下，其中 cost 表示损失函数的值， y 表示样本的真实类别：</p>
<p>$$<br>cost = -y\log{(\widehat{p})}-(1-y)\log{(1-\widehat{p})}<br>$$</p>
<p>这个式子其实很好理解，当样本的真实类别为 1 时，式子就变成了 $cost=-\log{\widehat{p}}$。此时函数图像如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/278099" alt="cost"></p>
<p>从图像能看出当样本的真实类别为 1 的前提下，$\widehat{p}$ 越大，损失函数值就越小。因为 $\widehat{p}$ 越大就越说明模型越认为该样本的类别为 1 。</p>
<p>当样本的真实类别为 0 时，式子就变成了 $cost=-\log{1-\widehat{p}}$ 。此时函数图像如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/278098" alt="cost"></p>
<p>从图像能看出当样本的真实类别为 0 的前提下，<strong>hatp</strong> 越大，损失函数值就越大。因为 $\widehat{p}$ 越大就越说明模型越认为该样本的类别为 1 。</p>
<p>$cost = -y\log{(\widehat{p})}-(1-y)\log{1-\widehat{p}}$是一个样本的损失计算公式，但是在一般情况下需要计算的是 m 条样本数据的平均损失值，所以损失函数的最终形态如下，其中 m 表示数据集中样本的数量， i 表示数据集中第 i 个样本：</p>
<p>$$<br>cost=-\frac{1}{m}\sum_{i=0}^{m}y^{(i)}\log{(\widehat{p}^{(i)})}-(1-y^{(i)})\log{(1-\widehat{p}^{(i)})}<br>$$</p>
<p>知道了逻辑回归的损失函数之后，逻辑回归的训练流程就很明显了，就是寻找一组合适的 W^T^ 和 <em>b</em> ，使得损失值最小。找到这组参数后模型就确定下来了。</p>
<h3 id="编程要求-1"><a href="#编程要求-1" class="headerlink" title="编程要求"></a>编程要求</h3><p>根据相关知识，按照要求完成右侧选择题任务，包含单选题和多选题。</p>
<h3 id="测试说明-1"><a href="#测试说明-1" class="headerlink" title="测试说明"></a>测试说明</h3><p>平台会对你选择的答案进行判断，全对则通过测试。</p>
<h3 id="参考答案-1"><a href="#参考答案-1" class="headerlink" title="参考答案"></a>参考答案</h3><ol>
<li><p>逻辑回归的损失函数可以写成如下形式</p>
<p>$$<br>cost=\begin{cases}</p>
<pre><code>-\log&#123;(\widehat&#123;p&#125;)&#125;,         &amp; y=1 \\[2ex]
-\log&#123;(1-\widehat&#123;p&#125;)&#125;,        &amp; y=0
</code></pre>
<p>\end{cases}<br>$$</p>
<ul>
<li>A、对</li>
<li>B、错</li>
</ul>
</li>
<li><p>下列说法正确的是</p>
<ul>
<li>A、损失值能够衡量模型在训练数据集上的拟合程度</li>
<li>B、sigmoid 函数不可导</li>
<li>C、sigmoid 函数的输入越大，输出就越大</li>
<li>D、训练的过程，就是寻找合适的参数使得损失函数值最小的过程</li>
</ul>
</li>
<li><p><code>sigmoid</code>函数(<strong>对数几率函数</strong>)相对于单位阶跃函数有哪些好处？</p>
<ul>
<li>A、sigmoid 函数可微分</li>
<li>B、sigmoid 函数处处连续</li>
<li>C、sigmoid 函数不是单调的</li>
<li>D、sigmoid 函数最多计算二阶导</li>
</ul>
</li>
<li><p>逻辑回归的优点有哪些？</p>
<ul>
<li>A、需要事先对数据的分布做假设</li>
<li>B、可以得到“类别”的真正的概率预测</li>
<li>C、可以用闭式解求解</li>
<li>D、可以用现有的数值优化算法求解</li>
</ul>
</li>
</ol>
<blockquote>
<ol>
<li>A</li>
<li>ACD</li>
<li>AB</li>
<li>D</li>
</ol>
</blockquote>
<h2 id="第-3-关：梯度下降"><a href="#第-3-关：梯度下降" class="headerlink" title="第 3 关：梯度下降"></a>第 3 关：梯度下降</h2><h3 id="任务描述-2"><a href="#任务描述-2" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：用 Python 构建梯度下降算法，并求取目标函数最小值。</p>
<h3 id="相关知识-2"><a href="#相关知识-2" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握：<strong>梯度下降算法</strong>。</p>
<h4 id="什么是梯度"><a href="#什么是梯度" class="headerlink" title="什么是梯度"></a>什么是梯度</h4><p><strong>梯度：</strong>梯度的本意是一个向量，由函数对每个参数的偏导组成，表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在该点处沿着该方向变化最快，变化率最大。</p>
<p><img src="https://data.educoder.net/api/attachments/278100" alt="梯度"></p>
<h5 id="梯度下降算法原理"><a href="#梯度下降算法原理" class="headerlink" title="梯度下降算法原理"></a>梯度下降算法原理</h5><p>算法思想：梯度下降是一种非常通用的优化算法，能够为大范围的问题找到最优解。梯度下降的中心思想就是迭代地调整参数从而使损失函数最小化。假设你迷失在山上的迷雾中，你能感觉到的只有你脚下路面的坡度。快速到达山脚的一个策略就是沿着最陡的方向下坡。这就是梯度下降的做法：通过测量参数向量 θ 相关的损失函数的局部梯度，并不断沿着降低梯度的方向调整，直到梯度降为 0 ，达到最小值。</p>
<p>梯度下降公式如下：</p>
<p><img src="https://data.educoder.net/api/attachments/268776" alt="梯度下降公式"></p>
<p>对应到每个权重公式为：</p>
<p><img src="https://data.educoder.net/api/attachments/268777" alt="每个权重的公式"></p>
<p>其中 η 为学习率，是 0 到 1 之间的值，是个超参数，需要我们自己来确定大小。</p>
<p>算法原理： 在传统机器学习中，损失函数通常为凸函数，假设此时只有一个参数，则损失函数对参数的梯度即损失函数对参数的导数。如果刚开始参数初始在最优解的左边，</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/278101" alt="损失函数"></p>
<p>很明显，这个时候损失函数对参数的导数是小于 0 的，而学习率是一个 0 到 1 之间的数，此时按照公式更新参数，初始的参数减去一个小于 0 的数是变大，也就是在坐标轴上往右走，即朝着最优解的方向走。同样的，如果参数初始在最优解的右边，</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/278102" alt="损失函数"></p>
<p>此时按照公式更新，参数将会朝左走，即最优解的方向。所以，不管刚开始参数初始在何位置，按着梯度下降公式不断更新，参数都会朝着最优解的方向走。 #####梯度下降算法流程</p>
<ol>
<li>随机初始参数；</li>
<li>确定学习率；</li>
<li>求出损失函数对参数梯度；</li>
<li>按照公式更新参数；</li>
<li>重复 3 、 4 直到满足终止条件（<strong>如：损失函数或参数更新变化值小于某个阈值，或者训练次数达到设定阈值</strong>）。</li>
</ol>
<h3 id="编程要求-2"><a href="#编程要求-2" class="headerlink" title="编程要求"></a>编程要求</h3><p>根据提示，使用 Python 实现梯度下降算法，并损失函数最小值时对应的参数<code>theta</code>，<code>theta</code>会返回给外部代码，由外部代码来判断<code>theta</code>是否正确。</p>
<h3 id="测试说明-2"><a href="#测试说明-2" class="headerlink" title="测试说明"></a>测试说明</h3><p>损失函数为：<em>l<strong>o</strong>s**s</em>=2∗(<em>θ</em>−3) 最优参数为：<code>3.0</code> 你的答案跟最优参数的误差低于<code>0.0001</code>才能通关。</p>
<h3 id="参考答案-2"><a href="#参考答案-2" class="headerlink" title="参考答案"></a>参考答案</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradient_descent</span>(<span class="params">initial_theta, eta=<span class="number">0.05</span>, n_iters=<span class="number">1000</span>, epslion=<span class="number">1e-8</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        梯度下降</span></span><br><span class="line"><span class="string">        :param initial_theta: 参数初始值，类型为float</span></span><br><span class="line"><span class="string">        :param eta: 学习率，类型为float</span></span><br><span class="line"><span class="string">        :param n_iters: 训练轮数，类型为int</span></span><br><span class="line"><span class="string">        :param epslion: 容忍误差范围，类型为float</span></span><br><span class="line"><span class="string">        :return: 训练后得到的参数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># ********** Begin *********#</span></span><br><span class="line">    theta = initial_theta</span><br><span class="line">    i_iter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i_iter &lt; n_iters:</span><br><span class="line">        gradient = <span class="number">2</span> * (theta - <span class="number">3</span>)</span><br><span class="line">        last_theta = theta</span><br><span class="line">        theta = theta - eta * gradient</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(theta - last_theta) &lt; epslion):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        i_iter += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line">    <span class="comment"># ********** End **********#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第-4-关：动手实现逻辑回归-癌细胞精准识别"><a href="#第-4-关：动手实现逻辑回归-癌细胞精准识别" class="headerlink" title="第 4 关：动手实现逻辑回归 - 癌细胞精准识别"></a>第 4 关：动手实现逻辑回归 - 癌细胞精准识别</h2><h3 id="任务描述-3"><a href="#任务描述-3" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：使用逻辑回归算法建立一个模型，并通过梯度下降算法进行训练，得到一个能够准确对癌细胞进行识别的模型。</p>
<h3 id="相关知识-3"><a href="#相关知识-3" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握：</p>
<ul>
<li>逻辑回归算法流程；</li>
<li>逻辑回归中的梯度下降。</li>
</ul>
<h4 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h4><p>乳腺癌数据集，其实例数量是 569 ，实例中包括诊断类和属性，帮助预测的属性一共 30 个，各属性包括为 radius 半径（从中心到边缘上点的距离的平均值）， texture 纹理（灰度值的标准偏差）等等，类包括： WDBC-Malignant 恶性和 WDBC-Benign 良性。用数据集的 80% 作为训练集，数据集的 20% 作为测试集，训练集和测试集中都包括特征和类别。其中特征和类别均为数值类型，类别中 0 代表良性， 1 代表恶性。</p>
<h4 id="构建逻辑回归模型"><a href="#构建逻辑回归模型" class="headerlink" title="构建逻辑回归模型"></a>构建逻辑回归模型</h4><p>由数据集可以知道，每一个样本有 30 个特征和 1 个标签，而我们要做的事就是通过这 30 个特征来分析细胞是良性还是恶性(其中标签 y=0 表示是良性， y=1 表示是恶性)。逻辑回归算法正好是一个二分类模型，我们可以构建一个逻辑回归模型，来对癌细胞进行识别。模型如下：</p>
<p>$$<br>z = b+\omega_1x_1+\omega_2x_2+\dots+\omega_nx_n \<br>y = \frac{1}{1+e^{-z}}<br>$$</p>
<p>其中 <code>xi</code>表示第 i 个特征，<code>wi</code>表示第 i 个特征对应的权重，<code>b</code>表示偏置。 为了方便，我们稍微将模型进行变换：</p>
<p>$$<br>z = \omega_0x_0+\omega_1x_1+\omega_2x_2+\dots+\omega_nx_n<br>$$</p>
<p>其中<code>x0</code>等于 1 。</p>
<p>$$<br>Z=heta.X \<br>heta = (\omega_0,\omega_1,\dots,\omega_n) \<br>X = (1,x_1,\dots,x_n)<br>y=\frac{1}{1+e^{-\theta.X}}<br>$$</p>
<p>我们将一个样本输入模型，如果预测值大于等于 0.5 则判定为 1 类别，如果小于 0.5 则判定为 0 类别。</p>
<h4 id="训练逻辑回归模型"><a href="#训练逻辑回归模型" class="headerlink" title="训练逻辑回归模型"></a>训练逻辑回归模型</h4><p>我们已经知道如何构建一个逻辑回归模型，但是如何得到一个能正确对癌细胞进行识别的模型呢？通常，我们先将数据输入到模型，从而得到一个预测值，再将预测值与真实值结合，得到一个损失函数，最后用梯度下降的方法来优化损失函数，从而不断的更新模型的参数 θ ，最后得到一个能够正确对良性细胞和癌细胞进行分类的模型。</p>
<p><img src="https://data.educoder.net/api/attachments/278090" alt="训练逻辑回归模型"></p>
<p>在上一节中，我们知道要使用梯度下降算法首先要知道损失函数对参数的梯度，即损失函数对每个参数的偏导，求解步骤如下：</p>
<p>$$<br>loss = -y\ln{a}-(1-y)\ln(1-a) \<br>\frac{\partial loss}{\partial a} = -\frac{y}{a} - \frac{1-y}{1-a}(-1) = \frac{a-y}{a(1-a)} \<br>\frac{\partial a}{\partial z} = \frac{e^{-z}}{(1+e^{-z})^2}=a.(1-a) \<br>\frac{\partial z}{\partial \omega} = x \<br>\frac{\partial loss}{\partial \omega} = (a-y)x<br>$$</p>
<p>其中<code>a</code>为预测值，<code>y</code>为真实值。 于是，在逻辑回归中的梯度下降公式如下：</p>
<p>$$<br>\omega_i = \omega_i - \eta(a-y)x_i<br>$$</p>
<p>训练流程：</p>
<p>同梯度下降算法流程：<strong>请参见上一关卡</strong>。</p>
<h3 id="编程要求-3"><a href="#编程要求-3" class="headerlink" title="编程要求"></a>编程要求</h3><p>根据提示，在右侧编辑器<code>Begin-End</code>处补充 Python 代码，构建一个逻辑回归模型，并对其进行训练，最后将得到的逻辑回归模型对癌细胞进行识别。</p>
<h3 id="测试说明-3"><a href="#测试说明-3" class="headerlink" title="测试说明"></a>测试说明</h3><p>只需返回预测结果即可，程序内部会检测您的代码，预测正确率高于 95% 视为过关。</p>
<p><strong>提示：</strong>构建模型时 <em>x</em>0 是添加在数据的左边，请根据提示构建模型,且返回<code>theta</code>形状为<code>(n,)</code>，<code>n</code>为特征个数。</p>
<h3 id="参考答案-3"><a href="#参考答案-3" class="headerlink" title="参考答案"></a>参考答案</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        sigmoid函数</span></span><br><span class="line"><span class="string">        :param x: 转换前的输入</span></span><br><span class="line"><span class="string">        :return: 转换后的概率</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">x, y, eta=<span class="number">1e-3</span>, n_iters=<span class="number">10000</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        训练逻辑回归模型</span></span><br><span class="line"><span class="string">        :param x: 训练集特征数据，类型为ndarray</span></span><br><span class="line"><span class="string">        :param y: 训练集标签，类型为ndarray</span></span><br><span class="line"><span class="string">        :param eta: 学习率，类型为float</span></span><br><span class="line"><span class="string">        :param n_iters: 训练轮数，类型为int</span></span><br><span class="line"><span class="string">        :return: 模型参数，类型为ndarray</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#   请在此添加实现代码   #</span></span><br><span class="line">    <span class="comment"># ********** Begin *********#</span></span><br><span class="line">    theta = np.zeros(x.shape[<span class="number">1</span>])</span><br><span class="line">    i_iter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i_iter &lt; n_iters:</span><br><span class="line">        gradient = (sigmoid(x.dot(theta)) - y).dot(x)</span><br><span class="line">        theta = theta - eta * gradient</span><br><span class="line">        i_iter += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line">    <span class="comment"># ********** End **********#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第-5-关：手写数字识别"><a href="#第-5-关：手写数字识别" class="headerlink" title="第 5 关：手写数字识别"></a>第 5 关：手写数字识别</h2><h3 id="任务描述-4"><a href="#任务描述-4" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：使用<code>sklearn</code>中的<code>LogisticRegression</code>类完成手写数字识别任务。</p>
<h3 id="相关知识-4"><a href="#相关知识-4" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握如何使用<code>sklearn</code>提供的<code>LogisticRegression</code>类。</p>
<h3 id="数据简介"><a href="#数据简介" class="headerlink" title="数据简介"></a>数据简介</h3><p>本关使用的是手写数字数据集，该数据集有 1797 个样本，每个样本包括 8*8 像素（实际上是一条样本有 64 个特征，每个像素看成是一个特征，每个特征都是<code>float</code>类型的数值）的图像和一个 [0, 9] 整数的标签。比如下图的标签是 2 ：</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/294852" alt="example"></p>
<p><code>sklearn</code>为该数据集提供了接口，若想使用该数据集，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#加载数据集</span></span><br><span class="line">digits = datasets.load_digits()</span><br><span class="line"><span class="comment">#X表示图像数据，y表示标签</span></span><br><span class="line">X = digits.data</span><br><span class="line">y = digits.target</span><br><span class="line"><span class="comment">#将第233张手写数字可视化</span></span><br><span class="line">plt.imshow(digits.images[<span class="number">232</span>])</span><br></pre></td></tr></table></figure>

<h4 id="LogisticRegression"><a href="#LogisticRegression" class="headerlink" title="LogisticRegression"></a><code>LogisticRegression</code></h4><p><code>LogisticRegression</code>中默认实现了 OVR ，因此<code>LogisticRegression</code>可以实现多分类。<code>LogisticRegression</code>的构造函数中有三个常用的参数可以设置：</p>
<ul>
<li><code>solver</code>：<code>&#123;&#39;newton-cg&#39; ,  &#39;lbfgs&#39;,  &#39;liblinear&#39;,  &#39;sag&#39;,  &#39;saga&#39;&#125;</code>， 分别为几种优化算法。默认为<code>liblinear</code>；</li>
<li><code>C</code>：正则化系数的倒数，默认为 1.0 ，越小代表正则化越强；</li>
<li><code>max_iter</code>：最大训练轮数，默认为 100 。</li>
</ul>
<p>和<code>sklearn</code>中其他分类器一样，<code>LogisticRegression</code>类中的<code>fit</code>函数用于训练模型，<code>fit</code>函数有两个向量输入：</p>
<ul>
<li><code>X</code>：大小为 [样本数量,特征数量] 的<code>ndarray</code>，存放训练样本；</li>
<li><code>Y</code>：值为整型，大小为 [样本数量] 的<code>ndarray</code>，存放训练样本的分类标签。</li>
</ul>
<p><code>LogisticRegression</code>类中的<code>predict</code>函数用于预测，返回预测标签，<code>predict</code>函数有一个向量输入：</p>
<ul>
<li><code>X</code>：大小为[样本数量,特征数量]的<code>ndarray</code>，存放预测样本。</li>
</ul>
<p><code>LogisticRegression</code>的使用代码如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">logreg = LogisticRegression(<span class="attribute">solver</span>=<span class="string">&#x27;lbfgs&#x27;</span>,max_iter =10,<span class="attribute">C</span>=10)logreg.fit(X_train, Y_train)result = logreg.predict(X_test)</span><br></pre></td></tr></table></figure>

<h3 id="编程要求-4"><a href="#编程要求-4" class="headerlink" title="编程要求"></a>编程要求</h3><p>填写<code>digit_predict(train_sample, train_label, test_sample)</code>函数完成手写数字识别任务，其中：</p>
<ul>
<li><code>train_image</code>：训练集图像，类型为<code>ndarray</code>，<code>shape=[-1, 8, 8]</code>；</li>
<li><code>train_label</code>：训练集标签，类型为<code>ndarray</code>；</li>
<li><code>test_image</code>：测试集图像，类型为<code>ndarray</code>。</li>
</ul>
<h3 id="测试说明-4"><a href="#测试说明-4" class="headerlink" title="测试说明"></a>测试说明</h3><p>只需返回预测结果即可，程序内部会检测您的代码，预测正确率高于 0.97 视为过关。</p>
<h3 id="参考答案-4"><a href="#参考答案-4" class="headerlink" title="参考答案"></a>参考答案</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">digit_predict</span>(<span class="params">train_image, train_label, test_image</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        实现功能：训练模型并输出预测结果</span></span><br><span class="line"><span class="string">        :param train_sample: 包含多条训练样本的样本集，类型为ndarray,shape为[-1, 8, 8]</span></span><br><span class="line"><span class="string">        :param train_label: 包含多条训练样本标签的标签集，类型为ndarray</span></span><br><span class="line"><span class="string">        :param test_sample: 包含多条测试样本的测试集，类型为ndarry</span></span><br><span class="line"><span class="string">        :return: test_sample对应的预测标签</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># ************* Begin ************#</span></span><br><span class="line">    flat_train_image = train_image.reshape((-<span class="number">1</span>, <span class="number">64</span>))</span><br><span class="line">    <span class="comment"># 训练集标准化</span></span><br><span class="line">    train_min = flat_train_image.<span class="built_in">min</span>()</span><br><span class="line">    train_max = flat_train_image.<span class="built_in">max</span>()</span><br><span class="line">    flat_train_image = (flat_train_image - train_min) / (train_max - train_min)</span><br><span class="line">    <span class="comment"># 测试集变形</span></span><br><span class="line">    flat_test_image = test_image.reshape((-<span class="number">1</span>, <span class="number">64</span>))</span><br><span class="line">    <span class="comment"># 测试集标准化</span></span><br><span class="line">    test_min = flat_test_image.<span class="built_in">min</span>()</span><br><span class="line">    test_max = flat_test_image.<span class="built_in">max</span>()</span><br><span class="line">    flat_test_image = (flat_test_image - test_min) / (test_max - test_min)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练--预测</span></span><br><span class="line">    rf = LogisticRegression(C=<span class="number">4.0</span>)</span><br><span class="line">    rf.fit(flat_train_image, train_label)</span><br><span class="line">    <span class="keyword">return</span> rf.predict(flat_test_image)</span><br><span class="line">    <span class="comment"># ************* End **************#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Educoder</category>
        <category>ML</category>
      </categories>
      <tags>
        <tag>Educoder</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>头歌 - 机器学习 - 决策树</title>
    <url>//2023/05/04/educoder-ml-homework/</url>
    <content><![CDATA[<h1 id="【educoder】-机器学习-决策树"><a href="#【educoder】-机器学习-决策树" class="headerlink" title="【educoder】 机器学习 --- 决策树"></a>【educoder】 机器学习 --- 决策树</h1><h2 id="第-1-关：什么是决策树"><a href="#第-1-关：什么是决策树" class="headerlink" title="第 1 关：什么是决策树"></a>第 1 关：什么是决策树</h2><h4 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h4><p>本关任务：根据本节课所学知识完成本关所设置的选择题。</p>
<h4 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h4><p>为了完成本关任务，你需要掌握决策树的相关基础知识。</p>
<h5 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h5><p>在炎热的夏天，没有什么比冰镇后的西瓜更能令人感到心旷神怡的了。现在我要去水果店买西瓜，但什么样的西瓜能入我法眼呢？那根据我的个人习惯，在挑西瓜时可能就有这样的脑回路。</p>
<p><img src="https://data.educoder.net/api/attachments/283157" alt="img-1"></p>
<p>假设现在水果店里有<code>3</code>个西瓜，它们的属性如下：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>瓤是否够红</th>
<th>够不够冰</th>
<th>是否便宜</th>
<th>是否有籽</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>2</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>3</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
</tbody></table>
<p>那么根据我的脑回路我会买<code>1</code>和<code>2</code>号西瓜。</p>
<p>其实我的脑回路可以看成一棵树，并且这棵树能够帮助我对买不买西瓜这件事做决策，所以它就是一棵决策树。</p>
<h5 id="决策树的相关概念"><a href="#决策树的相关概念" class="headerlink" title="决策树的相关概念"></a>决策树的相关概念</h5><p>决策树是一种可以用于分类与回归的机器学习算法，但主要用于分类。用于分类的决策树是一种描述对实例进行分类的树形结构。决策树由结点和边组成，其中结点分为内部结点和叶子结点，内部结点表示一个特征或者属性，叶子结点表示标签（脑回路图中黄色的是内部结点，蓝色的是叶子结点）。</p>
<p>从代码角度来看，决策树其实可以看成是一堆<code>if-else</code>语句的集合，例如引例中的决策树完全可以看成是如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> isRed:</span><br><span class="line">    <span class="keyword">if</span> isCold:</span><br><span class="line">        <span class="keyword">if</span> hasSeed:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;buy&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;don&#x27;t buy&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> isCheap:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;buy&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;don&#x27;t buy&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;don&#x27;t buy&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>因此决策树的一个非常大的优势就是模型的可理解性非常高，甚至可以用来挖掘数据中比较重要的信息。</p>
<p>那么如何构造出一棵好的决策树呢？其实构造决策树时会遵循一个指标，有的是按照信息增益来构建，如 ID3 算法；有的是信息增益率来构建，如 C4.5 算法；有的是按照基尼系数来构建的，如 CART 算法。但不管是使用哪种构建算法，决策树的构建过程通常都是一个递归选择最优特征，并根据特征对训练集进行分割，使得对各个子数据集有一个最好的分类的过程。</p>
<p>这一过程对应着对特征空间的划分，也对应着决策树的构建。一开始，构建决策树的根结点，将所有训练数据都放在根结点。选择一个最优特征，并按照这一特征将训练数据集分割成子集，使得各个子集有一个在当前条件下最好的分类。如果这些子集已经能够被基本正确分类，那么构建叶子结点，并将这些子集分到所对应的叶结点中去；如果还有子集不能被基本正确分类，那么就对这些子集选择新的最优特征，继续对其进行分割，并构建相应的结点。如此递归进行下去，直至所有训练数据子集被基本正确分类，或者没有合适的特征为止。最后每个子集都被分到叶子结点上，即都有了明确的类别。这就构建出了一棵决策树。</p>
<h4 id="编程要求"><a href="#编程要求" class="headerlink" title="编程要求"></a>编程要求</h4><p>根据本关所学习到的知识，完成所有选择题。</p>
<h4 id="测试说明"><a href="#测试说明" class="headerlink" title="测试说明"></a>测试说明</h4><p>平台会对你的选项进行判断，如果实际输出结果与预期结果相同，则通关；反之，则 <code>GameOver</code>。</p>
<h4 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h4><ul>
<li><p>1、下列说法正确的是？</p>
<p>A、训练决策树的过程就是构建决策树的过程</p>
<p>B、ID3 算法是根据信息增益来构建决策树</p>
<p>C、C4.5 算法是根据基尼系数来构建决策树</p>
<p>D、决策树模型的可理解性不高</p>
</li>
<li><p>2、下列说法错误的是？</p>
<p>A、从树的根节点开始，根据特征的值一步一步走到叶子节点的过程是决策树做决策的过程</p>
<p>B、决策树只能是一棵二叉树</p>
<p>C、根节点所代表的特征是最优特征</p>
</li>
</ul>
<blockquote>
<ol>
<li>A B</li>
<li>B</li>
</ol>
</blockquote>
<h2 id="第-2-关：信息熵与信息增益"><a href="#第-2-关：信息熵与信息增益" class="headerlink" title="第 2 关：信息熵与信息增益"></a>第 2 关：信息熵与信息增益</h2><h4 id="任务描述-1"><a href="#任务描述-1" class="headerlink" title="任务描述"></a>任务描述</h4><p>本关任务：掌握什么是信息增益，完成计算信息增益的程序设计。</p>
<h4 id="相关知识-1"><a href="#相关知识-1" class="headerlink" title="相关知识"></a>相关知识</h4><p>为了完成本关任务，你需要掌握：</p>
<ul>
<li>信息熵；</li>
<li>条件熵；</li>
<li>信息增益。</li>
</ul>
<h5 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h5><p>信息是个很抽象的概念。人们常常说信息很多，或者信息较少，但却很难说清楚信息到底有多少。比如一本五十万字的中文书到底有多少信息量。</p>
<p>直到 1948 年，香农提出了“信息熵”的概念，才解决了对信息的量化度量问题。信息熵这个词是香农从热力学中借用过来的。热力学中的热熵是表示分子状态混乱程度的物理量。香农用信息熵的概念来描述信源的不确定度。信源的不确定性越大，信息熵也越大。</p>
<p>从机器学习的角度来看，信息熵表示的是信息量的期望值。如果数据集中的数据需要被分成多个类别，则信息量<code>I(xi)</code>的定义如下(其中<code>xi</code>表示多个类别中的第<code>i</code>个类别，<code>p(xi)</code>数据集中类别为<code>xi</code>的数据在数据集中出现的概率表示)：</p>
<p>$$<br>I(X_i)=−\log_{2}{p(x_i)} \tag{1}<br>$$</p>
<p>由于信息熵是信息量的期望值，所以信息熵<code>H(X)</code>的定义如下(其中<code>n</code>为数据集中类别的数量)：</p>
<p>$$<br>H(X)=−\sum_{i=1}^{n}p(x_i) \log_{2}{p(x_i)} \tag{2}<br>$$</p>
<p>从这个公式也可以看出，如果概率是<code>0</code>或者是<code>1</code>的时候，熵就是<code>0</code>（因为这种情况下随机变量的不确定性是最低的）。那如果概率是<code>0.5</code>，也就是五五开的时候，此时熵达到最大，也就是<code>1</code>。（就像扔硬币，你永远都猜不透你下次扔到的是正面还是反面，所以它的不确定性非常高）。所以呢，熵越大，不确定性就越高。</p>
<h5 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h5><p>在实际的场景中，我们可能需要研究数据集中某个特征等于某个值时的信息熵等于多少，这个时候就需要用到条件熵。条件熵<code>H(Y|X)</code>表示特征 X 为某个值的条件下，类别为 Y 的熵。条件熵的计算公式如下：</p>
<p>$$<br>H(Y|X)= \sum_{i=1}^{n}p_iH(Y|X=x_i) \tag{3}<br>$$</p>
<p>当然条件熵的性质也和熵的性质一样，概率越确定，条件熵就越小，概率越五五开，条件熵就越大。</p>
<h5 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h5><p>现在已经知道了什么是熵，什么是条件熵。接下来就可以看看什么是信息增益了。所谓的信息增益就是表示我已知条件<code>X</code>后能得到信息<code>Y</code>的不确定性的减少程度。</p>
<p>就好比，我在玩读心术。你心里想一件东西，我来猜。我已开始什么都没问你，我要猜的话，肯定是瞎猜。这个时候我的熵就非常高。然后我接下来我会去试着问你是非题，当我问了是非题之后，我就能减小猜测你心中想到的东西的范围，这样其实就是减小了我的熵。那么我熵的减小程度就是我的信息增益。</p>
<p>所以信息增益如果套上机器学习的话就是，如果把特征<code>A</code>对训练集<code>D</code>的信息增益记为<code>g(D, A)</code>的话，那么<code>g(D, A)</code>的计算公式就是：</p>
<p>$$<br> g(D,A)=H(D)-H(D,A) \tag{4}<br>$$</p>
<p>为了更好的解释熵，条件熵，信息增益的计算过程，下面通过示例来描述。假设我现在有这一个数据集，第一列是编号，第二列是性别，第三列是活跃度，第四列是客户是否流失的标签（<code>0</code>表示未流失，<code>1</code>表示流失）。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>性别</th>
<th>活跃度</th>
<th>是否流失</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>男</td>
<td>高</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>女</td>
<td>中</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>男</td>
<td>低</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>女</td>
<td>高</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>男</td>
<td>高</td>
<td>0</td>
</tr>
<tr>
<td>6</td>
<td>男</td>
<td>中</td>
<td>0</td>
</tr>
<tr>
<td>7</td>
<td>男</td>
<td>中</td>
<td>1</td>
</tr>
<tr>
<td>8</td>
<td>女</td>
<td>中</td>
<td>0</td>
</tr>
<tr>
<td>9</td>
<td>女</td>
<td>低</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>女</td>
<td>中</td>
<td>0</td>
</tr>
<tr>
<td>11</td>
<td>女</td>
<td>高</td>
<td>0</td>
</tr>
<tr>
<td>12</td>
<td>男</td>
<td>低</td>
<td>1</td>
</tr>
<tr>
<td>13</td>
<td>女</td>
<td>低</td>
<td>1</td>
</tr>
<tr>
<td>14</td>
<td>男</td>
<td>高</td>
<td>0</td>
</tr>
<tr>
<td>15</td>
<td>男</td>
<td>高</td>
<td>0</td>
</tr>
</tbody></table>
<p>假如要算性别和活跃度这两个特征的信息增益的话，首先要先算总的熵和条件熵。总的熵其实非常好算，就是把标签作为随机变量<code>X</code>。上表中标签只有两种（<code>0</code>和<code>1</code>）因此随机变量<code>X</code>的取值只有<code>0</code>或者<code>1</code>。所以要计算熵就需要先分别计算标签为<code>0</code>的概率和标签为<code>1</code>的概率。从表中能看出标签为<code>0</code>的数据有<code>10</code>条，所以标签为<code>0</code>的概率等于<code>2/3</code>。标签为<code>1</code>的概率为<code>1/3</code>。所以熵为：</p>
<p>$$<br>−(1/3)log(1/3)−(2/3)log(2/3)=0.9182<br>$$</p>
<p>接下来就是条件熵的计算，以性别为男的熵为例。表格中性别为男的数据有<code>8</code>条，这<code>8</code>条数据中有<code>3</code>条数据的标签为<code>1</code>，有<code>5</code>条数据的标签为<code>0</code>。所以根据条件熵的计算公式能够得出该条件熵为：</p>
<p>$$<br>−(3/8)log(3/8)−(5/8)log(5/8)=0.9543<br>$$</p>
<p>根据上述的计算方法可知，总熵为：</p>
<p>$$<br>−(5/15)log(5/15)−(10/15)log(10/15)=0.9182<br>$$</p>
<p>性别为男的熵为：</p>
<p>$$<br>−(3/8)log(3/8)−(5/8)log(5/8)=0.9543<br>$$</p>
<p>性别为女的熵为：</p>
<p>$$<br>−(2/7)log(2/7)−(5/7)log(5/7)=0.8631<br>$$</p>
<p>活跃度为低的熵为：</p>
<p>$$<br>−(4/4)log(4/4)−0=0<br>$$</p>
<p>活跃度为中的熵为：</p>
<p>$$<br>−(1/5)log(1/5)−(4/5)log(4/5)=0.7219<br>$$</p>
<p>活跃度为高的熵为：</p>
<p>$$<br>−0−(6/6)log(6/6)=0<br>$$</p>
<p>现在有了总的熵和条件熵之后就能算出性别和活跃度这两个特征的信息增益了。</p>
<p>性别的信息增益=总的熵-(8/15)*性别为男的熵-(7/15)*性别为女的熵=0.0064</p>
<p>活跃度的信息增益=总的熵-(6/15)*活跃度为高的熵-(5/15)<em>活跃度为中的熵-(4/15)\</em>活跃度为低的熵=0.6776</p>
<p>那信息增益算出来之后有什么意义呢？回到读心术的问题，为了我能更加准确的猜出你心中所想，我肯定是问的问题越好就能猜得越准！换句话来说我肯定是要想出一个信息增益最大（减少不确定性程度最高）的问题来问你。其实<code>ID3</code>算法也是这么想的。<code>ID3</code>算法的思想是从训练集<code>D</code>中计算每个特征的信息增益，然后看哪个最大就选哪个作为当前结点。然后继续重复刚刚的步骤来构建决策树。</p>
<h4 id="编程要求-1"><a href="#编程要求-1" class="headerlink" title="编程要求"></a>编程要求</h4><p>根据提示，在右侧编辑器补充代码，完成<code>calcInfoGain</code>函数实现计算信息增益。</p>
<p><code>calcInfoGain</code>函数中的参数:</p>
<ul>
<li><code>feature</code>：测试用例中字典里的<code>feature</code>，类型为<code>ndarray</code>；</li>
<li><code>label</code>：测试用例中字典里的<code>label</code>，类型为<code>ndarray</code>；</li>
<li><code>index</code>：测试用例中字典里的<code>index</code>，即<code>feature</code>部分特征列的索引。该索引指的是<code>feature</code>中第几个特征，如<code>index:0</code>表示使用第一个特征来计算信息增益。</li>
</ul>
<h4 id="测试说明-1"><a href="#测试说明-1" class="headerlink" title="测试说明"></a>测试说明</h4><p>平台会对你编写的代码进行测试，期望您的代码根据输入来输出正确的信息增益，以下为其中一个测试用例：</p>
<p>测试输入： <code>&#123;&#39;feature&#39;:[[0, 1], [1, 0], [1, 2], [0, 0], [1, 1]], &#39;label&#39;:[0, 1, 0, 0, 1], &#39;index&#39;: 0&#125;</code></p>
<p>预期输出： <code>0.419973</code></p>
<p>提示： 计算<code>log</code>可以使用<code>NumPy</code>中的<code>log2</code>函数</p>
<h4 id="参考答案-1"><a href="#参考答案-1" class="headerlink" title="参考答案"></a>参考答案</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calcInfoGain</span>(<span class="params">feature, label, index</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算信息增益</span></span><br><span class="line"><span class="string">        :param feature:测试用例中字典里的feature，类型为ndarray</span></span><br><span class="line"><span class="string">        :param label:测试用例中字典里的label，类型为ndarray</span></span><br><span class="line"><span class="string">        :param index:测试用例中字典里的index，即feature部分特征列的索引。该索引指的是feature中第几个特征，如index:0表示使用第一个特征来计算信息增益。</span></span><br><span class="line"><span class="string">        :return:信息增益，类型float</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算熵</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calcInfoEntropy</span>(<span class="params">feature, label</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            计算信息熵</span></span><br><span class="line"><span class="string">            :param feature:数据集中的特征，类型为ndarray</span></span><br><span class="line"><span class="string">            :param label:数据集中的标签，类型为ndarray</span></span><br><span class="line"><span class="string">            :return:信息熵，类型float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        label_set = <span class="built_in">set</span>(label)  <span class="comment"># 创建一个无序不重复的元素集</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 统计不同标签各自的数量（一般为0和1）</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> label_set:</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(label)):</span><br><span class="line">                <span class="keyword">if</span> label[j] == l:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 计算标签在数据集中出现的概率</span></span><br><span class="line">            p = count / <span class="built_in">len</span>(label)</span><br><span class="line">            <span class="comment"># 计算熵</span></span><br><span class="line">            result -= p * np.log2(p)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算条件熵</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calcHDA</span>(<span class="params">feature, label, index, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            计算信息熵</span></span><br><span class="line"><span class="string">            :param feature:数据集中的特征，类型为ndarray</span></span><br><span class="line"><span class="string">            :param label:数据集中的标签，类型为ndarray</span></span><br><span class="line"><span class="string">            :param index:需要使用的特征列索引，类型为int</span></span><br><span class="line"><span class="string">            :param value:index所表示的特征列中需要考察的特征值，类型为int</span></span><br><span class="line"><span class="string">            :return:信息熵，类型float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># sub_feature和sub_label表示根据特征列和特征值</span></span><br><span class="line">        <span class="comment"># 分割出的子数据集中的特征和标签</span></span><br><span class="line">        sub_feature = []</span><br><span class="line">        sub_label = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(feature)):</span><br><span class="line">            <span class="keyword">if</span> feature[i][index] == value:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                sub_feature.append(feature[i])</span><br><span class="line">                sub_label.append(label[i])</span><br><span class="line">        pHA = count / <span class="built_in">len</span>(feature)</span><br><span class="line">        e = calcInfoEntropy(sub_feature, sub_label)</span><br><span class="line">        <span class="keyword">return</span> pHA * e</span><br><span class="line"></span><br><span class="line">    <span class="comment">#######请计算信息增益############</span></span><br><span class="line">    <span class="comment"># *********** Begin ***********#</span></span><br><span class="line">    values = []  <span class="comment"># 定义一个列表存放index列，即特征列的所有特征</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(feature)):</span><br><span class="line">        values.append(feature[i][index])</span><br><span class="line">    values_list = <span class="built_in">set</span>(values)  <span class="comment"># 创建一个无序不重复的元素集</span></span><br><span class="line">    g = calcInfoEntropy(feature, label)  <span class="comment"># 计算总熵</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> values_list:</span><br><span class="line">        g -= calcHDA(feature, label, index, i)  <span class="comment"># 总熵-每个特征的条件熵</span></span><br><span class="line">    <span class="keyword">return</span> g  <span class="comment"># 得到信息增益</span></span><br><span class="line">    <span class="comment"># *********** End *************#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第-3-关：使用-ID3-算法构建决策树"><a href="#第-3-关：使用-ID3-算法构建决策树" class="headerlink" title="第 3 关：使用 ID3 算法构建决策树"></a>第 3 关：使用 ID3 算法构建决策树</h2><h4 id="任务描述-2"><a href="#任务描述-2" class="headerlink" title="任务描述"></a>任务描述</h4><p>本关任务：补充<code>python</code>代码，完成<code>DecisionTree</code>类中的<code>fit</code>和<code>predict</code>函数。</p>
<h4 id="相关知识-2"><a href="#相关知识-2" class="headerlink" title="相关知识"></a>相关知识</h4><p>为了完成本关任务，你需要掌握：</p>
<ul>
<li><code>ID3</code>算法构造决策树的流程；</li>
<li>如何使用构造好的决策树进行预测。</li>
</ul>
<h5 id="ID3-算法"><a href="#ID3-算法" class="headerlink" title="ID3 算法"></a>ID3 算法</h5><p><code>ID3</code>算法其实就是依据特征的信息增益来构建树的。其大致步骤就是从根结点开始，对结点计算所有可能的特征的信息增益，然后选择信息增益<strong>最大</strong>的特征作为结点的特征，由该特征的不同取值建立子结点，然后对子结点递归执行上述的步骤直到信息增益很小或者没有特征可以继续选择为止。</p>
<p>因此，<code>ID3</code>算法伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设数据集为D，标签集为A，需要构造的决策树为tree</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ID3</span>(<span class="params">D, A</span>):</span><br><span class="line">    <span class="keyword">if</span> D中所有的标签都相同:</span><br><span class="line">        <span class="keyword">return</span> 标签</span><br><span class="line">    <span class="keyword">if</span> 样本中只有一个特征或者所有样本的特征都一样:</span><br><span class="line">        对D中所有的标签进行计数</span><br><span class="line">        <span class="keyword">return</span> 计数最高的标签</span><br><span class="line"></span><br><span class="line">    计算所有特征的信息增益</span><br><span class="line">    选出增益最大的特征作为最佳特征(best_feature)</span><br><span class="line">    将best_feature作为tree的根结点</span><br><span class="line">    得到best_feature在数据集中所有出现过的值的集合(value_set)</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> value_set:</span><br><span class="line">        从D中筛选出best_feature = value的子数据集(sub_feature)</span><br><span class="line">        从A中筛选出best_feature = value的子标签集(sub_label)</span><br><span class="line">        <span class="comment"># 递归构造tree</span></span><br><span class="line">        tree[best_feature][value] = ID3(sub_feature, sub_label)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="使用决策树进行预测"><a href="#使用决策树进行预测" class="headerlink" title="使用决策树进行预测"></a>使用决策树进行预测</h5><p>决策树的预测思想非常简单，假设现在已经构建出了一棵用来决策是否买西瓜的决策树。</p>
<p><img src="https://data.educoder.net/api/attachments/283157" alt="img-2"></p>
<p>并假设现在在水果店里有这样一个西瓜，其属性如下：</p>
<table>
<thead>
<tr>
<th>瓤是否够红</th>
<th>够不够冰</th>
<th>是否便宜</th>
<th>是否有籽</th>
</tr>
</thead>
<tbody><tr>
<td>是</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
</tbody></table>
<p>那买不买这个西瓜呢？只需把西瓜的属性代入决策树即可。决策树的根结点是<code>瓤是否够红</code>，所以就看西瓜的属性，经查看发现够红，因此接下来就看<code>够不够冰</code>。而西瓜不够冰，那么看<code>是否便宜</code>。发现西瓜是便宜的，所以这个西瓜是可以买的。</p>
<p>因此使用决策树进行预测的伪代码也比较简单，伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#tree表示决策树，feature表示测试数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">tree, feature</span>):</span><br><span class="line">    <span class="keyword">if</span> tree是叶子结点:</span><br><span class="line">        <span class="keyword">return</span> tree</span><br><span class="line">    根据feature中的特征值走入tree中对应的分支</span><br><span class="line">    <span class="keyword">if</span> 分支依然是课树:</span><br><span class="line">        result = predict(分支, feature)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h4 id="编程要求-2"><a href="#编程要求-2" class="headerlink" title="编程要求"></a>编程要求</h4><p>填写<code>fit(self, feature, label)</code>函数，实现<code>ID3</code>算法，要求决策树保存在<code>self.tree</code>中。其中：</p>
<ul>
<li><code>feature</code>：训练集数据，类型为<code>ndarray</code>，数值全为整数；</li>
<li><code>label</code>：训练集标签，类型为<code>ndarray</code>，数值全为整数。</li>
</ul>
<p>填写<code>predict(self, feature)</code>函数，实现预测功能，并将标签返回，其中：</p>
<ul>
<li><code>feature</code>：测试集数据，类型为<code>ndarray</code>，数值全为整数。<strong>（PS：feature 中有多条数据）</strong></li>
</ul>
<h4 id="测试说明-2"><a href="#测试说明-2" class="headerlink" title="测试说明"></a>测试说明</h4><p>只需完成<code>fit</code>与<code>predict</code>函数即可，程序内部会调用您所完成的<code>fit</code>函数构建模型并调用<code>predict</code>函数来对数据进行预测。预测的准确率高于<code>0.92</code>视为过关。(PS:若<code>self.tree is None</code>则会打印<strong>决策树构建失败</strong>)</p>
<h4 id="参考答案-2"><a href="#参考答案-2" class="headerlink" title="参考答案"></a>参考答案</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecisionTree</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 决策树模型</span></span><br><span class="line">        self.tree = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calcInfoGain</span>(<span class="params">self, feature, label, index</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            计算信息增益</span></span><br><span class="line"><span class="string">            :param feature:测试用例中字典里的feature，类型为ndarray</span></span><br><span class="line"><span class="string">            :param label:测试用例中字典里的label，类型为ndarray</span></span><br><span class="line"><span class="string">            :param index:测试用例中字典里的index，即feature部分特征列的索引。该索引指的是feature中第几个特征，如index:0表示使用第一个特征来计算信息增益。</span></span><br><span class="line"><span class="string">            :return:信息增益，类型float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算熵</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">calcInfoEntropy</span>(<span class="params">label</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                计算信息熵</span></span><br><span class="line"><span class="string">                :param label:数据集中的标签，类型为ndarray</span></span><br><span class="line"><span class="string">                :return:信息熵，类型float</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            label_set = <span class="built_in">set</span>(label)</span><br><span class="line">            result = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> label_set:</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(label)):</span><br><span class="line">                    <span class="keyword">if</span> label[j] == l:</span><br><span class="line">                        count += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 计算标签在数据集中出现的概率</span></span><br><span class="line">                p = count / <span class="built_in">len</span>(label)</span><br><span class="line">                <span class="comment"># 计算熵</span></span><br><span class="line">                result -= p * np.log2(p)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算条件熵</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">calcHDA</span>(<span class="params">feature, label, index, value</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                计算信息熵</span></span><br><span class="line"><span class="string">                :param feature:数据集中的特征，类型为ndarray</span></span><br><span class="line"><span class="string">                :param label:数据集中的标签，类型为ndarray</span></span><br><span class="line"><span class="string">                :param index:需要使用的特征列索引，类型为int</span></span><br><span class="line"><span class="string">                :param value:index所表示的特征列中需要考察的特征值，类型为int</span></span><br><span class="line"><span class="string">                :return:信息熵，类型float</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="comment"># sub_feature和sub_label表示根据特征列和特征值分割出的子数据集中的特征和标签</span></span><br><span class="line">            sub_feature = []</span><br><span class="line">            sub_label = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(feature)):</span><br><span class="line">                <span class="keyword">if</span> feature[i][index] == value:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    sub_feature.append(feature[i])</span><br><span class="line">                    sub_label.append(label[i])</span><br><span class="line">            pHA = count / <span class="built_in">len</span>(feature)</span><br><span class="line">            e = calcInfoEntropy(sub_label)</span><br><span class="line">            <span class="keyword">return</span> pHA * e</span><br><span class="line"></span><br><span class="line">        base_e = calcInfoEntropy(label)  <span class="comment"># 信息熵</span></span><br><span class="line">        f = np.array(feature)</span><br><span class="line">        <span class="comment"># 得到指定特征列的值的集合</span></span><br><span class="line">        f_set = <span class="built_in">set</span>(f[:, index])</span><br><span class="line">        sum_HDA = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 计算条件熵</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> f_set:</span><br><span class="line">            sum_HDA += calcHDA(feature, label, index, value)</span><br><span class="line">        <span class="comment"># 计算信息增益</span></span><br><span class="line">        <span class="keyword">return</span> base_e - sum_HDA</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得信息增益最高的特征</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getBestFeature</span>(<span class="params">self, feature, label</span>):</span><br><span class="line">        max_infogain = <span class="number">0</span></span><br><span class="line">        best_feature = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 每一列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(feature[<span class="number">0</span>])):</span><br><span class="line">            infogain = self.calcInfoGain(feature, label, i)  <span class="comment"># 计算每一个特征的信息增益</span></span><br><span class="line">            <span class="keyword">if</span> infogain &gt; max_infogain:</span><br><span class="line">                max_infogain = infogain</span><br><span class="line">                best_feature = i</span><br><span class="line">        <span class="keyword">return</span> best_feature</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createTree</span>(<span class="params">self, feature, label</span>):</span><br><span class="line">        <span class="comment"># 1.所有的标签相同，样本里都是同一个label没必要继续分叉了</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(label)) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> label[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 2.样本中只有一个特征或者所有样本的特征都一样的话就看哪个label的票数高</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(feature[<span class="number">0</span>]) == <span class="number">1</span> <span class="keyword">or</span> <span class="built_in">len</span>(np.unique(feature, axis=<span class="number">0</span>)) == <span class="number">1</span>:</span><br><span class="line">            vote = &#123;&#125;</span><br><span class="line">            <span class="comment"># 为不同的label投票，计算数量最高的label</span></span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> label:</span><br><span class="line">                <span class="keyword">if</span> l <span class="keyword">in</span> vote.keys():</span><br><span class="line">                    vote[l] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    vote[l] = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 求vote中计数最高的label</span></span><br><span class="line">            max_count = <span class="number">0</span></span><br><span class="line">            vote_label = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> vote.items():</span><br><span class="line">                <span class="keyword">if</span> v &gt; max_count:</span><br><span class="line">                    max_count = v</span><br><span class="line">                    vote_label = k</span><br><span class="line">            <span class="keyword">return</span> vote_label</span><br><span class="line">        <span class="comment"># 3.第三种情况，根据信息增益拿到特征的索引</span></span><br><span class="line">        best_feature = self.getBestFeature(feature, label)</span><br><span class="line">        <span class="comment"># 创建树，根结点为信息增益最大的特征索引</span></span><br><span class="line">        tree = &#123;best_feature: &#123;&#125;&#125;</span><br><span class="line">        f = np.array(feature)</span><br><span class="line">        <span class="comment"># 拿到bestfeature的所有特征值</span></span><br><span class="line">        f_set = <span class="built_in">set</span>(f[:, best_feature])</span><br><span class="line">        <span class="comment"># 构建对应特征值的子样本集sub_feature, sub_label</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> f_set:</span><br><span class="line">            sub_feature = []</span><br><span class="line">            sub_label = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(feature)):</span><br><span class="line">                <span class="comment"># 在此特征的此样本条下构建子树</span></span><br><span class="line">                <span class="keyword">if</span> feature[i][best_feature] == v:</span><br><span class="line">                    sub_feature.append(feature[i])</span><br><span class="line">                    sub_label.append(label[i])</span><br><span class="line">            <span class="comment"># 递归构建决策树</span></span><br><span class="line">            tree[best_feature][v] = self.createTree(sub_feature, sub_label)</span><br><span class="line">        <span class="keyword">return</span> tree</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, feature, label</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            :param feature: 训练集数据，类型为ndarray</span></span><br><span class="line"><span class="string">            :param label:训练集标签，类型为ndarray</span></span><br><span class="line"><span class="string">            :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># ************* Begin ************#</span></span><br><span class="line">        self.tree = self.createTree(feature, label)</span><br><span class="line">        <span class="comment"># ************* End **************#</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, feature</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            :param feature:测试集数据，类型为ndarray</span></span><br><span class="line"><span class="string">            :return:预测结果，如np.array([0, 1, 2, 2, 1, 0])</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ************* Begin ************#</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">classify</span>(<span class="params">tree, feature</span>):</span><br><span class="line">            <span class="comment"># 如果tree是叶子结点，也就不是字典类型，返回结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(tree, <span class="built_in">dict</span>):</span><br><span class="line">                <span class="keyword">return</span> tree</span><br><span class="line">            <span class="comment"># tree.items()返回可遍历的(键, 值) 元组数组。</span></span><br><span class="line">            t_index, t_value = <span class="built_in">list</span>(tree.items())[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># t_index:树根特征对应feature的index,eg:feature[4,3,1,0]</span></span><br><span class="line">            f_value = feature[t_index]  <span class="comment"># 最优信息增益index对应的特征值</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(t_value, <span class="built_in">dict</span>):  <span class="comment"># 如果tree是叶子结点，继续分叉</span></span><br><span class="line">                value = classify(tree[t_index][f_value], feature)  <span class="comment"># 递归此结点后面的树</span></span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">            <span class="comment"># 最后一个，叶子结点，对应的为标签值</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> t_value</span><br><span class="line"></span><br><span class="line">        label = []</span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> feature:</span><br><span class="line">            <span class="comment"># 添加通过决策树模型找到的叶子结点</span></span><br><span class="line">            label.append(classify(self.tree, f))</span><br><span class="line">        <span class="keyword">return</span> np.array(label)</span><br><span class="line">        <span class="comment"># ************* End **************#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第-4-关：信息增益率"><a href="#第-4-关：信息增益率" class="headerlink" title="第 4 关：信息增益率"></a>第 4 关：信息增益率</h2><h4 id="任务描述-3"><a href="#任务描述-3" class="headerlink" title="任务描述"></a>任务描述</h4><p>本关任务：根据本关所学知识，完成<code>calcInfoGainRatio</code>函数。</p>
<h4 id="相关知识-3"><a href="#相关知识-3" class="headerlink" title="相关知识"></a>相关知识</h4><p>为了完成本关任务，你需要掌握：信息增益率</p>
<h5 id="信息增益率"><a href="#信息增益率" class="headerlink" title="信息增益率"></a>信息增益率</h5><p>由于在使用信息增益这一指标进行划分时，更喜欢可取值数量较多的特征。为了减少这种<strong>偏好</strong>可能带来的不利影响，<code>Ross Quinlan</code>使用了<strong>信息增益率</strong>这一指标来选择最优划分属性。</p>
<p>信息增益率的数学定义为如下，其中<em>D</em>表示数据集，<em>a</em>表示数据集中的某一列，<em>G<strong>a</strong>i**n</em>(<em>D</em>,<em>a</em>)表示<em>D</em>中<em>a</em>的信息增益，<em>V</em>表示<em>a</em>这一列中取值的集合，<em>v</em>表示<em>V</em>中的某种取值，∣<em>D</em>∣ 表示<em>D</em>中样本的数量，∣<em>D\</em>*v<em>∣ 表示</em>D<em>中</em>a<em>这一列中值等于</em>v*的数量。</p>
<p>$$<br>Gain_ratio(D,a)=\frac{Gain(D,a)}{-\sum_{v=1}^{V}\log_{2}{\frac{|D^v|}{|D|}}} \tag{5}<br>$$</p>
<p>从公式可以看出，信息增益率很好算，只是用信息增益除以另一个分母，该分母通常称为<strong>固有值</strong>。举个例子，还是使用<strong>第二关</strong>中提到过的数据集，第一列是编号，第二列是性别，第三列是活跃度，第四列是客户是否流失的标签（<code>0</code>表示未流失，<code>1</code>表示流失）。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>性别</th>
<th>活跃度</th>
<th>是否流失</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>男</td>
<td>高</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>女</td>
<td>中</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>男</td>
<td>低</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>女</td>
<td>高</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>男</td>
<td>高</td>
<td>0</td>
</tr>
<tr>
<td>6</td>
<td>男</td>
<td>中</td>
<td>0</td>
</tr>
<tr>
<td>7</td>
<td>男</td>
<td>中</td>
<td>1</td>
</tr>
<tr>
<td>8</td>
<td>女</td>
<td>中</td>
<td>0</td>
</tr>
<tr>
<td>9</td>
<td>女</td>
<td>低</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>女</td>
<td>中</td>
<td>0</td>
</tr>
<tr>
<td>11</td>
<td>女</td>
<td>高</td>
<td>0</td>
</tr>
<tr>
<td>12</td>
<td>男</td>
<td>低</td>
<td>1</td>
</tr>
<tr>
<td>13</td>
<td>女</td>
<td>低</td>
<td>1</td>
</tr>
<tr>
<td>14</td>
<td>男</td>
<td>高</td>
<td>0</td>
</tr>
<tr>
<td>15</td>
<td>男</td>
<td>高</td>
<td>0</td>
</tr>
</tbody></table>
<p>根据<strong>第二关</strong>已经知道性别的信息增益为 0.0064，设<em>a</em>为性别，则有<strong>Gain</strong>(<em>D</em>,<em>a</em>)=0.0064。由根据数据可知，<em>V</em>=2，假设当<em>v</em>=1 时表示性别为男，<em>v</em>=2 时表示性别为女，则有 ∣<em>D</em>∣=15，∣<em>D</em>1∣=8，∣<em>D</em>2∣=7。因此根据信息增益率的计算公式可知**$Gain_{ratio}$**(<em>D</em>,<em>a</em>)=0.0642。同理可以算出活跃度的信息增益率为 0.4328。</p>
<h4 id="编程要求-3"><a href="#编程要求-3" class="headerlink" title="编程要求"></a>编程要求</h4><p>根据提示，在右侧编辑器补充代码，完成<code>calcInfoGainRatio</code>函数实现计算信息增益。</p>
<p><code>calcInfoGainRatio</code>函数中的参数:</p>
<ul>
<li><code>feature</code>：测试用例中字典里的<code>feature</code>，类型为<code>ndarray</code>；</li>
<li><code>label</code>：测试用例中字典里的<code>label</code>，类型为<code>ndarray</code>；</li>
<li><code>index</code>：测试用例中字典里的<code>index</code>，即<code>feature</code>部分特征列的索引。该索引指的是<code>feature</code>中第几个特征，如<code>index:0</code>表示使用第一个特征来计算信息增益率。</li>
</ul>
<h4 id="测试说明-3"><a href="#测试说明-3" class="headerlink" title="测试说明"></a>测试说明</h4><p>平台会对你编写的代码进行测试，期望您的代码根据输入来输出正确的信息增益，以下为其中一个测试用例：</p>
<p>测试输入： <code>&#123;&#39;feature&#39;:[[0, 1], [1, 0], [1, 2], [0, 0], [1, 1]], &#39;label&#39;:[0, 1, 0, 0, 1], &#39;index&#39;: 0&#125;</code></p>
<p>预期输出： <code>0.432538</code></p>
<p>提示： 计算<code>log</code>可以使用<code>NumPy</code>中的<code>log2</code>函数</p>
<h4 id="参考答案-3"><a href="#参考答案-3" class="headerlink" title="参考答案"></a>参考答案</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calcInfoGain</span>(<span class="params">feature, label, index</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算信息增益</span></span><br><span class="line"><span class="string">        :param feature:测试用例中字典里的feature，类型为ndarray</span></span><br><span class="line"><span class="string">        :param label:测试用例中字典里的label，类型为ndarray</span></span><br><span class="line"><span class="string">        :param index:测试用例中字典里的index，即feature部分特征列的索引。该索引指的是feature中第几个特征，如index:0表示使用第一个特征来计算信息增益。</span></span><br><span class="line"><span class="string">        :return:信息增益，类型float</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算熵</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calcInfoEntropy</span>(<span class="params">label</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            计算信息熵</span></span><br><span class="line"><span class="string">            :param label:数据集中的标签，类型为ndarray</span></span><br><span class="line"><span class="string">            :return:信息熵，类型float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        label_set = <span class="built_in">set</span>(label)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> label_set:</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(label)):</span><br><span class="line">                <span class="keyword">if</span> label[j] == l:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 计算标签在数据集中出现的概率</span></span><br><span class="line">            p = count / <span class="built_in">len</span>(label)</span><br><span class="line">            <span class="comment"># 计算熵</span></span><br><span class="line">            result -= p * np.log2(p)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算条件熵</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calcHDA</span>(<span class="params">feature, label, index, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            计算信息熵</span></span><br><span class="line"><span class="string">            :param feature:数据集中的特征，类型为ndarray</span></span><br><span class="line"><span class="string">            :param label:数据集中的标签，类型为ndarray</span></span><br><span class="line"><span class="string">            :param index:需要使用的特征列索引，类型为int</span></span><br><span class="line"><span class="string">            :param value:index所表示的特征列中需要考察的特征值，类型为int</span></span><br><span class="line"><span class="string">            :return:信息熵，类型float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># sub_label表示根据特征列和特征值分割出的子数据集中的标签</span></span><br><span class="line">        sub_label = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(feature)):</span><br><span class="line">            <span class="keyword">if</span> feature[i][index] == value:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                sub_label.append(label[i])</span><br><span class="line">        pHA = count / <span class="built_in">len</span>(feature)</span><br><span class="line">        e = calcInfoEntropy(sub_label)</span><br><span class="line">        <span class="keyword">return</span> pHA * e</span><br><span class="line"></span><br><span class="line">    base_e = calcInfoEntropy(label)</span><br><span class="line">    f = np.array(feature)</span><br><span class="line">    <span class="comment"># 得到指定特征列的值的集合,:表示获取所有行</span></span><br><span class="line">    f_set = <span class="built_in">set</span>(f[:, index])  <span class="comment"># 将不重复的特征值获取出来（比如:男，女）</span></span><br><span class="line">    sum_HDA = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 计算条件熵</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> f_set:</span><br><span class="line">        sum_HDA += calcHDA(feature, label, index, value)</span><br><span class="line">    <span class="comment"># 计算信息增益</span></span><br><span class="line">    <span class="keyword">return</span> base_e - sum_HDA</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calcInfoGainRatio</span>(<span class="params">feature, label, index</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算信息增益率</span></span><br><span class="line"><span class="string">        :param feature:测试用例中字典里的feature，类型为ndarray</span></span><br><span class="line"><span class="string">        :param label:测试用例中字典里的label，类型为ndarray</span></span><br><span class="line"><span class="string">        :param index:测试用例中字典里的index，即feature部分特征列的索引。该索引指的是feature中第几个特征，如index:0表示使用第一个特征来计算信息增益。</span></span><br><span class="line"><span class="string">        :return:信息增益率，类型float</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ********* Begin *********#</span></span><br><span class="line">    up = calcInfoGain(feature, label, index)  <span class="comment"># 信息增益率的分子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义一个方法求分母中某个类型的个数(如求当v=1时表示性别为男的)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dcon</span>(<span class="params">feature, value</span>):</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(feature)):</span><br><span class="line">            <span class="keyword">if</span> feature[i][index] == value:</span><br><span class="line">                s += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    down = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 取出特征值该列所有数据</span></span><br><span class="line">    values = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(feature)):</span><br><span class="line">        values.append(feature[i][index])</span><br><span class="line">    values_set = <span class="built_in">set</span>(values)  <span class="comment"># 使用set()过滤重复值，得到特征值列中所有类型(如性别中男和女)</span></span><br><span class="line">    <span class="comment"># 循环递归求出分母</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> values_set:</span><br><span class="line">        down -= (dcon(feature, value) / <span class="built_in">len</span>(feature)) * np.log2(dcon(feature, value) / <span class="built_in">len</span>(feature))</span><br><span class="line">    <span class="comment"># 求得信息增益率</span></span><br><span class="line">    gain = up / down</span><br><span class="line">    <span class="keyword">return</span> gain</span><br><span class="line">    <span class="comment"># ********* End *********#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第-5-关：基尼系数"><a href="#第-5-关：基尼系数" class="headerlink" title="第 5 关：基尼系数"></a>第 5 关：基尼系数</h2><h4 id="任务描述-4"><a href="#任务描述-4" class="headerlink" title="任务描述"></a>任务描述</h4><p>本关任务：根据本关所学知识，完成<code>calcGini</code>函数。</p>
<h4 id="相关知识-4"><a href="#相关知识-4" class="headerlink" title="相关知识"></a>相关知识</h4><p>为了完成本关任务，你需要掌握：基尼系数。</p>
<h5 id="基尼系数"><a href="#基尼系数" class="headerlink" title="基尼系数"></a>基尼系数</h5><p>在<code>ID3</code>算法中我们使用了信息增益来选择特征，信息增益大的优先选择。在<code>C4.5</code>算法中，采用了信息增益率来选择特征，以减少信息增益容易选择特征值多的特征的问题。但是无论是<code>ID3</code>还是<code>C4.5</code>,都是基于信息论的熵模型的，这里面会涉及大量的对数运算。能不能简化模型同时也不至于完全丢失熵模型的优点呢？当然有！那就是<strong>基尼系数</strong>！</p>
<p><code>CART</code>算法使用<strong>基尼系数</strong>来代替信息增益率，基尼系数代表了模型的不纯度，基尼系数越小，则不纯度越低，特征越好。这和信息增益与信息增益率是相反的(它们都是越大越好)。</p>
<p>基尼系数的数学定义为如下，其中<em>D</em>表示数据集，<em>p\</em>*k*表示<code>D</code>中第<code>k</code>个类别在<code>D</code>中所占比例。</p>
<p>Gini(D)=1−sum\k=1∣y∣pk*2</p>
<p>从公式可以看出，相比于信息增益和信息增益率，计算起来更加简单。举个例子，还是使用<strong>第二关</strong>中提到过的数据集，第一列是编号，第二列是性别，第三列是活跃度，第四列是客户是否流失的标签（<code>0</code>表示未流失，<code>1</code>表示流失）。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>性别</th>
<th>活跃度</th>
<th>是否流失</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>男</td>
<td>高</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>女</td>
<td>中</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>男</td>
<td>低</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>女</td>
<td>高</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>男</td>
<td>高</td>
<td>0</td>
</tr>
<tr>
<td>6</td>
<td>男</td>
<td>中</td>
<td>0</td>
</tr>
<tr>
<td>7</td>
<td>男</td>
<td>中</td>
<td>1</td>
</tr>
<tr>
<td>8</td>
<td>女</td>
<td>中</td>
<td>0</td>
</tr>
<tr>
<td>9</td>
<td>女</td>
<td>低</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>女</td>
<td>中</td>
<td>0</td>
</tr>
<tr>
<td>11</td>
<td>女</td>
<td>高</td>
<td>0</td>
</tr>
<tr>
<td>12</td>
<td>男</td>
<td>低</td>
<td>1</td>
</tr>
<tr>
<td>13</td>
<td>女</td>
<td>低</td>
<td>1</td>
</tr>
<tr>
<td>14</td>
<td>男</td>
<td>高</td>
<td>0</td>
</tr>
<tr>
<td>15</td>
<td>男</td>
<td>高</td>
<td>0</td>
</tr>
</tbody></table>
<p>从表格可以看出，<em>D</em>中总共有 2 个类别，设类别为 0 的比例为<em>p</em>1，则有<em>p</em>1=1510。设类别为 1 的比例为<em>p</em>2，则有<em>p</em>2=155。根据基尼系数的公式可知<em>G<strong>i</strong>n\</em>*i*(<em>D</em>)=1−(<em>p</em>12+<em>p</em>22)=0.4444。</p>
<p>上面是基于数据集<code>D</code>的基尼系数的计算方法，那么基于数据集<code>D</code>与特征<code>a</code>的基尼系数怎样计算呢？其实和信息增益率的套路差不多。计算公式如下：</p>
<p>$$ Gini(D,a)=\sum_{v=1}^{V}\frac{|D^v|}{|D|}Gini(D^v) \tag6 $$</p>
<p>还是以用户流失的数据为例，现在算一算性别的基尼系数。设性别男为<em>v</em>=1，性别女为<em>v</em>=2 则有 ∣<em>D</em>∣=15，∣<em>D</em>1∣=8，∣<em>D</em>2∣=7，<em>G<strong>i</strong>n**i</em>(<em>D</em>1)=0.46875，<em>G<strong>i</strong>n**i</em>(<em>D</em>2)=0.40816。所以<em>G<strong>i</strong>n\</em>*i*(<em>D</em>,<em>a</em>)=0.44048。</p>
<h4 id="编程要求-4"><a href="#编程要求-4" class="headerlink" title="编程要求"></a>编程要求</h4><p>根据提示，在右侧编辑器补充代码，完成<code>calcGini</code>函数实现计算信息增益。</p>
<p><code>calcGini</code>函数中的参数:</p>
<ul>
<li><code>feature</code>：测试用例中字典里的<code>feature</code>，类型为<code>ndarray</code>；</li>
<li><code>label</code>：测试用例中字典里的<code>label</code>，类型为<code>ndarray</code>；</li>
<li><code>index</code>：测试用例中字典里的<code>index</code>，即<code>feature</code>部分特征列的索引。该索引指的是<code>feature</code>中第几个特征，如<code>index:0</code>表示使用第一个特征来计算基尼系数。</li>
</ul>
<h4 id="测试说明-4"><a href="#测试说明-4" class="headerlink" title="测试说明"></a>测试说明</h4><p>平台会对你编写的代码进行测试，期望您的代码根据输入来输出正确的信息增益，以下为其中一个测试用例：</p>
<p>测试输入： <code>&#123;&#39;feature&#39;:[[0, 1], [1, 0], [1, 2], [0, 0], [1, 1]], &#39;label&#39;:[0, 1, 0, 0, 1], &#39;index&#39;: 0&#125;</code></p>
<p>预期输出： <code>0.266667</code></p>
<h4 id="参考答案-4"><a href="#参考答案-4" class="headerlink" title="参考答案"></a>参考答案</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calcGini</span>(<span class="params">feature, label, index</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算基尼系数</span></span><br><span class="line"><span class="string">        :param feature:测试用例中字典里的feature，类型为ndarray</span></span><br><span class="line"><span class="string">        :param label:测试用例中字典里的label，类型为ndarray</span></span><br><span class="line"><span class="string">        :param index:测试用例中字典里的index，即feature部分特征列的索引。该索引指的是feature中第几个特征，如index:0表示使用第一个特征来计算信息增益。</span></span><br><span class="line"><span class="string">        :return:基尼系数，类型float</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ********* Begin *********#</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_gini</span>(<span class="params">label</span>):</span><br><span class="line">        unique_label = <span class="built_in">list</span>(<span class="built_in">set</span>(label))</span><br><span class="line">        gini = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> unique_label:</span><br><span class="line">            p = np.<span class="built_in">sum</span>(label == l) / <span class="built_in">len</span>(label)</span><br><span class="line">            gini -= p ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> gini</span><br><span class="line"></span><br><span class="line">    unique_value = <span class="built_in">list</span>(<span class="built_in">set</span>(feature[:, index]))</span><br><span class="line">    gini = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> unique_value:</span><br><span class="line">        len_v = np.<span class="built_in">sum</span>(feature[:, index] == value)</span><br><span class="line">        gini += (len_v / <span class="built_in">len</span>(feature)) * _gini(label[feature[:, index] == value])</span><br><span class="line">    <span class="keyword">return</span> gini</span><br><span class="line">    <span class="comment"># ********* End *********#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第-6-关：预剪枝与后剪枝"><a href="#第-6-关：预剪枝与后剪枝" class="headerlink" title="第 6 关：预剪枝与后剪枝"></a>第 6 关：预剪枝与后剪枝</h2><h4 id="任务描述-5"><a href="#任务描述-5" class="headerlink" title="任务描述"></a>任务描述</h4><p>本关任务：补充<code>python</code>代码，完成<code>DecisionTree</code>类中的<code>fit</code>和<code>predict</code>函数。</p>
<h4 id="相关知识-5"><a href="#相关知识-5" class="headerlink" title="相关知识"></a>相关知识</h4><p>为了完成本关任务，你需要掌握：</p>
<ul>
<li>为什么需要剪枝；</li>
<li>预剪枝；</li>
<li>后剪枝。</li>
</ul>
<h5 id="为什么需要剪枝"><a href="#为什么需要剪枝" class="headerlink" title="为什么需要剪枝"></a>为什么需要剪枝</h5><p>决策树的生成是递归地去构建决策树，直到不能继续下去为止。这样产生的树往往对训练数据有很高的分类准确率，但对未知的测试数据进行预测就没有那么准确了，也就是所谓的过拟合。</p>
<p>决策树容易过拟合的原因是在构建决策树的过程时会过多地考虑如何提高对训练集中的数据的分类准确率，从而会构建出非常复杂的决策树（树的宽度和深度都比较大）。在之前的实训中已经提到过，<strong>模型的复杂度越高，模型就越容易出现过拟合的现象。</strong>所以简化决策树的复杂度能够有效地缓解过拟合现象，而简化决策树最常用的方法就是剪枝。剪枝分为预剪枝与后剪枝。</p>
<h5 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h5><p>预剪枝的核心思想是在决策树生成过程中，对每个结点在划分前先进行一个评估，若当前结点的划分不能带来决策树泛化性能提升，则停止划分并将当前结点标记为叶结点。</p>
<p>想要评估决策树算法的泛化性能如何，方法很简单。可以将训练数据集中随机取出一部分作为验证数据集，然后在用训练数据集对每个结点进行划分之前用当前状态的决策树计算出在验证数据集上的正确率。正确率越高说明决策树的泛化性能越好，如果在划分结点的时候发现泛化性能有所下降或者没有提升时，说明应该停止划分，并用投票计数的方式将当前结点标记成叶子结点。</p>
<p>举个例子，假如上一关中所提到的用来决定是否买西瓜的决策树模型已经出现过拟合的情况，模型如下：</p>
<p><img src="https://data.educoder.net/api/attachments/283157" alt="img-3"></p>
<p>假设当模型在划分<code>是否便宜</code>这个结点前，模型在验证数据集上的正确率为<code>0.81</code>。但在划分后，模型在验证数据集上的正确率降为<code>0.67</code>。此时就不应该划分<code>是否便宜</code>这个结点。所以预剪枝后的模型如下：</p>
<p><img src="https://data.educoder.net/api/attachments/283551" alt="img-4"></p>
<p>从上图可以看出，<strong>预剪枝能够降低决策树的复杂度。这种预剪枝处理属于贪心思想，但是贪心有一定的缺陷，就是可能当前划分会降低泛化性能，但在其基础上进行的后续划分却有可能导致性能显著提高。所以有可能会导致决策树出现欠拟合的情况。</strong></p>
<h5 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h5><p>后剪枝是先从训练集生成一棵完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能够带来决策树泛化性能提升，则将该子树替换为叶结点。</p>
<p>后剪枝的思路很直接，对于决策树中的每一个非叶子结点的子树，我们尝试着把它替换成一个叶子结点，该叶子结点的类别我们用子树所覆盖训练样本中存在最多的那个类来代替，这样就产生了一个简化决策树，然后比较这两个决策树在测试数据集中的表现，如果简化决策树在验证数据集中的准确率有所提高，那么该子树就可以替换成叶子结点。该算法以<code>bottom-up</code>的方式遍历所有的子树，直至没有任何子树可以替换使得测试数据集的表现得以改进时，算法就可以终止。</p>
<p>从后剪枝的流程可以看出，后剪枝是从全局的角度来看待要不要剪枝，所以造成欠拟合现象的可能性比较小。但由于后剪枝需要先生成完整的决策树，然后再剪枝，所以后剪枝的训练时间开销更高。</p>
<h4 id="编程要求-5"><a href="#编程要求-5" class="headerlink" title="编程要求"></a>编程要求</h4><p>填写<code>fit(self, train_feature, train_label, val_featrue, val_label)</code>函数，实现带<strong>后剪枝</strong>的<code>ID3</code>算法，要求决策树保存在<code>self.tree</code>中。其中：</p>
<ul>
<li><code>train_feature</code>：训练集数据，类型为<code>ndarray</code>，数值全为整数；</li>
<li><code>train_label</code>：训练集标签，类型为<code>ndarray</code>，数值全为整数；</li>
<li><code>val_feature</code>：验证集数据，类型为<code>ndarray</code>，数值全为整数；</li>
<li><code>val_label</code>：验证集标签，类型为<code>ndarray</code>，数值全为整数。</li>
</ul>
<p>填写<code>predict(self, feature)</code>函数，实现预测功能，并将标签返回，其中：</p>
<ul>
<li><code>feature</code>：测试集数据，类型为<code>ndarray</code>，数值全为整数。<strong>（PS：feature 中有多条数据）</strong></li>
</ul>
<h4 id="测试说明-5"><a href="#测试说明-5" class="headerlink" title="测试说明"></a>测试说明</h4><p>只需完成<code>fit</code>与<code>predict</code>函数即可，程序内部会调用您所完成的<code>fit</code>函数构建模型并调用<code>predict</code>函数来对数据进行预测。预测的准确率高于<code>0.935</code>视为过关。(PS:若<code>self.tree is None</code>则会打印<strong>决策树构建失败</strong>)</p>
<h4 id="参考答案-5"><a href="#参考答案-5" class="headerlink" title="参考答案"></a>参考答案</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecisionTree</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 决策树模型</span></span><br><span class="line">        self.tree = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calcInfoGain</span>(<span class="params">self, feature, label, index</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            计算信息增益</span></span><br><span class="line"><span class="string">            :param feature:测试用例中字典里的feature，类型为ndarray</span></span><br><span class="line"><span class="string">            :param label:测试用例中字典里的label，类型为ndarray</span></span><br><span class="line"><span class="string">            :param index:测试用例中字典里的index，即feature部分特征列的索引。该索引指的是feature中第几个特征，如index:0表示使用第一个特征来计算信息增益。</span></span><br><span class="line"><span class="string">            :return:信息增益，类型float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算熵</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">calcInfoEntropy</span>(<span class="params">feature, label</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                计算信息熵</span></span><br><span class="line"><span class="string">                :param feature:数据集中的特征，类型为ndarray</span></span><br><span class="line"><span class="string">                :param label:数据集中的标签，类型为ndarray</span></span><br><span class="line"><span class="string">                :return:信息熵，类型float</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">            label_set = <span class="built_in">set</span>(label)</span><br><span class="line">            result = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> label_set:</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(label)):</span><br><span class="line">                    <span class="keyword">if</span> label[j] == l:</span><br><span class="line">                        count += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 计算标签在数据集中出现的概率</span></span><br><span class="line">                p = count / <span class="built_in">len</span>(label)</span><br><span class="line">                <span class="comment"># 计算熵</span></span><br><span class="line">                result -= p * np.log2(p)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算条件熵</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">calcHDA</span>(<span class="params">feature, label, index, value</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                计算信息熵</span></span><br><span class="line"><span class="string">                :param feature:数据集中的特征，类型为ndarray</span></span><br><span class="line"><span class="string">                :param label:数据集中的标签，类型为ndarray</span></span><br><span class="line"><span class="string">                :param index:需要使用的特征列索引，类型为int</span></span><br><span class="line"><span class="string">                :param value:index所表示的特征列中需要考察的特征值，类型为int</span></span><br><span class="line"><span class="string">                :return:信息熵，类型float</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="comment"># sub_feature和sub_label表示根据特征列和特征值分割出的子数据集中的特征和标签</span></span><br><span class="line">            sub_feature = []</span><br><span class="line">            sub_label = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(feature)):</span><br><span class="line">                <span class="keyword">if</span> feature[i][index] == value:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    sub_feature.append(feature[i])</span><br><span class="line">                    sub_label.append(label[i])</span><br><span class="line">            pHA = count / <span class="built_in">len</span>(feature)</span><br><span class="line">            e = calcInfoEntropy(sub_feature, sub_label)</span><br><span class="line">            <span class="keyword">return</span> pHA * e</span><br><span class="line"></span><br><span class="line">        base_e = calcInfoEntropy(feature, label)</span><br><span class="line">        f = np.array(feature)</span><br><span class="line">        <span class="comment"># 得到指定特征列的值的集合</span></span><br><span class="line">        f_set = <span class="built_in">set</span>(f[:, index])</span><br><span class="line">        sum_HDA = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 计算条件熵</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> f_set:</span><br><span class="line">            sum_HDA += calcHDA(feature, label, index, value)</span><br><span class="line">        <span class="comment"># 计算信息增益</span></span><br><span class="line">        <span class="keyword">return</span> base_e - sum_HDA</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得信息增益最高的特征</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getBestFeature</span>(<span class="params">self, feature, label</span>):</span><br><span class="line">        max_infogain = <span class="number">0</span></span><br><span class="line">        best_feature = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(feature[<span class="number">0</span>])):</span><br><span class="line">            infogain = self.calcInfoGain(feature, label, i)</span><br><span class="line">            <span class="keyword">if</span> infogain &gt; max_infogain:</span><br><span class="line">                max_infogain = infogain</span><br><span class="line">                best_feature = i</span><br><span class="line">        <span class="keyword">return</span> best_feature</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算验证集准确率</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calc_acc_val</span>(<span class="params">self, the_tree, val_feature, val_label</span>):</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">classify</span>(<span class="params">tree, feature</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(tree, <span class="built_in">dict</span>):</span><br><span class="line">                <span class="keyword">return</span> tree</span><br><span class="line">            t_index, t_value = <span class="built_in">list</span>(tree.items())[<span class="number">0</span>]</span><br><span class="line">            f_value = feature[t_index]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(t_value, <span class="built_in">dict</span>):</span><br><span class="line">                classLabel = classify(tree[t_index][f_value], feature)</span><br><span class="line">                <span class="keyword">return</span> classLabel</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> t_value</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> val_feature:</span><br><span class="line">            result.append(classify(the_tree, f))</span><br><span class="line"></span><br><span class="line">        result = np.array(result)</span><br><span class="line">        <span class="keyword">return</span> np.mean(result == val_label)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createTree</span>(<span class="params">self, train_feature, train_label</span>):</span><br><span class="line">        <span class="comment"># 样本里都是同一个label没必要继续分叉了</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(train_label)) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> train_label[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 样本中只有一个特征或者所有样本的特征都一样的话就看哪个label的票数高</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(train_feature[<span class="number">0</span>]) == <span class="number">1</span> <span class="keyword">or</span> <span class="built_in">len</span>(np.unique(train_feature, axis=<span class="number">0</span>)) == <span class="number">1</span>:</span><br><span class="line">            vote = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> train_label:</span><br><span class="line">                <span class="keyword">if</span> l <span class="keyword">in</span> vote.keys():</span><br><span class="line">                    vote[l] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    vote[l] = <span class="number">1</span></span><br><span class="line">            max_count = <span class="number">0</span></span><br><span class="line">            vote_label = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> vote.items():</span><br><span class="line">                <span class="keyword">if</span> v &gt; max_count:</span><br><span class="line">                    max_count = v</span><br><span class="line">                    vote_label = k</span><br><span class="line">            <span class="keyword">return</span> vote_label</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据信息增益拿到特征的索引</span></span><br><span class="line">        best_feature = self.getBestFeature(train_feature, train_label)</span><br><span class="line">        tree = &#123;best_feature: &#123;&#125;&#125;</span><br><span class="line">        f = np.array(train_feature)</span><br><span class="line">        <span class="comment"># 拿到bestfeature的所有特征值</span></span><br><span class="line">        f_set = <span class="built_in">set</span>(f[:, best_feature])</span><br><span class="line">        <span class="comment"># 构建对应特征值的子样本集sub_feature, sub_label</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> f_set:</span><br><span class="line">            sub_feature = []</span><br><span class="line">            sub_label = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(train_feature)):</span><br><span class="line">                <span class="keyword">if</span> train_feature[i][best_feature] == v:</span><br><span class="line">                    sub_feature.append(train_feature[i])</span><br><span class="line">                    sub_label.append(train_label[i])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归构建决策树</span></span><br><span class="line">            tree[best_feature][v] = self.createTree(sub_feature, sub_label)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tree</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 后剪枝</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post_cut</span>(<span class="params">self, val_feature, val_label</span>):</span><br><span class="line">        <span class="comment"># 拿到非叶子节点的数量</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_non_leaf_node_count</span>(<span class="params">tree</span>):</span><br><span class="line">            non_leaf_node_path = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">tree, path, all_path</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> tree.keys():</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">isinstance</span>(tree[k], <span class="built_in">dict</span>):</span><br><span class="line">                        path.append(k)</span><br><span class="line">                        dfs(tree[k], path, all_path)</span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; <span class="number">0</span>:</span><br><span class="line">                            path.pop()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        all_path.append(path[:])</span><br><span class="line"></span><br><span class="line">            dfs(tree, [], non_leaf_node_path)</span><br><span class="line"></span><br><span class="line">            unique_non_leaf_node = []</span><br><span class="line">            <span class="keyword">for</span> path <span class="keyword">in</span> non_leaf_node_path:</span><br><span class="line">                isFind = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">for</span> p <span class="keyword">in</span> unique_non_leaf_node:</span><br><span class="line">                    <span class="keyword">if</span> path == p:</span><br><span class="line">                        isFind = <span class="literal">True</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> isFind:</span><br><span class="line">                    unique_non_leaf_node.append(path)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(unique_non_leaf_node)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 拿到树中深度最深的从根节点到非叶子节点的路径</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_the_most_deep_path</span>(<span class="params">tree</span>):</span><br><span class="line">            non_leaf_node_path = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">tree, path, all_path</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> tree.keys():</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">isinstance</span>(tree[k], <span class="built_in">dict</span>):</span><br><span class="line">                        path.append(k)</span><br><span class="line">                        dfs(tree[k], path, all_path)</span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; <span class="number">0</span>:</span><br><span class="line">                            path.pop()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        all_path.append(path[:])</span><br><span class="line"></span><br><span class="line">            dfs(tree, [], non_leaf_node_path)</span><br><span class="line"></span><br><span class="line">            max_depth = <span class="number">0</span></span><br><span class="line">            result = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> path <span class="keyword">in</span> non_leaf_node_path:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; max_depth:</span><br><span class="line">                    max_depth = <span class="built_in">len</span>(path)</span><br><span class="line">                    result = path</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 剪枝</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">set_vote_label</span>(<span class="params">tree, path, label</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(path) - <span class="number">1</span>):</span><br><span class="line">                tree = tree[path[i]]</span><br><span class="line">            tree[path[<span class="built_in">len</span>(path) - <span class="number">1</span>]] = vote_label</span><br><span class="line"></span><br><span class="line">        acc_before_cut = self.calc_acc_val(self.tree, val_feature, val_label)</span><br><span class="line">        <span class="comment"># 遍历所有非叶子节点</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(get_non_leaf_node_count(self.tree)):</span><br><span class="line">            path = get_the_most_deep_path(self.tree)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 备份树</span></span><br><span class="line">            tree = deepcopy(self.tree)</span><br><span class="line">            step = deepcopy(tree)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 跟着路径走</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> path:</span><br><span class="line">                step = step[k]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 叶子节点中票数最多的标签</span></span><br><span class="line">            vote_label = <span class="built_in">sorted</span>(step.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse=<span class="literal">True</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 在备份的树上剪枝</span></span><br><span class="line">            set_vote_label(tree, path, vote_label)</span><br><span class="line"></span><br><span class="line">            acc_after_cut = self.calc_acc_val(tree, val_feature, val_label)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 验证集准确率高于0.9才剪枝</span></span><br><span class="line">            <span class="keyword">if</span> acc_after_cut &gt; acc_before_cut:</span><br><span class="line">                set_vote_label(self.tree, path, vote_label)</span><br><span class="line">                acc_before_cut = acc_after_cut</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, train_feature, train_label, val_feature, val_label</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            :param train_feature:训练集数据，类型为ndarray</span></span><br><span class="line"><span class="string">            :param train_label:训练集标签，类型为ndarray</span></span><br><span class="line"><span class="string">            :param val_feature:验证集数据，类型为ndarray</span></span><br><span class="line"><span class="string">            :param val_label:验证集标签，类型为ndarray</span></span><br><span class="line"><span class="string">            :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ************* Begin ************#</span></span><br><span class="line">        self.tree = self.createTree(train_feature, train_label)</span><br><span class="line">        <span class="comment"># 后剪枝</span></span><br><span class="line">        self.post_cut(val_feature, val_label)</span><br><span class="line">        <span class="comment"># ************* End **************#</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, feature</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            :param feature:测试集数据，类型为ndarray</span></span><br><span class="line"><span class="string">            :return:预测结果，如np.array([0, 1, 2, 2, 1, 0])</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ************* Begin ************#</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 单个样本分类</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">classify</span>(<span class="params">tree, feature</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(tree, <span class="built_in">dict</span>):</span><br><span class="line">                <span class="keyword">return</span> tree</span><br><span class="line">            t_index, t_value = <span class="built_in">list</span>(tree.items())[<span class="number">0</span>]</span><br><span class="line">            f_value = feature[t_index]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(t_value, <span class="built_in">dict</span>):</span><br><span class="line">                classLabel = classify(tree[t_index][f_value], feature)</span><br><span class="line">                <span class="keyword">return</span> classLabel</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> t_value</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> feature:</span><br><span class="line">            result.append(classify(self.tree, f))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> np.array(result)</span><br><span class="line">        <span class="comment"># ************* End **************#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第-7-关：鸢尾花识别"><a href="#第-7-关：鸢尾花识别" class="headerlink" title="第 7 关：鸢尾花识别"></a>第 7 关：鸢尾花识别</h2><h4 id="任务描述-6"><a href="#任务描述-6" class="headerlink" title="任务描述"></a>任务描述</h4><p>本关任务：使用<code>sklearn</code>完成鸢尾花分类任务。</p>
<h4 id="相关知识-6"><a href="#相关知识-6" class="headerlink" title="相关知识"></a>相关知识</h4><p>为了完成本关任务，你需要掌握如何使用<code>sklearn</code>提供的<code>DecisionTreeClassifier</code>。</p>
<h5 id="数据简介"><a href="#数据简介" class="headerlink" title="数据简介"></a>数据简介</h5><p><img src="https://data.educoder.net/api/attachments/283552" alt="img-6"></p>
<p>鸢尾花数据集是一类多重变量分析的数据集。通过花萼长度，花萼宽度，花瓣长度，花瓣宽度<code>4</code>个属性预测鸢尾花卉属于(<code>Setosa</code>，<code>Versicolour</code>，<code>Virginica</code>)三个种类中的哪一类(其中分别用<code>0</code>，<code>1</code>，<code>2</code>代替)。</p>
<p>数据集中部分数据与标签如下图所示：</p>
<p><img src="https://data.educoder.net/api/attachments/317817" alt="img-7"></p>
<p><img src="https://data.educoder.net/api/attachments/317819" alt="img-7"></p>
<h5 id="DecisionTreeClassifier"><a href="#DecisionTreeClassifier" class="headerlink" title="DecisionTreeClassifier"></a>DecisionTreeClassifier</h5><p><code>DecisionTreeClassifier</code>的构造函数中有两个常用的参数可以设置：</p>
<ul>
<li><code>criterion</code>:划分节点时用到的指标。有<code>gini</code>（<strong>基尼系数</strong>）,<code>entropy</code>(<strong>信息增益</strong>)。若不设置，默认为<code>gini</code></li>
<li><code>max_depth</code>:决策树的最大深度，如果发现模型已经出现过拟合，可以尝试将该参数调小。若不设置，默认为<code>None</code></li>
</ul>
<p>和<code>sklearn</code>中其他分类器一样，<code>DecisionTreeClassifier</code>类中的<code>fit</code>函数用于训练模型，<code>fit</code>函数有两个向量输入：</p>
<ul>
<li><code>X</code>：大小为<code>[样本数量,特征数量]</code>的<code>ndarray</code>，存放训练样本；</li>
<li><code>Y</code>：值为整型，大小为<code>[样本数量]</code>的<code>ndarray</code>，存放训练样本的分类标签。</li>
</ul>
<p><code>DecisionTreeClassifier</code>类中的<code>predict</code>函数用于预测，返回预测标签，<code>predict</code>函数有一个向量输入：</p>
<ul>
<li><code>X</code>：大小为<code>[样本数量,特征数量]</code>的<code>ndarray</code>，存放预测样本。</li>
</ul>
<p><code>DecisionTreeClassifier</code>的使用代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">clf = tree.DecisionTreeClassifier()</span><br><span class="line">clf.fit(X_train, Y_train)</span><br><span class="line">result = clf.predict(X_test)</span><br></pre></td></tr></table></figure>

<p>数据文件格式如下图所示:</p>
<p><img src="https://data.educoder.net/api/attachments/317828" alt="img-8"></p>
<p>标签文件格式如下图所示:</p>
<p><img src="https://data.educoder.net/api/attachments/317829" alt="img-9"></p>
<p><strong>PS：<code>predict.csv</code>文件的格式必须与标签文件格式一致。</strong></p>
<h4 id="测试说明-6"><a href="#测试说明-6" class="headerlink" title="测试说明"></a>测试说明</h4><p>只需将结果保存至<code>./step7/predict.csv</code>即可，程序内部会检测您的代码，预测准确率高于<code>0.95</code>视为过关。</p>
<h4 id="参考答案-6"><a href="#参考答案-6" class="headerlink" title="参考答案"></a>参考答案</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ********* Begin *********#</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line">train_df = pd.read_csv(<span class="string">&#x27;./step7/train_data.csv&#x27;</span>).as_matrix()</span><br><span class="line">train_label = pd.read_csv(<span class="string">&#x27;./step7/train_label.csv&#x27;</span>).as_matrix()</span><br><span class="line">test_df = pd.read_csv(<span class="string">&#x27;./step7/test_data.csv&#x27;</span>).as_matrix()</span><br><span class="line"></span><br><span class="line">dt = DecisionTreeClassifier()</span><br><span class="line">dt.fit(train_df, train_label)</span><br><span class="line">result = dt.predict(test_df)</span><br><span class="line"></span><br><span class="line">result = pd.DataFrame(&#123;<span class="string">&#x27;target&#x27;</span>: result&#125;)</span><br><span class="line">result.to_csv(<span class="string">&#x27;./step7/predict.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># ********* End *********#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Educoder</category>
        <category>ML</category>
      </categories>
      <tags>
        <tag>Educoder</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>头歌 - 机器学习 - Adaboost</title>
    <url>//2023/05/25/educoder-ml-homework/</url>
    <content><![CDATA[<h1 id="【educoder】-机器学习-Adaboost"><a href="#【educoder】-机器学习-Adaboost" class="headerlink" title="【educoder】 机器学习 --- Adaboost"></a>【educoder】 机器学习 --- Adaboost</h1><h2 id="第1关：Boosting"><a href="#第1关：Boosting" class="headerlink" title="第1关：Boosting"></a>第1关：Boosting</h2><h3 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：根据本节课所学知识完成本关所设置的选择题。</p>
<h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握：1.什么是集成学习，2.Boosting。</p>
<h4 id="什么是集成学习"><a href="#什么是集成学习" class="headerlink" title="什么是集成学习"></a>什么是集成学习</h4><p>集成学习方法是一种常用的机器学习方法，分为 bagging 与 boosting 两种方法，应用十分广泛。集成学习基本思想是：对于一个复杂的学习任务，我们首先构造多个简单的学习模型，然后再把这些简单模型组合成一个高效的学习模型。实际上，就是<strong>“三个臭皮匠顶个诸葛亮”</strong>的道理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog294198" alt="img"> </p>
<p>集成学习采取投票的方式来综合多个简单模型的结果，按 bagging 投票思想，如下面例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog294208" alt="img"> </p>
<p>假设一共训练了 5 个简单模型，每个模型对分类结果预测如上图，则最终预测结果为： A:2  B:3  3&gt;2  结果为 B</p>
<p>不过在有的时候，每个模型对分类结果的确定性不一样，即有的对分类结果非常肯定，有的不是很肯定,说明每个模型投的一票应该是有相应的权重来衡量这一票的重要性。就像在歌手比赛中，每个观众投的票记 1 分，而专家投票记 10 分。按 boosting 投票思想，如下例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/294224" alt="img"> </p>
<p>A：<code>(0.9+0.4+0.3+0.8+0.2)/5=0.52</code> B：<code>(0.1+0.6+0.7+0.2+0.8)/5=0.48</code> <code>0.52&gt;0.48</code> 结果为 A</p>
<h4 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h4><p><strong>提升方法</strong>基于这样一种思想：对于一个复杂任务来说，将多个专家的判断进行适当的综合所得出的判断，要比其中任何一个专家单独的判断好。</p>
<p>历史上， Kearns 和 Valiant 首先提出了<strong>强可学习</strong>和<strong>弱可学习</strong>的概念。指出：在 PAC 学习的框架中，一个概念，如果存在一个多项式的学习算法能够学习它，并且正确率很高，那么就称这个概念是强可学习的；一个概念，如果存在一个多项式的学习算法能够学习它，学习的正确率仅比随机猜测略好，那么就称这个概念是弱可学习的。非常有趣的是 Schapire 后来证明强可学习与弱可学习是等价的，也就是说，在 PAC 学习的框架下，一个概念是强可学习的充分必要条件是这个概念是弱可学习的。</p>
<p>这样一来，问题便成为，在学习中，如果已经发现了<strong>弱学习算法</strong>，那么能否将它<strong>提升</strong>为<strong>强学习算法</strong>。大家知道，发现弱学习算法通常要比发现强学习算法容易得多。那么如何具体实施提升，便成为开发提升方法时所要解决的问题。</p>
<p>与 bagging 不同， boosting 采用的是一个串行训练的方法。首先，它训练出一个<strong>弱分类器</strong>，然后在此基础上，再训练出一个稍好点的<strong>弱分类器</strong>，以此类推，不断的训练出多个弱分类器，最终再将这些分类器相结合，这就是 boosting 的基本思想，流程如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog294254" alt="img"> </p>
<p>可以看出，子模型之间存在强依赖关系，必须串行生成。 boosting 是利用不同模型的相加，构成一个更好的模型，求取模型一般都采用序列化方法，后面的模型依据前面的模型。</p>
<h3 id="编程要求"><a href="#编程要求" class="headerlink" title="编程要求"></a>编程要求</h3><p>根据所学完成右侧选择题。</p>
<h3 id="测试说明"><a href="#测试说明" class="headerlink" title="测试说明"></a>测试说明</h3><p>略</p>
<h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h3><ul>
<li><p>现在有一份数据，你随机的将数据分成了<code>n</code>份，然后同时训练<code>n</code>个子模型，再将模型最后相结合得到一个强学习器，这属于<code>boosting</code>方法吗？</p>
<p>A、是B、不是C、不确定</p>
</li>
<li><p>2、对于一个二分类问题，假如现在训练了<code>500</code>个子模型，每个模型权重大小一样。若每个子模型正确率为<code>51%</code>，则整体正确率为多少？若把每个子模型正确率提升到<code>60%</code>，则整体正确率为多少？</p>
<p>A、51%,60%B、60%,90%C、65.7%,99.99%D、65.7%,90%</p>
</li>
</ul>
<blockquote>
<p>参考答案：</p>
<p>1.B 2.C</p>
</blockquote>
<h2 id="第2关：Adaboost算法"><a href="#第2关：Adaboost算法" class="headerlink" title="第2关：Adaboost算法"></a>第2关：Adaboost算法</h2><h3 id="任务描述-1"><a href="#任务描述-1" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：用 Python 实现 Adaboost，并通过鸢尾花数据集中鸢尾花的 2 种属性与种类对 Adaboost 模型进行训练。我们会调用你训练好的 Adaboost 模型，来对未知的鸢尾花进行分类。</p>
<h3 id="相关知识-1"><a href="#相关知识-1" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握：1. Adaboost 算法原理，2. Adaboost 算法流程。</p>
<h4 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h4><p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog286256" alt="img"> </p>
<p>数据集为鸢尾花数据，一共有 150 个样本，每个样本有 4 个特征，由于 Adaboost 是一个串行的迭代二分类算法，运算成本较大，为了减轻运算成本，我们只利用其中两个特征与两种类别构造与训练模型，且 adaboost 算法返回的值为 1 与 -1，所以要将标签为 0 的数据改为 -1 部分数据如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog294166" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog294167" alt="img"></p>
<p>数据获取代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取并处理鸢尾花数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_data</span>():</span><br><span class="line">    iris = load_iris()</span><br><span class="line">    df = pd.DataFrame(iris.data, columns=iris.feature_names)</span><br><span class="line">    df[<span class="string">&#x27;label&#x27;</span>] = iris.target</span><br><span class="line">    df.columns = [<span class="string">&#x27;sepal length&#x27;</span>, <span class="string">&#x27;sepal width&#x27;</span>, <span class="string">&#x27;petal length&#x27;</span>, <span class="string">&#x27;petal width&#x27;</span>, <span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">    data = np.array(df.iloc[:<span class="number">100</span>, [<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>]])</span><br><span class="line">    <span class="comment">#将标签为0的数据标签改为-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        <span class="keyword">if</span> data[i,-<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">            data[i,-<span class="number">1</span>] = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> data[:,:<span class="number">2</span>], data[:,-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="Adaboost算法原理"><a href="#Adaboost算法原理" class="headerlink" title="Adaboost算法原理"></a>Adaboost算法原理</h4><p>对提升方法来说，有两个问题需要回答：<strong>一是在每一轮如何改变训练数据的权值或概率分布；二是如何将弱分类器组合成一个强分类器。</strong>关于第 1 个问题，AdaBoost的做法是，<strong>提高那些被前一轮弱分类器错误分类样本的权值，而降低那些被正确分类样本的权值</strong>。这样一来，那些没有得到正确分类的数据，由于其权值的加大而受到后一轮的弱分类器的更大关注。于是，分类问题被一系列的弱分类器“分而治之”。至于第 2 个问题，即弱分类器的组合，AdaBoost采取<strong>加权多数表决的方法，加大分类误差率小的弱分类器的权值，使其在表决中起较大的作用，减小分类误差率大的弱分类器的权值，使其在表决中起较小的作用</strong>。</p>
<h4 id="Adaboost算法流程"><a href="#Adaboost算法流程" class="headerlink" title="Adaboost算法流程"></a>Adaboost算法流程</h4><p> AdaBoost 是 AdaptiveBoost 的缩写，表明该算法是具有适应性的提升算法。</p>
<p>算法的步骤如下：</p>
<p>1.给每个训练样本(<em>x</em>1,<em>x</em>2,..,<em>x**N</em>)分配权重，初始权重<em>w</em>1均为1/<em>N</em>；</p>
<p>2.针对带有权值的样本进行训练，得到模型<em>G**m</em>（初始模型为<em>G</em>1）；</p>
<p>3.计算模型<em>G**m</em>的误分率：<br>$$<br>e_m=\sum^{N}_{i}\omega_iI(y_i\neq G_M(X_i))<br>$$<br>其中：<br>$$<br>I(y_I\neq G_M(X_i))<br>$$<br>为指示函数，表示括号内成立时函数值为 1，否则为 0。</p>
<p>4.计算模型$G_M$的系数：<br>$$<br>\alpha_m=\frac{1}{2}\log(\frac{1-e_m}{e_m})<br>$$<br>5.根据误分率<em>e</em>和当前权重向量$\omega_m$更新权重向量：<br>$$<br>\omega_{m+1,i}=\frac{\omega_m}{z_m}e^{-\alpha_my_iG_m(x_i)}<br>$$<br>其中$Z_m$为规范化因子：<br>$$<br>z_m=\sum_{i=1}^{m}\omega_{mi}e^{-\alpha_my_iG_m(x_i)}<br>$$<br>6.计算组合模型$f(x)=\sum_{m=1}^{M}\alpha_my_iG_m(x_i)$的误分率；</p>
<p>7.当组合模型的误分率或迭代次数低于一定阈值，停止迭代；否则，回到步骤 2。</p>
<h3 id="编程要求-1"><a href="#编程要求-1" class="headerlink" title="编程要求"></a>编程要求</h3><p>根据提示，在右侧编辑器的 begin-end 间补充 Python 代码，实现 Adaboost 算法，并利用训练好的模型对鸢尾花数据进行分类。</p>
<h3 id="测试说明-1"><a href="#测试说明-1" class="headerlink" title="测试说明"></a>测试说明</h3><p>只需返回分类结果即可，程序内部会检测您的代码，预测正确率高于 95% 视为过关。</p>
<h3 id="参考答案-1"><a href="#参考答案-1" class="headerlink" title="参考答案"></a>参考答案</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># adaboost算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdaBoost</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        input:n_estimators(int):迭代轮数</span></span><br><span class="line"><span class="string">              learning_rate(float):弱分类器权重缩减系数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n_estimators=<span class="number">50</span>, learning_rate=<span class="number">1.0</span></span>):</span><br><span class="line">        self.clf_num = n_estimators</span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init_args</span>(<span class="params">self, datasets, labels</span>):</span><br><span class="line">        self.X = datasets</span><br><span class="line">        self.Y = labels</span><br><span class="line">        self.M, self.N = datasets.shape</span><br><span class="line">        <span class="comment"># 弱分类器数目和集合</span></span><br><span class="line">        self.clf_sets = []</span><br><span class="line">        <span class="comment"># 初始化weights</span></span><br><span class="line">        self.weights = [<span class="number">1.0</span> / self.M] * self.M</span><br><span class="line">        <span class="comment"># G(x)系数 alpha</span></span><br><span class="line">        self.alpha = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ********* Begin *********#</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_G</span>(<span class="params">self, features, labels, weights</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            input:features(ndarray):数据特征</span></span><br><span class="line"><span class="string">                  labels(ndarray):数据标签</span></span><br><span class="line"><span class="string">                  weights(ndarray):样本权重系数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        e = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(weights.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">if</span> (labels[i] == self.G(self.X[i], self.clif_sets, self.alpha)):</span><br><span class="line">                e += weights[i]</span><br><span class="line">        <span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算alpha</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_alpha</span>(<span class="params">self, error</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * np.log((<span class="number">1</span> - error) / error)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 规范化因子</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_Z</span>(<span class="params">self, weights, a, clf</span>):</span><br><span class="line">        <span class="keyword">return</span> np.<span class="built_in">sum</span>(weights * np.exp(-a * self.Y * self.G(self.X, clf, self.alpha)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 权值更新</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_w</span>(<span class="params">self, a, clf, Z</span>):</span><br><span class="line">        w = np.zeros(self.weights.shape)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.M):</span><br><span class="line">            w[i] = weights[i] * np.exp(-a * self.Y[i] * G(x, clf, self.alpha)) / Z</span><br><span class="line">        self.weights = w</span><br><span class="line"></span><br><span class="line">    <span class="comment"># G(x)的线性组合</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">G</span>(<span class="params">self, x, v, direct</span>):</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        x = x.reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(v)):</span><br><span class="line">            result += v[i].predict(x) * direct[i]</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, X, y</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            X(ndarray):训练数据</span></span><br><span class="line"><span class="string">            y(ndarray):训练标签</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 计算G(x)系数a</span></span><br><span class="line">        self.init_args(X, y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            input:data(ndarray):单个样本</span></span><br><span class="line"><span class="string">            output:预测为正样本返回+1，负样本返回-1</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ada = AdaBoostClassifier(n_estimators=<span class="number">100</span>, learning_rate=<span class="number">0.1</span>)</span><br><span class="line">        ada.fit(self.X, self.Y)</span><br><span class="line">        data = data.reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">        predict = ada.predict(data)</span><br><span class="line">        <span class="keyword">return</span> predict[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># ********* End *********#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第3关：sklearn中的Adaboost"><a href="#第3关：sklearn中的Adaboost" class="headerlink" title="第3关：sklearn中的Adaboost"></a>第3关：sklearn中的Adaboost</h2><h3 id="任务描述-2"><a href="#任务描述-2" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：你需要调用 sklearn 中的 Adaboost 模型，并通过癌细胞数据集对 Adaboost 模型进行训练。我们会调用你训练好的 Adaboost 模型，来对未知的癌细胞进行识别。</p>
<h3 id="相关知识-2"><a href="#相关知识-2" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握：1. AdaBoostClassifier。</p>
<h4 id="数据集介绍-1"><a href="#数据集介绍-1" class="headerlink" title="数据集介绍"></a>数据集介绍</h4><p>乳腺癌数据集，其实例数量是 569 ，实例中包括诊断类和属性，帮助预测的属性一共 30 个，各属性包括为 radius  半径（从中心到边缘上点的距离的平均值），texture  纹理（灰度值的标准偏差）等等，类包括： WDBC-Malignant  恶性和  WDBC-Benign  良性。用数据集的 80% 作为训练集，数据集的 20% 作为测试集，训练集和测试集中都包括特征和诊断类。</p>
<p>想要使用该数据集可以使用如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"><span class="comment">#加载数据</span></span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line"><span class="comment">#获取特征与标签</span></span><br><span class="line">x,y = cancer[<span class="string">&#x27;data&#x27;</span>],cancer[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line"><span class="comment">#划分训练集与测试集</span></span><br><span class="line">x_train,x_test,y_train,y_test = train_test_split(x,y,test_size=<span class="number">0.2</span>,random_state=<span class="number">666</span>)</span><br></pre></td></tr></table></figure>

<p>数据集中部分数据与标签如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/312821" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/312823" alt="img"></p>
<h4 id="AdaBoostClassifier"><a href="#AdaBoostClassifier" class="headerlink" title="AdaBoostClassifier"></a>AdaBoostClassifier</h4><p> AdaBoostClassifier 的构造函数中有四个常用的参数可以设置：</p>
<ul>
<li> algorithm ：这个参数只有 AdaBoostClassifier 有。主要原因是scikit-learn 实现了两种 Adaboost 分类算法， SAMME 和 SAMME.R。两者的主要区别是弱学习器权重的度量， SAMME.R 使用了概率度量的连续值，迭代一般比 SAMME 快，因此 AdaBoostClassifier 的默认算法 algorithm 的值也是 SAMME.R；</li>
<li> n_estimators ：弱学习器的最大迭代次数。一般来说 n_estimators 太小，容易欠拟合，n_estimators 太大，又容易过拟合，一般选择一个适中的数值。默认是 50；</li>
<li> learning_rate ：AdaBoostClassifier 和 AdaBoostRegressor 都有，即每个弱学习器的权重缩减系数 ν，默认为 1.0；</li>
<li> base_estimator ：弱分类学习器或者弱回归学习器。理论上可以选择任何一个分类或者回归学习器，不过需要支持样本权重。我们常用的一般是 CART 决策树或者神经网络 MLP。</li>
</ul>
<p>和 sklearn 中其他分类器一样，AdaBoostClassifier 类中的 fit 函数用于训练模型，fit 函数有两个向量输入：</p>
<ul>
<li> X ：大小为**[样本数量,特征数量]**的 ndarray，存放训练样本；</li>
<li> Y ：值为整型，大小为**[样本数量]**的 ndarray，存放训练样本的分类标签。</li>
</ul>
<p>AdaBoostClassifier 类中的 predict 函数用于预测，返回预测标签， predict 函数有一个向量输入：</p>
<p> X ：大小为**[样本数量,特征数量]**的 ndarray，存放预测样本 AdaBoostClassifier 的使用代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ada=AdaBoostClassifier(n_estimators=<span class="number">5</span>,learning_rate=<span class="number">1.0</span>)</span><br><span class="line">ada.fit(train_data,train_label)</span><br><span class="line">predict = ada.predict(test_data)</span><br></pre></td></tr></table></figure>

<h3 id="编程要求-2"><a href="#编程要求-2" class="headerlink" title="编程要求"></a>编程要求</h3><p>在 begin-end 区域内填写<code>ada_classifier(train_data,train_label,test_data)</code>函数完成癌细胞识别任务，其中：</p>
<ul>
<li>train_data：训练样本；</li>
<li>train_label：训练标签；</li>
<li>test_data：测试样本。</li>
</ul>
<h3 id="测试说明-2"><a href="#测试说明-2" class="headerlink" title="测试说明"></a>测试说明</h3><p>只需返回预测结果即可，程序内部会检测您的代码，预测正确率高于 95% 视为过关。</p>
<h3 id="参考答案-2"><a href="#参考答案-2" class="headerlink" title="参考答案"></a>参考答案</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding=utf8</span></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ada_classifier</span>(<span class="params">train_data, train_label, test_data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        input:train_data(ndarray):训练数据</span></span><br><span class="line"><span class="string">              train_label(ndarray):训练标签</span></span><br><span class="line"><span class="string">              test_data(ndarray):测试标签</span></span><br><span class="line"><span class="string">        output:predict(ndarray):预测结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># ********* Begin *********#</span></span><br><span class="line">    ada = AdaBoostClassifier(n_estimators=<span class="number">80</span>, learning_rate=<span class="number">1.0</span>)</span><br><span class="line">    ada.fit(train_data, train_label)</span><br><span class="line">    predict = ada.predict(test_data)</span><br><span class="line">    <span class="comment"># ********* End *********#</span></span><br><span class="line">    <span class="keyword">return</span> predict</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Educoder</category>
        <category>ML</category>
      </categories>
      <tags>
        <tag>Educoder</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>研二学年计划 &amp; 安排</title>
    <url>//2023/08/30/%E7%A0%94%E4%BA%8C%E5%AD%A6%E5%B9%B4%E8%AE%A1%E5%88%92%20&amp;%20%E5%AE%89%E6%8E%92/</url>
    <content><![CDATA[<h1 id="研二学年计划-amp-安排"><a href="#研二学年计划-amp-安排" class="headerlink" title="研二学年计划 &amp; 安排"></a>研二学年计划 &amp; 安排</h1><h2 id="研二学年计划-——-想干啥？"><a href="#研二学年计划-——-想干啥？" class="headerlink" title="研二学年计划 —— 想干啥？"></a>研二学年计划 —— 想干啥？</h2><ul>
<li><input checked="" disabled="" type="checkbox"> <strong>通过大学英语六级</strong></li>
<li><input disabled="" type="checkbox"> <strong>发文章</strong></li>
<li><input disabled="" type="checkbox"> <strong>写博客</strong></li>
<li><input disabled="" type="checkbox"> <strong>入党</strong></li>
</ul>
<h2 id="研二学年安排-——-怎么干？"><a href="#研二学年安排-——-怎么干？" class="headerlink" title="研二学年安排 —— 怎么干？"></a>研二学年安排 —— 怎么干？</h2><h3 id="通过大学英语六级"><a href="#通过大学英语六级" class="headerlink" title="通过大学英语六级"></a><strong>通过大学英语六级</strong></h3><ol>
<li>背单词，坚持每天 <code>背单词</code> ！！！</li>
<li>学语法，学习基础的英语语法</li>
<li>练习听力，阅读，写作，主要是<code>阅读的速度</code>和<code>写作的能力</code></li>
</ol>
<h3 id="发文章"><a href="#发文章" class="headerlink" title="发文章"></a>发文章</h3><p>目前正在做的一些工作如下：</p>
<ol>
<li><strong>吐槽大会数据集</strong></li>
<li>讽刺生成（强化学习）</li>
<li>文本风格转换综述</li>
<li>中药 VQA（数据集 + 模型）</li>
</ol>
<p>目前各个项目的进展如下（截止到 2023.08.30）：</p>
<ol>
<li>吐槽大会数据集正在进行字幕校对的工作，后续工作主要是完成字幕校对，进行情感标注，撰写文章和文章修改</li>
<li>讽刺生成目前正在可行性验证阶段，后续的工作主要是完成模型的构建，撰写文章和文章修改</li>
<li>文本风格转换数据集正在进行论文收集和阅读的工作，后续的工作主要是进行研究方向的工作总结，撰写文章和文章修改</li>
<li>中药 VQA 数据集已经基本构建完成，目前正在进行的是基线模型的复现，后续工作主要是将基线模型使用在我们的数据集中，然后构建自己的用于 VQA 的模型，撰写文章和文章修改</li>
</ol>
<h3 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h3><ol>
<li>记录学习的心路历程和心得体会</li>
<li>记录遇到的问题和解决的方案</li>
<li>记录学习、工作、生活等</li>
</ol>
<h3 id="入党"><a href="#入党" class="headerlink" title="入党"></a>入党</h3><ol>
<li>思想汇报</li>
<li>党组织活动</li>
<li>培养人谈话</li>
</ol>
]]></content>
      <categories>
        <category>Plan</category>
        <category>Graduate</category>
      </categories>
      <tags>
        <tag>计划</tag>
        <tag>研究生</tag>
      </tags>
  </entry>
  <entry>
    <title>【教程】OverLeaf 免费永久升级 Professional 订阅</title>
    <url>//2023/10/17/%E3%80%90%E6%95%99%E7%A8%8B%E3%80%91OverLeaf%20%E5%85%8D%E8%B4%B9%E6%B0%B8%E4%B9%85%E5%8D%87%E7%BA%A7%20Professional%20%E8%AE%A2%E9%98%85/</url>
    <content><![CDATA[<h1 id="【教程】OverLeaf-免费永久升级-Professional-订阅"><a href="#【教程】OverLeaf-免费永久升级-Professional-订阅" class="headerlink" title="【教程】OverLeaf 免费永久升级 Professional 订阅"></a>【教程】OverLeaf 免费永久升级 Professional 订阅</h1><p>在读博士或者硕士的同学，可能经常会需要用到<code>LaTex</code>和<a href="https://cn.overleaf.com/">Overleaf</a>来对论文进行编辑和排版。常见的<code>LaTex</code>有两种使用的方式，一种是下载到自己本地然后在本地进行编译运行，另一种是在线编译运行。这里需要讲到的是在线编译运行的方式使用<code>LaTex</code>。</p>
<p><a href="https://cn.overleaf.com/">Overleaf</a> 是在线编译运行<code>LaTex</code>的代表软件之一。<a href="https://cn.overleaf.com/">Overleaf</a>因其界面友好、可实时修改评论，且支持多人在线协作而受到许多人的欢迎。它支持多种运行的环境，有非常多的论文模板可以选用比如像ACM的会议通常会提供这两种工具的模版，并且是完全免费的。</p>
<p><a href="https://cn.overleaf.com/">Overleaf</a>的免费版本是不能解锁<code>review</code>模式等全部功能的。今天在这里分享一个实用小技巧，让大家可以免费获得<code>Professional Plan</code>，解锁全部功能！</p>
<h2 id="OverLeaf-官网"><a href="#OverLeaf-官网" class="headerlink" title="OverLeaf 官网"></a><code>OverLeaf </code>官网</h2><ol>
<li>中文官网：<a href="https://cn.overleaf.com/">Overleaf, 在线LaTeX编辑器</a></li>
<li>英文官网：<a href="https://www.overleaf.com/">Overleaf, Online LaTeX Editor</a></li>
</ol>
<h2 id="IEEE-Collabratec-官网"><a href="#IEEE-Collabratec-官网" class="headerlink" title="IEEE Collabratec 官网"></a><code>IEEE Collabratec</code> 官网</h2><ol>
<li>英文官网：<a href="https://ieee-collabratec.ieee.org/">IEEE Collabratec®</a></li>
</ol>
<h2 id="需要使用的工具"><a href="#需要使用的工具" class="headerlink" title="需要使用的工具"></a>需要使用的工具</h2><ol>
<li><code>科学上网小工具</code>(懂的都懂)</li>
<li><code>一个邮箱</code>(什么邮箱都行)</li>
</ol>
<h2 id="升级-Professional-Plan-订阅"><a href="#升级-Professional-Plan-订阅" class="headerlink" title="升级 Professional Plan 订阅"></a>升级 Professional Plan 订阅</h2><ol>
<li><p>进入<a href="https://ieee-collabratec.ieee.org/">IEEE Collabratec</a>主页，注册一个账号（免费），注册的时候需要使用到<code>科学上网小工具</code>，具体操作请自行探索。</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blogimage-20231017162616768.png" alt="image-20231017162616768"></p>
</li>
<li><p>使用邮箱注册<a href="https://cn.overleaf.com/">Overleaf</a>账号（免费）</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blogimage-20231017161857158.png" alt="image-20231017161857158"></p>
<p>⚠️：如果已经注册了<a href="https://cn.overleaf.com/">Overleaf</a>账号可以省略注册步骤，但是请务必注意：<code>注册IEEE Collabratec的邮箱和Overleaf注册邮箱需要保持一致</code></p>
</li>
<li><p>进入登陆好的<code>IEEE Collabratec</code>主页，从上方导航栏的<code>Settings</code>里进入<code>Attached services</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blogimage-20231017162959224.png" alt="image-20231017162959224"></p>
</li>
<li><p>找到Overleaf，点击Connect，用邮箱完成验证即可，出现下方图片中的情况说明你已经关联成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blogimage-20231017163141758.png" alt="image-20231017163141758"></p>
</li>
<li><p>再次查看自己的Overleaf账号，就会发现已经是Professional Plan啦（图五），解锁全部功能！正在overleaf订阅期的小伙伴建议订阅期结束再尝试哦。</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blogimage-20231017163713653.png" alt="image-20231017163713653"></p>
</li>
</ol>
<p>至此，恭喜你成为了尊贵的 <code>OverLeaf</code> Professional Plan 订阅者，解锁所有 <code>OverLeaf </code>的功能。目前没有现实到期时间，所以只要<code>IEEE Collabratec</code> 和 <code>OverLeaf </code>的合作不间断，就可以一直白嫖。</p>
]]></content>
      <categories>
        <category>教程</category>
        <category>OverLeaf</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>OverLeaf</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-08-31 学习笔记</title>
    <url>//2023/08/31/2023-08-31%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="2023-08-31-学习笔记"><a href="#2023-08-31-学习笔记" class="headerlink" title="2023-08-31 学习笔记"></a>2023-08-31 学习笔记</h1><h2 id="1-预训练语言模型的使用"><a href="#1-预训练语言模型的使用" class="headerlink" title="1. 预训练语言模型的使用"></a>1. 预训练语言模型的使用</h2><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p><code>如何使用预训练的语言模型在已有的数据集上进行微调？</code></p>
<h3 id="解决方案如下："><a href="#解决方案如下：" class="headerlink" title="解决方案如下："></a>解决方案如下：</h3><ol>
<li>首先下载一个预训练语言模型，这里使用的是 <code>cardiffnlp/twitter-xlm-roberta-base-sentiment-multilingual</code> 可以直接在<a href="https://huggingface.co/cardiffnlp/twitter-xlm-roberta-base-sentiment-multilingual">Hugging Face</a> 上下载</li>
<li>预处理数据集(很关键！！)，数据集如果没有处理好，模型运行过程中容易报错，例如 <code>3. 错误解决</code> 中就出现了因为数据集没有处理好而导致的错误</li>
<li>加载模型和分词器</li>
<li>模型训练</li>
<li>模型评估</li>
</ol>
<h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><ol>
<li><p>项目配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hydra 配置</span></span><br><span class="line"><span class="attr">defaults:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">_self_</span> <span class="comment"># 优先级最高, 会覆盖其他配置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">override hydra/hydra_logging:</span> <span class="string">disabled</span> <span class="comment"># 禁用hydra日志, 会覆盖其他配置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">override hydra/job_logging:</span> <span class="string">disabled</span> <span class="comment"># 禁用hydra日志, 会覆盖其他配置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">hydra:</span></span><br><span class="line">  <span class="attr">output_subdir:</span> <span class="literal">null</span> <span class="comment"># 输出目录</span></span><br><span class="line">  <span class="attr">run:</span> <span class="comment"># 运行配置</span></span><br><span class="line">    <span class="attr">dir:</span> <span class="string">.</span> <span class="comment"># 运行目录，相对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目配置</span></span><br><span class="line"><span class="attr">project:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Mongolian</span> <span class="string">Sentiment</span> <span class="string">Classification</span> <span class="comment"># 项目名称</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">0.0</span><span class="number">.1</span> <span class="comment"># 项目版本</span></span><br><span class="line"></span><br><span class="line"><span class="attr">resume:</span> <span class="string">&quot;output/epoch_4_f1_0.2792.pth&quot;</span> <span class="comment"># 恢复训练模型路径</span></span><br><span class="line"><span class="attr">lr:</span> <span class="number">1e-5</span> <span class="comment"># 学习率</span></span><br><span class="line"><span class="attr">train_batch_size:</span> <span class="number">64</span> <span class="comment"># 训练batch size</span></span><br><span class="line"><span class="attr">valid_batch_size:</span> <span class="number">128</span> <span class="comment"># 验证batch size</span></span><br><span class="line"><span class="attr">warm_up_steps:</span> <span class="number">500</span> <span class="comment"># warm up steps</span></span><br><span class="line"><span class="attr">epochs:</span> <span class="number">10</span> <span class="comment"># 训练轮数</span></span><br><span class="line"><span class="attr">device:</span> <span class="string">&quot;cuda:2&quot;</span> <span class="comment"># 训练设备</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pretrained_model_name_or_path:</span> <span class="string">&quot;model&quot;</span> <span class="comment"># 预训练模型路径</span></span><br><span class="line"><span class="attr">output_dir:</span> <span class="string">&quot;output&quot;</span> <span class="comment"># 输出目录</span></span><br><span class="line"><span class="attr">train_file_path:</span> <span class="string">&quot;data/train.csv&quot;</span> <span class="comment"># 训练数据路径</span></span><br><span class="line"><span class="attr">valid_file_path:</span> <span class="string">&quot;data/valid.csv&quot;</span> <span class="comment"># 验证数据路径</span></span><br><span class="line"><span class="attr">weight_decay:</span> <span class="number">0.01</span> <span class="comment"># 权重衰减</span></span><br><span class="line"></span><br><span class="line"><span class="attr">plm_config:</span></span><br><span class="line">  <span class="attr">max_length:</span> <span class="number">256</span> <span class="comment"># 最大序列长度</span></span><br><span class="line">  <span class="attr">num_labels:</span> <span class="number">6</span></span><br><span class="line">  <span class="attr">label2id:</span></span><br><span class="line">    <span class="attr">neural:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">happy:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">angry:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">sad:</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">fear:</span> <span class="number">4</span></span><br><span class="line">    <span class="attr">surprise:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">id2label:</span></span><br><span class="line">    <span class="attr">0:</span> <span class="string">neural</span></span><br><span class="line">    <span class="attr">1:</span> <span class="string">happy</span></span><br><span class="line">    <span class="attr">2:</span> <span class="string">angry</span></span><br><span class="line">    <span class="attr">3:</span> <span class="string">sad</span></span><br><span class="line">    <span class="attr">4:</span> <span class="string">fear</span></span><br><span class="line">    <span class="attr">5:</span> <span class="string">surprise</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数据预处理代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">split_dataset</span>(<span class="params">data_path: <span class="built_in">str</span> = <span class="string">&quot;data/data.csv&quot;</span>, ratio=<span class="number">0.8</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        划分数据集</span></span><br><span class="line"><span class="string">        :param ratio: 划分比例</span></span><br><span class="line"><span class="string">        :param data_path: 数据集路径</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 读取文件</span></span><br><span class="line">    data = pd.read_csv(data_path, encoding=<span class="string">&#x27;GBK&#x27;</span>, names=[<span class="string">&#x27;text&#x27;</span>, <span class="string">&#x27;label&#x27;</span>])</span><br><span class="line">    data.dropna(axis=<span class="number">0</span>, inplace=<span class="literal">True</span>)  <span class="comment"># 删除空行</span></span><br><span class="line">    data.dropna(axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)  <span class="comment"># 删除空行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 划分数据集</span></span><br><span class="line">    train_data = data.sample(frac=ratio, random_state=<span class="number">0</span>, axis=<span class="number">0</span>)</span><br><span class="line">    valid_data = data.drop(train_data.index)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;数据集大小：<span class="subst">&#123;data.shape[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;训练集大小：<span class="subst">&#123;train_data.shape[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;验证集大小：<span class="subst">&#123;valid_data.shape[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存数据集</span></span><br><span class="line">    train_data.to_csv(<span class="string">&quot;data/train.csv&quot;</span>, columns=[<span class="string">&quot;text&quot;</span>, <span class="string">&quot;label&quot;</span>], index=<span class="literal">False</span>, encoding=<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line">    valid_data.to_csv(<span class="string">&quot;data/valid.csv&quot;</span>, columns=[<span class="string">&quot;text&quot;</span>, <span class="string">&quot;label&quot;</span>], index=<span class="literal">False</span>, encoding=<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>加载模型和分词器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_pretrained_model</span>(<span class="params">config</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        加载预训练语言模型</span></span><br><span class="line"><span class="string">        :param config: 配置文件</span></span><br><span class="line"><span class="string">        :return: 模型和分词器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 加载配置文件和修改配置文件</span></span><br><span class="line">    plm_config = XLMRobertaConfig.from_pretrained(config[<span class="string">&#x27;pretrained_model_name_or_path&#x27;</span>])</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> config[<span class="string">&#x27;plm_config&#x27;</span>].items():</span><br><span class="line">        <span class="built_in">setattr</span>(plm_config, key, value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载预训练语言模型和分词器</span></span><br><span class="line">    model = XLMRobertaForSequenceClassification.from_pretrained(config[<span class="string">&#x27;pretrained_model_name_or_path&#x27;</span>])</span><br><span class="line">    tokenizer = XLMRobertaTokenizerFast.from_pretrained(config[<span class="string">&#x27;pretrained_model_name_or_path&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改模型的分类器配置文件</span></span><br><span class="line">    model.plm_config = plm_config</span><br><span class="line">    model.num_labels = plm_config.num_labels</span><br><span class="line">    model.classifier = RobertaClassificationHead(plm_config)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 冻结模型</span></span><br><span class="line">    freeze_model(model.roberta)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回模型和分词器</span></span><br><span class="line">    <span class="keyword">return</span> model, tokenizer</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>模型训练</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_train</span>(<span class="params">config</span>):</span><br><span class="line">    epochs, device = config[<span class="string">&#x27;epochs&#x27;</span>], torch.device(config[<span class="string">&#x27;device&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载数据集</span></span><br><span class="line">    train_loader, valid_loader = load_data(config)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算总步数</span></span><br><span class="line">    total_steps = <span class="built_in">len</span>(train_loader) * epochs</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载模型</span></span><br><span class="line">    model, tokenizer = load_pretrained_model(config)</span><br><span class="line">    model.to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载优化器</span></span><br><span class="line">    optimizer = AdamW(model.parameters(), lr=config[<span class="string">&#x27;lr&#x27;</span>], weight_decay=config[<span class="string">&#x27;weight_decay&#x27;</span>])</span><br><span class="line">    scheduler = get_linear_schedule_with_warmup(</span><br><span class="line">        optimizer=optimizer,</span><br><span class="line">        num_warmup_steps=config[<span class="string">&#x27;warm_up_steps&#x27;</span>],</span><br><span class="line">        num_training_steps=total_steps</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    best_ckpt_path, best_f1 = <span class="string">&quot;&quot;</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 断续训练</span></span><br><span class="line">    <span class="keyword">if</span> config[<span class="string">&#x27;resume&#x27;</span>]:</span><br><span class="line">        <span class="keyword">assert</span> os.path.exists(config[<span class="string">&#x27;resume&#x27;</span>]), <span class="string">f&quot;文件不存在：<span class="subst">&#123;config[<span class="string">&#x27;resume&#x27;</span>]&#125;</span>&quot;</span></span><br><span class="line">        resume_result = torch.load(config[<span class="string">&#x27;resume&#x27;</span>])</span><br><span class="line">        model.load_state_dict(resume_result[<span class="string">&#x27;model&#x27;</span>])</span><br><span class="line">        optimizer.load_state_dict(resume_result[<span class="string">&#x27;optimizer&#x27;</span>])</span><br><span class="line">        scheduler.load_state_dict(resume_result[<span class="string">&#x27;scheduler&#x27;</span>])</span><br><span class="line">        best_ckpt_path = config[<span class="string">&#x27;resume&#x27;</span>]</span><br><span class="line">        best_f1 = resume_result[<span class="string">&#x27;metric_dict&#x27;</span>][<span class="string">&#x27;f1&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    pbar = tqdm(dynamic_ncols=<span class="literal">True</span>, total=total_steps)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        <span class="comment"># model 设置为训练模式</span></span><br><span class="line">        model.train()</span><br><span class="line">        pbar.set_description(<span class="string">f&#x27;[<span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>/<span class="subst">&#123;epochs&#125;</span>]&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> train_loader:</span><br><span class="line">            texts, labels = item[<span class="string">&#x27;text&#x27;</span>], item[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">            model_inputs = tokenizer(</span><br><span class="line">                texts,</span><br><span class="line">                padding=<span class="literal">True</span>,</span><br><span class="line">                truncation=<span class="literal">True</span>,</span><br><span class="line">                max_length=config[<span class="string">&#x27;plm_config&#x27;</span>][<span class="string">&#x27;max_length&#x27;</span>],</span><br><span class="line">                return_tensors=<span class="string">&quot;pt&quot;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> model_inputs.keys():</span><br><span class="line">                model_inputs[key] = model_inputs[key].to(device)</span><br><span class="line"></span><br><span class="line">            labels = torch.LongTensor(labels).to(device) - <span class="number">1</span></span><br><span class="line">            outputs = model(**model_inputs, labels=labels)</span><br><span class="line">            loss = outputs.loss</span><br><span class="line"></span><br><span class="line">            pbar.set_postfix(&#123;<span class="string">&#x27;loss&#x27;</span>: <span class="built_in">round</span>(loss.item(), <span class="number">4</span>)&#125;)</span><br><span class="line">            pbar.update(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            scheduler.step()</span><br><span class="line"></span><br><span class="line">        metric_dict = do_evaluate(</span><br><span class="line">            model,</span><br><span class="line">            tokenizer,</span><br><span class="line">            valid_loader,</span><br><span class="line">            config[<span class="string">&#x27;plm_config&#x27;</span>][<span class="string">&#x27;max_length&#x27;</span>],</span><br><span class="line">            device</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        pp(metric_dict)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> metric_dict[<span class="string">&#x27;f1&#x27;</span>] &gt; best_f1:</span><br><span class="line">            best_f1 = metric_dict[<span class="string">&#x27;f1&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> os.path.exists(best_ckpt_path):</span><br><span class="line">                os.remove(best_ckpt_path)</span><br><span class="line"></span><br><span class="line">            best_ckpt_path = <span class="string">f&quot;<span class="subst">&#123;config[<span class="string">&#x27;output_dir&#x27;</span>]&#125;</span>/epoch_<span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>_f1_<span class="subst">&#123;<span class="built_in">round</span>(best_f1, <span class="number">4</span>)&#125;</span>.pth&quot;</span></span><br><span class="line"></span><br><span class="line">            torch.save(&#123;</span><br><span class="line">                <span class="string">&#x27;model&#x27;</span>: model.state_dict(),</span><br><span class="line">                <span class="string">&#x27;optimizer&#x27;</span>: optimizer.state_dict(),</span><br><span class="line">                <span class="string">&#x27;scheduler&#x27;</span>: scheduler.state_dict(),</span><br><span class="line">                <span class="string">&#x27;metric_dict&#x27;</span>: metric_dict</span><br><span class="line">            &#125;, best_ckpt_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存最佳模型的路径</span></span><br><span class="line">    <span class="keyword">return</span> best_ckpt_path</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>模型验证</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@torch.no_grad()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_evaluate</span>(<span class="params">model, tokenizer, valid_loader, max_length, device</span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        评估模型</span></span><br><span class="line"><span class="string">        :param model: 模型</span></span><br><span class="line"><span class="string">        :param tokenizer: 分词器</span></span><br><span class="line"><span class="string">        :param valid_loader: 验证集</span></span><br><span class="line"><span class="string">        :param max_length: 最大长度</span></span><br><span class="line"><span class="string">        :param device: 设备</span></span><br><span class="line"><span class="string">        :return: 评估结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># model 设置为评估模式</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    total_predict, total_ground = [], []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> tqdm(valid_loader, dynamic_ncols=<span class="literal">True</span>, desc=<span class="string">&#x27;evaluating...&#x27;</span>):</span><br><span class="line">        texts, labels = item[<span class="string">&#x27;text&#x27;</span>], item[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">        model_inputs = tokenizer(</span><br><span class="line">            texts,</span><br><span class="line">            padding=<span class="literal">True</span>,</span><br><span class="line">            truncation=<span class="literal">True</span>,</span><br><span class="line">            max_length=max_length,</span><br><span class="line">            return_tensors=<span class="string">&quot;pt&quot;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> model_inputs.keys():</span><br><span class="line">            model_inputs[key] = model_inputs[key].to(device)</span><br><span class="line"></span><br><span class="line">        labels = torch.LongTensor(labels).to(device) - <span class="number">1</span></span><br><span class="line">        outputs = model(**model_inputs, labels=labels)</span><br><span class="line">        logits = outputs.logits</span><br><span class="line">        predict = logits.argmax(dim=-<span class="number">1</span>).cpu().numpy().tolist()</span><br><span class="line">        total_predict.extend(predict)</span><br><span class="line">        total_ground.extend(labels.cpu().numpy().tolist())</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>: f1_score(total_ground, total_predict, average=<span class="string">&#x27;macro&#x27;</span>),</span><br><span class="line">        <span class="string">&quot;acc&quot;</span>: accuracy_score(total_ground, total_predict),</span><br><span class="line">        <span class="string">&quot;recall&quot;</span>: recall_score(total_ground, total_predict, average=<span class="string">&#x27;macro&#x27;</span>),</span><br><span class="line">        <span class="string">&quot;precision&quot;</span>: precision_score(total_ground, total_predict, average=<span class="string">&#x27;macro&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="完整训练代码如下："><a href="#完整训练代码如下：" class="headerlink" title="完整训练代码如下："></a>完整训练代码如下：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*-coding: Utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Project Name: d2l-zh</span></span><br><span class="line"><span class="comment"># @File: __init__.py.py</span></span><br><span class="line"><span class="comment"># @Author: David</span></span><br><span class="line"><span class="comment"># @Date：2023/8/31 23:13</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pp</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hydra</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> omegaconf <span class="keyword">import</span> OmegaConf</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score, precision_score, accuracy_score, recall_score</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.optim.adamw <span class="keyword">import</span> AdamW</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, Dataset</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> XLMRobertaForSequenceClassification, XLMRobertaConfig, XLMRobertaTokenizerFast, get_linear_schedule_with_warmup</span><br><span class="line"><span class="keyword">from</span> transformers.models.roberta.modeling_roberta <span class="keyword">import</span> RobertaClassificationHead</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split_dataset</span>(<span class="params">data_path: <span class="built_in">str</span> = <span class="string">&quot;data/data.csv&quot;</span>, ratio=<span class="number">0.8</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        划分数据集</span></span><br><span class="line"><span class="string">        :param ratio: 划分比例</span></span><br><span class="line"><span class="string">        :param data_path: 数据集路径</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 读取文件</span></span><br><span class="line">    data = pd.read_csv(data_path, encoding=<span class="string">&#x27;GBK&#x27;</span>, names=[<span class="string">&#x27;text&#x27;</span>, <span class="string">&#x27;label&#x27;</span>])</span><br><span class="line">    data.dropna(axis=<span class="number">0</span>, inplace=<span class="literal">True</span>)  <span class="comment"># 删除空行</span></span><br><span class="line">    data.dropna(axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)  <span class="comment"># 删除空行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 划分数据集</span></span><br><span class="line">    train_data = data.sample(frac=ratio, random_state=<span class="number">0</span>, axis=<span class="number">0</span>)</span><br><span class="line">    valid_data = data.drop(train_data.index)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;数据集大小：<span class="subst">&#123;data.shape[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;训练集大小：<span class="subst">&#123;train_data.shape[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;验证集大小：<span class="subst">&#123;valid_data.shape[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存数据集</span></span><br><span class="line">    train_data.to_csv(<span class="string">&quot;data/train.csv&quot;</span>, columns=[<span class="string">&quot;text&quot;</span>, <span class="string">&quot;label&quot;</span>], index=<span class="literal">False</span>, encoding=<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line">    valid_data.to_csv(<span class="string">&quot;data/valid.csv&quot;</span>, columns=[<span class="string">&quot;text&quot;</span>, <span class="string">&quot;label&quot;</span>], index=<span class="literal">False</span>, encoding=<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">freeze_model</span>(<span class="params">model: nn.Module</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        冻结模型</span></span><br><span class="line"><span class="string">        :param model: 模型</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> model.parameters():</span><br><span class="line">        p.requires_grad = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_pretrained_model</span>(<span class="params">config</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        加载预训练语言模型</span></span><br><span class="line"><span class="string">        :param config: 配置文件</span></span><br><span class="line"><span class="string">        :return: 模型和分词器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 加载配置文件和修改配置文件</span></span><br><span class="line">    plm_config = XLMRobertaConfig.from_pretrained(config[<span class="string">&#x27;pretrained_model_name_or_path&#x27;</span>])</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> config[<span class="string">&#x27;plm_config&#x27;</span>].items():</span><br><span class="line">        <span class="built_in">setattr</span>(plm_config, key, value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载预训练语言模型和分词器</span></span><br><span class="line">    model = XLMRobertaForSequenceClassification.from_pretrained(config[<span class="string">&#x27;pretrained_model_name_or_path&#x27;</span>])</span><br><span class="line">    tokenizer = XLMRobertaTokenizerFast.from_pretrained(config[<span class="string">&#x27;pretrained_model_name_or_path&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改模型的分类器配置文件</span></span><br><span class="line">    model.plm_config = plm_config</span><br><span class="line">    model.num_labels = plm_config.num_labels</span><br><span class="line">    model.classifier = RobertaClassificationHead(plm_config)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 冻结模型</span></span><br><span class="line">    freeze_model(model.roberta)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回模型和分词器</span></span><br><span class="line">    <span class="keyword">return</span> model, tokenizer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, csv_file_path</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyDataset, self).__init__()</span><br><span class="line">        df = pd.read_csv(csv_file_path, encoding=<span class="string">&quot;GBK&quot;</span>)</span><br><span class="line">        self.texts = df[<span class="string">&#x27;text&#x27;</span>].values.tolist()</span><br><span class="line">        self.labels = df[<span class="string">&#x27;label&#x27;</span>].values.tolist()</span><br><span class="line">        self.size = df.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&#x27;text&#x27;</span>: self.texts[idx],</span><br><span class="line">            <span class="string">&#x27;label&#x27;</span>: self.labels[idx]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_data</span>(<span class="params">config</span>):</span><br><span class="line">    train_path, valid_path = config[<span class="string">&#x27;train_file_path&#x27;</span>], config[<span class="string">&#x27;valid_file_path&#x27;</span>]</span><br><span class="line">    train_dataset = MyDataset(train_path)</span><br><span class="line">    valid_dataset = MyDataset(valid_path)</span><br><span class="line">    train_loader = DataLoader(</span><br><span class="line">        dataset=train_dataset,</span><br><span class="line">        shuffle=<span class="literal">True</span>,</span><br><span class="line">        drop_last=<span class="literal">False</span>,</span><br><span class="line">        batch_size=config[<span class="string">&#x27;train_batch_size&#x27;</span>]</span><br><span class="line">    )</span><br><span class="line">    valid_loader = DataLoader(</span><br><span class="line">        dataset=valid_dataset,</span><br><span class="line">        shuffle=<span class="literal">False</span>,</span><br><span class="line">        drop_last=<span class="literal">False</span>,</span><br><span class="line">        batch_size=config[<span class="string">&#x27;valid_batch_size&#x27;</span>]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train_loader, valid_loader</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_train</span>(<span class="params">config</span>):</span><br><span class="line">    epochs, device = config[<span class="string">&#x27;epochs&#x27;</span>], torch.device(config[<span class="string">&#x27;device&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载数据集</span></span><br><span class="line">    train_loader, valid_loader = load_data(config)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算总步数</span></span><br><span class="line">    total_steps = <span class="built_in">len</span>(train_loader) * epochs</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载模型</span></span><br><span class="line">    model, tokenizer = load_pretrained_model(config)</span><br><span class="line">    model.to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载优化器</span></span><br><span class="line">    optimizer = AdamW(model.parameters(), lr=config[<span class="string">&#x27;lr&#x27;</span>], weight_decay=config[<span class="string">&#x27;weight_decay&#x27;</span>])</span><br><span class="line">    scheduler = get_linear_schedule_with_warmup(</span><br><span class="line">        optimizer=optimizer,</span><br><span class="line">        num_warmup_steps=config[<span class="string">&#x27;warm_up_steps&#x27;</span>],</span><br><span class="line">        num_training_steps=total_steps</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    best_ckpt_path, best_f1 = <span class="string">&quot;&quot;</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 断续训练</span></span><br><span class="line">    <span class="keyword">if</span> config[<span class="string">&#x27;resume&#x27;</span>]:</span><br><span class="line">        <span class="keyword">assert</span> os.path.exists(config[<span class="string">&#x27;resume&#x27;</span>]), <span class="string">f&quot;文件不存在：<span class="subst">&#123;config[<span class="string">&#x27;resume&#x27;</span>]&#125;</span>&quot;</span></span><br><span class="line">        resume_result = torch.load(config[<span class="string">&#x27;resume&#x27;</span>])</span><br><span class="line">        model.load_state_dict(resume_result[<span class="string">&#x27;model&#x27;</span>])</span><br><span class="line">        optimizer.load_state_dict(resume_result[<span class="string">&#x27;optimizer&#x27;</span>])</span><br><span class="line">        scheduler.load_state_dict(resume_result[<span class="string">&#x27;scheduler&#x27;</span>])</span><br><span class="line">        best_ckpt_path = config[<span class="string">&#x27;resume&#x27;</span>]</span><br><span class="line">        best_f1 = resume_result[<span class="string">&#x27;metric_dict&#x27;</span>][<span class="string">&#x27;f1&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    pbar = tqdm(dynamic_ncols=<span class="literal">True</span>, total=total_steps)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        <span class="comment"># model 设置为训练模式</span></span><br><span class="line">        model.train()</span><br><span class="line">        pbar.set_description(<span class="string">f&#x27;[<span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>/<span class="subst">&#123;epochs&#125;</span>]&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> train_loader:</span><br><span class="line">            texts, labels = item[<span class="string">&#x27;text&#x27;</span>], item[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">            model_inputs = tokenizer(</span><br><span class="line">                texts,</span><br><span class="line">                padding=<span class="literal">True</span>,</span><br><span class="line">                truncation=<span class="literal">True</span>,</span><br><span class="line">                max_length=config[<span class="string">&#x27;plm_config&#x27;</span>][<span class="string">&#x27;max_length&#x27;</span>],</span><br><span class="line">                return_tensors=<span class="string">&quot;pt&quot;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> model_inputs.keys():</span><br><span class="line">                model_inputs[key] = model_inputs[key].to(device)</span><br><span class="line"></span><br><span class="line">            labels = torch.LongTensor(labels).to(device) - <span class="number">1</span></span><br><span class="line">            outputs = model(**model_inputs, labels=labels)</span><br><span class="line">            loss = outputs.loss</span><br><span class="line"></span><br><span class="line">            pbar.set_postfix(&#123;<span class="string">&#x27;loss&#x27;</span>: <span class="built_in">round</span>(loss.item(), <span class="number">4</span>)&#125;)</span><br><span class="line">            pbar.update(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            scheduler.step()</span><br><span class="line"></span><br><span class="line">        metric_dict = do_evaluate(</span><br><span class="line">            model,</span><br><span class="line">            tokenizer,</span><br><span class="line">            valid_loader,</span><br><span class="line">            config[<span class="string">&#x27;plm_config&#x27;</span>][<span class="string">&#x27;max_length&#x27;</span>],</span><br><span class="line">            device</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        pp(metric_dict)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> metric_dict[<span class="string">&#x27;f1&#x27;</span>] &gt; best_f1:</span><br><span class="line">            best_f1 = metric_dict[<span class="string">&#x27;f1&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> os.path.exists(best_ckpt_path):</span><br><span class="line">                os.remove(best_ckpt_path)</span><br><span class="line"></span><br><span class="line">            best_ckpt_path = <span class="string">f&quot;<span class="subst">&#123;config[<span class="string">&#x27;output_dir&#x27;</span>]&#125;</span>/epoch_<span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>_f1_<span class="subst">&#123;<span class="built_in">round</span>(best_f1, <span class="number">4</span>)&#125;</span>.pth&quot;</span></span><br><span class="line"></span><br><span class="line">            torch.save(&#123;</span><br><span class="line">                <span class="string">&#x27;model&#x27;</span>: model.state_dict(),</span><br><span class="line">                <span class="string">&#x27;optimizer&#x27;</span>: optimizer.state_dict(),</span><br><span class="line">                <span class="string">&#x27;scheduler&#x27;</span>: scheduler.state_dict(),</span><br><span class="line">                <span class="string">&#x27;metric_dict&#x27;</span>: metric_dict</span><br><span class="line">            &#125;, best_ckpt_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存最佳模型的路径</span></span><br><span class="line">    <span class="keyword">return</span> best_ckpt_path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@torch.no_grad()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_evaluate</span>(<span class="params">model, tokenizer, valid_loader, max_length, device</span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        评估模型</span></span><br><span class="line"><span class="string">        :param model: 模型</span></span><br><span class="line"><span class="string">        :param tokenizer: 分词器</span></span><br><span class="line"><span class="string">        :param valid_loader: 验证集</span></span><br><span class="line"><span class="string">        :param max_length: 最大长度</span></span><br><span class="line"><span class="string">        :param device: 设备</span></span><br><span class="line"><span class="string">        :return: 评估结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># model 设置为评估模式</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    total_predict, total_ground = [], []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> tqdm(valid_loader, dynamic_ncols=<span class="literal">True</span>, desc=<span class="string">&#x27;evaluating...&#x27;</span>):</span><br><span class="line">        texts, labels = item[<span class="string">&#x27;text&#x27;</span>], item[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">        model_inputs = tokenizer(</span><br><span class="line">            texts,</span><br><span class="line">            padding=<span class="literal">True</span>,</span><br><span class="line">            truncation=<span class="literal">True</span>,</span><br><span class="line">            max_length=max_length,</span><br><span class="line">            return_tensors=<span class="string">&quot;pt&quot;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> model_inputs.keys():</span><br><span class="line">            model_inputs[key] = model_inputs[key].to(device)</span><br><span class="line"></span><br><span class="line">        labels = torch.LongTensor(labels).to(device) - <span class="number">1</span></span><br><span class="line">        outputs = model(**model_inputs, labels=labels)</span><br><span class="line">        logits = outputs.logits</span><br><span class="line">        predict = logits.argmax(dim=-<span class="number">1</span>).cpu().numpy().tolist()</span><br><span class="line">        total_predict.extend(predict)</span><br><span class="line">        total_ground.extend(labels.cpu().numpy().tolist())</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;f1&quot;</span>: f1_score(total_ground, total_predict, average=<span class="string">&#x27;macro&#x27;</span>),</span><br><span class="line">        <span class="string">&quot;acc&quot;</span>: accuracy_score(total_ground, total_predict),</span><br><span class="line">        <span class="string">&quot;recall&quot;</span>: recall_score(total_ground, total_predict, average=<span class="string">&#x27;macro&#x27;</span>),</span><br><span class="line">        <span class="string">&quot;precision&quot;</span>: precision_score(total_ground, total_predict, average=<span class="string">&#x27;macro&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        检查数据集</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    data = pd.read_csv(<span class="string">&quot;data/valid.csv&quot;</span>, encoding=<span class="string">&#x27;GBK&#x27;</span>, names=[<span class="string">&#x27;text&#x27;</span>, <span class="string">&#x27;label&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按行遍历 data</span></span><br><span class="line">    <span class="keyword">for</span> i, row <span class="keyword">in</span> data.iterrows():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(row[<span class="string">&#x27;text&#x27;</span>], <span class="built_in">float</span>) <span class="keyword">or</span> <span class="built_in">isinstance</span>(row[<span class="string">&#x27;label&#x27;</span>], <span class="built_in">float</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;text or label is empty: <span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;text <span class="subst">&#123;row[<span class="string">&#x27;text&#x27;</span>]&#125;</span>, label <span class="subst">&#123;row[<span class="string">&#x27;label&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@hydra.main(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="meta">    config_path=<span class="string">&#x27;config&#x27;</span>,  <span class="comment"># 配置文件路径</span></span></span></span><br><span class="line"><span class="params"><span class="meta">    config_name=<span class="string">&#x27;config&#x27;</span>,  <span class="comment"># 配置文件名称</span></span></span></span><br><span class="line"><span class="params"><span class="meta">    version_base=<span class="string">&#x27;1.3.2&#x27;</span>  <span class="comment"># 版本号</span></span></span></span><br><span class="line"><span class="params"><span class="meta"></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">config</span>):</span><br><span class="line">    config = OmegaConf.to_container(config, resolve=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建输出目录</span></span><br><span class="line">    os.makedirs(config[<span class="string">&#x27;output_dir&#x27;</span>], exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># split_dataset() # 划分数据集</span></span><br><span class="line">    do_train(config)  <span class="comment"># 训练模型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    split_dataset()</span><br><span class="line">    check()</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-发现新的软件使用技巧"><a href="#2-发现新的软件使用技巧" class="headerlink" title="2. 发现新的软件使用技巧"></a>2. 发现新的软件使用技巧</h2><p><code>Typora</code> 软件可以打开控制台，本质上和浏览器没有区别，只是一个套壳的浏览器而已</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blogimage-20230901014434093.png" alt="image-20230901014434093"></p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blogimage-20230901014452319.png" alt="image-20230901014452319"></p>
<h2 id="3-错误解决"><a href="#3-错误解决" class="headerlink" title="3. 错误解决"></a>3. 错误解决</h2><p>错误提示：<code>TypeError: TextEncodeInput must be Union[TextInputSequence,Tupele[InputSequence, InputSequence]]</code></p>
<p>问题原因：数据集中存在空值或者 <code>nan</code></p>
<p>解决方案：处理数据时，删除数据中的空值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">split_dataset</span>(<span class="params">data_path: <span class="built_in">str</span> = <span class="string">&quot;data/data.csv&quot;</span>, ratio=<span class="number">0.8</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        划分数据集</span></span><br><span class="line"><span class="string">        :param ratio: 划分比例</span></span><br><span class="line"><span class="string">        :param data_path: 数据集路径</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 读取文件</span></span><br><span class="line">    data = pd.read_csv(data_path, encoding=<span class="string">&#x27;GBK&#x27;</span>, names=[<span class="string">&#x27;text&#x27;</span>, <span class="string">&#x27;label&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># here</span></span><br><span class="line">    data.dropna(axis=<span class="number">0</span>, inplace=<span class="literal">True</span>)  <span class="comment"># 删除空行</span></span><br><span class="line">    data.dropna(axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)  <span class="comment"># 删除空行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 划分数据集</span></span><br><span class="line">    train_data = data.sample(frac=ratio, random_state=<span class="number">0</span>, axis=<span class="number">0</span>)</span><br><span class="line">    valid_data = data.drop(train_data.index)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;数据集大小：<span class="subst">&#123;data.shape[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;训练集大小：<span class="subst">&#123;train_data.shape[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;验证集大小：<span class="subst">&#123;valid_data.shape[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存数据集</span></span><br><span class="line">    train_data.to_csv(<span class="string">&quot;data/train.csv&quot;</span>, columns=[<span class="string">&quot;text&quot;</span>, <span class="string">&quot;label&quot;</span>], index=<span class="literal">False</span>, encoding=<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line">    valid_data.to_csv(<span class="string">&quot;data/valid.csv&quot;</span>, columns=[<span class="string">&quot;text&quot;</span>, <span class="string">&quot;label&quot;</span>], index=<span class="literal">False</span>, encoding=<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>【2023-10-25 组会分享】大语言模型综述</title>
    <url>//2023/10/25/1%202023-10-25%20%E7%BB%84%E4%BC%9A%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h1 id="大语言模型综述A-Survey-of-Large-Language-Models"><a href="#大语言模型综述A-Survey-of-Large-Language-Models" class="headerlink" title="大语言模型综述A Survey of Large Language Models"></a>大语言模型综述<br/><span style='text-align: center; font-size: 16px;'>A Survey of Large Language Models</span ></h1><blockquote>
<p>文章基本信息如下</p>
<ul>
<li>文章名字：A Survey of Large Language Models</li>
<li>发表时间：2023年3月</li>
<li>发表期刊：arxiv(预印版)</li>
<li>发表机构：<a href="http://aibox.ruc.edu.cn/">中国人民大学 - AI Box小组 (ruc.edu.cn)</a></li>
</ul>
</blockquote>
<h2 id="0-摘要-Abstract"><a href="#0-摘要-Abstract" class="headerlink" title="0 摘要 (Abstract)"></a>0 摘要 <span style='font-size: 14px;'>(Abstract)</span></h2><blockquote>
<p><strong>时代背景：</strong></p>
<ol>
<li>自从20世纪50年代图灵测试被提出以来，人类一直在探索如何用机器掌握语言智能。</li>
<li>近年来，通过在大规模语料库上对Transformer 模型进行预训练，人们提出了预训练语言模型（Pre-training Language Model, PLM），其在解决各种自然语言处理（Natural Language Processing, NLP）任务方面表现出强大的能力。</li>
<li>近年来，学术界和工业界极大地 推进了针对LLM的研究，其中一个显著的进展是推出了ChatGPT（一种基于LLM开发的强大AI聊天机器人），它引起了社会的广泛 关注。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>研究发现：</strong></p>
<ol>
<li>研究人员发现扩展模型规模可以提高模型能力，因此他们通过将参数增加到更大的 尺寸来进一步研究该效应。</li>
<li>有趣的是，当参数规模超过一定水平时，这些规模更大的语言模型的性能不仅得到了显著提升，而且还表现出 一些小规模语言模型（例如BERT）所不具备的特殊能力（例如上下文学习）。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>文章讲了什么？</strong></p>
<ol>
<li>通过介绍大语言模型(large Language Model)的背景、主要发现和主流技术来回顾近年来的进展。</li>
<li>主要关注大语言模型(large Language Model)以下四个主要方面：①预训练，②适配微调，③使用，④能力评估</li>
<li>总结了开发LLM的可用资源，并讨论了LLM现有的问题和未来的发展方向。</li>
<li>提供了关于 LLM 的最新文献综述。</li>
</ol>
</blockquote>
<h2 id="1-大语言模型近年来的发展"><a href="#1-大语言模型近年来的发展" class="headerlink" title="1 大语言模型近年来的发展"></a>1 大语言模型近年来的发展</h2><h3 id="1-1-大语言模型的背景"><a href="#1-1-大语言模型的背景" class="headerlink" title="1.1 大语言模型的背景"></a>1.1 大语言模型的背景</h3><blockquote>
<p>自从20世纪50年代图灵测试被提出以来，人类一直在探索如何用机器掌握语言智能。机器除非配备了强大的人工智能算法，否则不能自然地掌握以人类语言形式理解和交流的能力。实现让机器像人类一样阅读、写作和交流的目标， 一直是一个长期的研究挑战。作为一种主要的语言理解和生成方法，语言建模在过去的二十年中得到了广泛的研究，并从<strong>统计语言模型</strong>逐步发展为<strong>神经语言模型</strong>。</p>
</blockquote>
<h4 id="1-1-1-语言建模的四个主要发展阶段："><a href="#1-1-1-语言建模的四个主要发展阶段：" class="headerlink" title="1.1.1 语言建模的四个主要发展阶段："></a>1.1.1 语言建模的四个主要发展阶段：</h4><ol>
<li><strong>统计语言模型(SLM)</strong><ul>
<li>20世纪90年代，学术界对于统计语言模型(SLM)的研究开始兴起。</li>
<li>统计语言模型(SLM)基于统计学习方法开发，其基本思想是基于马尔可夫假设建立词预测模型，例如根据最近的上下文预测下一个词。</li>
<li>具有固定上下文长度n的统计语言模型(SLM)也称为n元语言模型，例如 bi-gram 和 tri-gram 语言模型。<ul>
<li>bi-gram语言模型：当前词出现的概率只与上一个词出现的概率相关</li>
<li>tri-gram语言模型：当前词出现的概率只与上两个词出现的概率相关</li>
</ul>
</li>
<li>统计语言模型(SLM)已被广泛应用于提高信息检索（IR）和自然语言处理（NLP）的任务性能。</li>
</ul>
</li>
<li><strong>神经语言模型(NLM)</strong><ol>
<li>神经语言模型(NLM)通过神经网络， 如循环神经网络（RNN），来描述单词序列的概率。</li>
<li>word2vec提出了构建一个简化的浅层神经网络来学习分布式单词表示的方法，这些表示在各种 NLP 任务中被证明非常有效。</li>
<li>这些研究开创了将语言模型用于表示学习（超越词序列建模）的应用，对NLP领域产生了 重要影响。</li>
</ol>
</li>
<li><strong>预训练语言模型(PLM)</strong><ol>
<li>ELMo被提出来通过预训练一个双向LSTM（bi-LSTM）网络来捕捉上下文感知的词表示，然后根据 特定的下游任务微调bi-LSTM网络。</li>
<li>基于自注意力机制的高度并行化Transformer架构，BERT作为双向语言模型，在大规模无标签语料库上使用专门设计的预训练任务。这些预训练的上下文感知词表示作为通用语义特征非常有效，其极大地提高了NLP任务的性能。</li>
</ol>
</li>
<li><strong>大语言模型(LLM)</strong><ol>
<li>扩展PLM（例如 扩展模型大小或数据大小）通常会提高下游任务的模型性能。许多研究通过训练越来越大的PLM （例如175B参数的GPT-3，40B参数的PaLM和2200B参数的GPT4）来探索性能极限。</li>
<li>尽管扩展主要在模型大小方面进行（使用类似的架构和预训练任务），但这些大规模的PLM与较小的PLM （例如0.3B参数的BERT和1.5B参数的GPT-2）表现出不同的行为，并在解决一系列复杂任务中展示了惊人的能力（称 为涌现能力）。例如，GPT-3可以通过上下文学习（in-context learning, ICL）来解决小样本任务，而GPT-2则表现不佳。</li>
</ol>
</li>
</ol>
<h4 id="1-1-2-研究热度统计："><a href="#1-1-2-研究热度统计：" class="headerlink" title="1.1.2 研究热度统计："></a>1.1.2 研究热度统计：</h4><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/arxiv_llms.png" alt="arxiv_llms" style="zoom:100%;" />

<blockquote>
<ul>
<li> (a)图显示了包含关键词<code>Language Model</code>的arXiv文章累计数量统计（自2018年6月起）</li>
<li> (b)图显示了包含关键词<code>Large Language Model</code>的arXiv文章累计数量统计（自2019年10月起）</li>
</ul>
<p>通过按月份查询标题或摘要中的关键词，使用精确匹配计算统计数据。(b)图中可以看出，ChatGPT发布后急剧在标题或摘要中包含“大型语言模型”的已发表arXiv论文的平均数量增加，从每天0.40篇增加到每天8.58篇</p>
</blockquote>
<h3 id="1-2-主要发现"><a href="#1-2-主要发现" class="headerlink" title="1.2 主要发现"></a>1.2 主要发现</h3><blockquote>
<p>问题一：多大的模型才能算是大语言模型呢？</p>
</blockquote>
<ul>
<li>Bing AI：The definition of “large” is fuzzy, but “large” has been used to describe BERT (110M parameters) as well as PaLM 2 (up to 340B parameters. Parameters are the weights the model learned during training, used to predict the next token in the sequence.</li>
<li>wikipedia：大语言模型 (英语：large language model，LLM) 是一种语言模型，由具有许多参数（通常数十亿个权重或更多）的人工神经网络组成，使用自监督学习或半监督学习对大量未标记文本进行训练。大型语言模型在2018年左右出现，并在各种任务中表现出色。</li>
<li><strong>本综述的观点：</strong>大语言模型是指包含数千亿（或更多）参数的Transformer语言模型，这些模型是在大规模文本数据上进行训练的，例如GPT-3，PaLM，Galactica 和 LLaMA。</li>
<li><strong>我的理解：</strong><ul>
<li>通过上面的回答我们可以看出，现在的研究中并没有对于多大的模型才能算作大语言模型有一个确切的定义。通常大语言模型一般拥有数十亿或者更多的参数。</li>
<li>对于本综述的观点我并不是非常的认可。因为我们知道 LLaMA 2 拥有三个版本，参数量分别是7B、13B和70B，没有达到综述中的千亿参数的规模，但是 LLaMA 2 还是被大家公认为是一个预训练的大语言模型。</li>
</ul>
</li>
</ul>
<blockquote>
<p>问题二：LLM和PLM有什么区别呢？</p>
</blockquote>
<ol>
<li>LLM表现出一些令人惊讶的涌现能力，这些能力可能在以前较小的PLM中没有观察到。这些能力是LM在复杂任务上表现的关键，它使得人工智能算法具有前所未有的强大和有效性。</li>
<li>LLM将彻底改变人类开发和使用人工智能算法的方式。与小型PLM不同，访问LLM的主要方法是通过提示接口（例如GPT-4API）。人们必须了解LLM 的工作原理，并以LLM能够遵循的方式形式化他们的任务。</li>
<li>LLM的发展不再明确区分研究和工程。训练LLM需要在大规模数据处理和分布式并行训练方面具有丰富的实践经验。为了开发出有能力的LLM，研究人员必须解决复杂的工程问题，他们需要与工程师合作或成为工程师。</li>
</ol>
<p><strong>我的理解：</strong></p>
<ul>
<li><p>大语言模型(LLM)指的是的参数量非常庞大的语言模型，而预训练语言模型(PLM)指的是在一些通用的语料库上预先训练过的语言模型。</p>
</li>
<li><p>例如：前面提到的“ELMo被提出来通过预训练一个双向LSTM（bi-LSTM）”，它是预训练语言模型(PLM)但是不能算作大语言模型(LLM)，因为它的参数量没有达到大语言模型的标准(虽然这个标准很模糊)，但是它在一些语料库中进行过训练，所以能够称为预训练语言模型(PLM)。</p>
</li>
<li><p>所以，大语言模型(LLM)和预训练语言模型(PLM)之间存在交集，但不是被包含与包含的关系</p>
<img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20231022212643140.png" alt="image-20231022212643140" style="zoom:100%;" />



</li>
</ul>
<h3 id="1-3-大语言模型的扩展法则"><a href="#1-3-大语言模型的扩展法则" class="headerlink" title="1.3 大语言模型的扩展法则"></a>1.3 大语言模型的扩展法则</h3><h4 id="1-3-1-KM扩展法则"><a href="#1-3-1-KM扩展法则" class="headerlink" title="1.3.1 KM扩展法则"></a>1.3.1 KM扩展法则</h4><ol>
<li><p>Kaplan 等人（OpenAI 团队）于2023年首次提出了神经语言模型的性能与模型规模（N）、数据集规模（D）和训练计算量（C）之间的幂律关系。</p>
</li>
<li><p>计算公式如下<br>$$<br>L(N) = \bigg(\frac{N_c}{N}\bigg)^{\alpha_N}, ~~ \alpha_N \sim 0.076, N_c \sim 8.8\times 10^{13} \<br>L(D) = \bigg(\frac{D_c}{D}\bigg)^{\alpha_D},  ~~ \alpha_D \sim 0.095, D_c \sim 5.4\times 10^{13} \<br>L(C) = \bigg(\frac{C_c}{C}\bigg)^{\alpha_C},  ~~ \alpha_C \sim 0.050, C_c \sim 3.1\times 10^{8}<br>$$</p>
</li>
<li><p>这三个规律是通过拟合模型在不同数据大小、模型大小和训练计算量下的性能得出的。结果表明，模型性能与这三个因素存在着强依赖关系。</p>
</li>
</ol>
<h4 id="1-3-2-Chinchilla-扩展法则"><a href="#1-3-2-Chinchilla-扩展法则" class="headerlink" title="1.3.2 Chinchilla 扩展法则"></a>1.3.2 Chinchilla 扩展法则</h4><ol>
<li>Hoffmann 等人（Google DeepMind 团队）提出了一种扩展法则的替代形式来指导大语言模型最优计算量的训练。</li>
<li>他们通过变化更大范围的模型大小和数据大小进行了严格的实验，并拟合了一个类似的扩展法则。</li>
</ol>
<blockquote>
<p><strong>KM扩展法则</strong>更偏向于将更大的预算分配给模型大小，而<strong>Chinchilla 扩展法则</strong>认为模型大小和数据大小应该以相同的比例增加。</p>
</blockquote>
<h3 id="1-4-大语言模型的涌现能力"><a href="#1-4-大语言模型的涌现能力" class="headerlink" title="1.4 大语言模型的涌现能力"></a>1.4 大语言模型的涌现能力</h3><blockquote>
<p><strong>大语言模型的涌现能力的定义：</strong>在小型模型中不存在但在大型模型中产生的能力</p>
<p><strong>解释：</strong>当规模达到一定水平时，性能显著提高，超出随机水平。</p>
</blockquote>
<p>大语言模型的三种典型涌现能力和具备这种能力的代表性模型：</p>
<ol>
<li>上下文学习，代表模型：GPT-3(175B的GPT-3模型在一般情况下表现出强大的上下文学习能力，但GPT-1和GPT-2模型则没有)</li>
<li> 指令遵循(指令微调)，代表模型：LaMDA-PT(当模型大小达到68B时，经过指令微调的LaMDA-PT开始在未见过的任务上显著优于未微调的模型，但对于8B或更小的模型大小则不会如此。)</li>
<li> 逐步推理，代表模型：PaLM(当思维链提示应用于模型大小大于60B的PaLM变体时，可以提高模型在算术推理基准任务上的性能，而当模型大小超过100B时，其相 对于标准提示的优势更加明显。)</li>
</ol>
<h3 id="1-5-大语言模型的关键技术"><a href="#1-5-大语言模型的关键技术" class="headerlink" title="1.5 大语言模型的关键技术"></a>1.5 大语言模型的关键技术</h3><p>大语言模型能够成功的几个可能的关键技术：</p>
<ul>
<li>扩展：Transformer语言模型存在明显的扩展效应：更大的模型，更大的数据规模和更多的训练计算通常会导致模型能力的提升。</li>
<li>训练：由于巨大的模型规模，成功训练一种能力强的大语言模型(LLM)是非常具有挑战性的。大语言模型(LLM)一般使用分布式训练，搭配一些正对行的优化策略来进行训练。</li>
<li>能力引导：大语言模型在一些特定的任务上表现并不是很好，但是可以通过一些手段引导大模型以激发这些能力。例如：通过设计合适的任务指令或具体的上下文学习(ICL)策略或者使用自然语言表达的任务描述对大语言模型(LLM)进行指令微调，以提高LLM在未见任务上的泛化能力。</li>
<li>对齐微调：由于大语言模型(LLM)被训练用来捕捉预训练语料库的数据特征，它们可能会为人类 生成有毒、偏见甚至有害的内容。因此，有必要使大语言模型(LLM)与 人类价值观保持一致，例如有用性、诚实性和无害性。</li>
<li>工具操作：大语言模型(LLM)在一些不适合以纯文本形式表达的任务上表现不佳，为了解决这些问题可以利用外部工具来弥补大语言模型(LLM)的不足。例如：GPT4已经能够使用外部插件来扩展它的能力范围。</li>
</ul>
<h3 id="1-6-大模型的发展史"><a href="#1-6-大模型的发展史" class="headerlink" title="1.6 大模型的发展史"></a>1.6 大模型的发展史</h3><h4 id="1-6-1-各种大模型的发布时间"><a href="#1-6-1-各种大模型的发布时间" class="headerlink" title="1.6.1 各种大模型的发布时间"></a>1.6.1 各种大模型的发布时间</h4><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/LLMs-0623-final.png" alt="LLMs-0623-final" style="zoom:100%;" />

<blockquote>
<p>最近几年现有的大语言模型(参数量超过10B)发布的时间。黄色标记的是具有公开可用模型检查点的大语言模型。</p>
</blockquote>
<h4 id="1-6-2-GPT-系列模型的发展"><a href="#1-6-2-GPT-系列模型的发展" class="headerlink" title="1.6.2 GPT 系列模型的发展"></a>1.6.2 GPT 系列模型的发展</h4><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/GPT%20%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%BC%94%E5%8F%98.png" alt="GPT 系列模型的演变" style="zoom:100%;" />

<blockquote>
<p>GPT 系列模型的发展史：</p>
<ul>
<li>GPT-1于2018年6月发布，是一个只有解码器架构的生成预训练语言模型。</li>
<li>GPT-2于2019年2月发布，是一个无监督多任务学习器模型。拥有4个模型版本：分别是Small(117M)，Medium(345M)，Large(762M)，Extra Large(1542M)</li>
<li>GPT-3于2020年5月发布，是一个拥有上下文学习能力的大语言模型。拥有8个模型版本，最小的参数规模为125M，最大的参数规模为175B</li>
<li>Codex于2020年7月发布，是GPT-3添加了代码生成的能力，在代码的数据集上进行了预训练。</li>
<li>GPT-3.5于2022年3月发布，是一个综合的大语言模型，拥有对话生成，文本阅读和理解等功能。参数规模为175B。</li>
<li>GPT-4于2023年3月发布，是一个多模态大模型，拥有较强的综合推理能力。</li>
</ul>
</blockquote>
<h4 id="1-6-3-LLaMA-系列模型的发展"><a href="#1-6-3-LLaMA-系列模型的发展" class="headerlink" title="1.6.3 LLaMA 系列模型的发展"></a>1.6.3 LLaMA 系列模型的发展</h4><h5 id="两张可爱的关于-LLaMA-的漫画："><a href="#两张可爱的关于-LLaMA-的漫画：" class="headerlink" title="两张可爱的关于 LLaMA 的漫画："></a><strong>两张可爱的关于 LLaMA 的漫画：</strong></h5><div align='center' style='display: flex; justify-content: center; align-items: center;'><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/a-ai-art-of-llama-family-v0-rpr9pe916xvb1.png" alt="a-ai-art-of-llama-family-v0-rpr9pe916xvb1" style="zoom:45%; margin-right: 2%" /><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/es99xs58xxvb1.jpeg" alt="CDN media" style="zoom:45%; margin-left: 2%" /></div>

<h5 id="LLaMA-的发展和演变："><a href="#LLaMA-的发展和演变：" class="headerlink" title="LLaMA 的发展和演变："></a><strong>LLaMA 的发展和演变：</strong></h5><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/LLaMA.png" alt="LLaMA" style="zoom:100%;" />

<blockquote>
<p>图中展示的是<code>LLaMA</code>的演变过程。</p>
<ul>
<li>虚线部分部分代表使用其他数据<code>继续预训练</code>，实线部分代表<code>指令微调</code></li>
<li>图中没有背景颜色的表示 <code>有效参数微调</code>，黄色背景颜色的表示 <code>全参数微调</code></li>
<li>从图中可以看出，<code>LLaMA</code> 有三个主要的分支，分别是：<ol>
<li>使用中文数据预训练后的 <code>Chinese LLaMA</code></li>
<li>使用合成数据进行微调的 <code>Alpaca</code></li>
<li>使用对话数据进行微调的 <code>Vicuna</code></li>
</ol>
</li>
<li>在这三个主要的分支的基础上，又发展出了许多其他的模型，涵盖了数学，金融，医疗，法律，双语，教育等方面。其中有很多我们耳熟能详的模型，例如：<code>MiniGPT-4</code>、<code>PandaGPT</code>、<code>TaoLi</code>等</li>
</ul>
</blockquote>
<h2 id="2-大语言模型四个主要方面"><a href="#2-大语言模型四个主要方面" class="headerlink" title="2 大语言模型四个主要方面"></a>2 大语言模型四个主要方面</h2><h3 id="2-1-预训练"><a href="#2-1-预训练" class="headerlink" title="2.1 预训练"></a>2.1 预训练</h3><h4 id="2-1-1-为什么要进行预训练？"><a href="#2-1-1-为什么要进行预训练？" class="headerlink" title="2.1.1 为什么要进行预训练？"></a>2.1.1 为什么要进行预训练？</h4><blockquote>
<p>预培训奠定了大语言模型(LLM)能力的基础。通过对大规模语料库的预训练，大语言模型(LLM)可以获得基本的语言理解和生成技能。预训练语料库的规模和质量是大语言模型(LLM)获得强大功能的关键。此外，为了有效地预训练大语言模型(LLM)，模型架构，加速方法和优化技术需要很好地设计。</p>
</blockquote>
<h4 id="2-1-2-预训练包括哪些过程？"><a href="#2-1-2-预训练包括哪些过程？" class="headerlink" title="2.1.2 预训练包括哪些过程？"></a>2.1.2 预训练包括哪些过程？</h4><blockquote>
<p>预训练通常包括：数据的收集和处理，模型的结构设计和模型训练的优化技术三个部分。不同的模型预训练可能存在一些特殊的情况，但是普遍的情况都会包含上述的三个部分。</p>
</blockquote>
<h5 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a><strong>数据预处理</strong></h5><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20231024142708636.png" alt="image-20231024142708636" style="zoom:2=100%;" />

<blockquote>
<p>上图中显示的是数据预处理的过程：</p>
<ol>
<li>原始语料(Raw Corpus)输入到质量过滤器(Quality Filtering)进行一些过滤操作，例如：语言过滤，度量过滤，统计过滤，关键词过滤等。</li>
<li>过滤后的数据输入到重复过滤器中，去除句子，文档，集合中的重复部分。</li>
<li>去重之后的数据输入到隐私过滤器中，检测并去除一些包含个人隐私的信息。</li>
<li>去除隐私后的数据输入到分词其中，得到词汇表和数据对应的向量表示。</li>
</ol>
</blockquote>
<h5 id="模型训练时各种数据来源的占比"><a href="#模型训练时各种数据来源的占比" class="headerlink" title="模型训练时各种数据来源的占比"></a><strong>模型训练时各种数据来源的占比</strong></h5><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E9%A2%84%E8%AE%AD%E7%BB%83%E8%BF%99%E7%A7%8D%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8D%A0%E6%AF%94.png" alt="大语言模型预训练这种各种数据的占比" style="zoom:100%;" />

<blockquote>
<p>上图中现实的是在预训练过程中各种数据来源的占比.</p>
<ul>
<li>图中可以看出，大部分大语言模型(LLM)都或多或少的使用了网页，书籍和新闻等数据</li>
<li>一些特殊的大语言模型(LLM)可能有针对性的使用了一些数据集进行训练或者微调</li>
</ul>
</blockquote>
<h5 id="主流的大语言模型架构"><a href="#主流的大语言模型架构" class="headerlink" title="主流的大语言模型架构"></a><strong>主流的大语言模型架构</strong></h5><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20231024144043317.png" alt="image-20231024144043317" style="zoom:100%;" />

<blockquote>
<p>主流的大语言模型的架构如上图所示，分别是：因果解码器架构，前缀解码器架构和编码器-解码器架构。</p>
<p>图中蓝色的方块表示前缀token之间的注意力，绿色的方块表示前缀token和目标token之间的注意力，黄色的方块表示目标token之间的注意力，灰色的方块表示掩码注意力。</p>
</blockquote>
<ol>
<li><strong>Encoder-Decoder架构</strong>：  普通的 Transformer 模型建立在<code>Encoder-Decoder</code>架构之上，它由两个 Transformer 块组成，分别作为编码器和解码器。编码器采用堆叠的多头自注意层对输入序列进行编码以生成其潜在表示，而解码器对这些表示进行交叉注意并自回归生成目标序列。<code>Encoder-Decoder</code>架构的预训练语言模型（例如 T5  和 BART）已在各种 NLP 任务中显示出有效性。到目前为止，只有少量的大语言模型是基于<code>Encoder-Decoder</code>架构构建的，例如 Flan-T5。</li>
<li><strong>Causal Decoder架构</strong>：<code>Causal Decoder</code>架构结合了单向注意掩码，以保证每个输入<code>token</code>只能关注过去的<code>token</code>和它自己。输入和输出<code>token</code>通过解码器以相同的方式处理。作为该架构的代表性语言模型，GPT 系列模型是基于因果解码器架构开发的。特别是，GPT-3 已经成功地证明了这种架构的有效性，也展示了大语言模型惊人的上下文学习能力。有趣的是，GPT-1 和 GPT-2 并没有表现出像 GPT-3 那样优越的能力，而且似乎缩放在增加该模型架构的模型容量方面起着重要作用。到目前为止，Causal Decoder已被各种现有的大语言模型广泛采用作为 大语言模型的体系结构，例如 OPT、BLOOM和 Gopher。请注意，接下来讨论的因果解码器和前缀解码器都属于<code>Decoder-only architecture</code>架构。而在提到<code>Decoder-only architecture</code>时，除非特别说明，否则主要指的是现有文献中的<code>Causal decoder architecture</code>。</li>
<li><strong>Prefix Decoder架构</strong>（又名，非因果解码器）修改了<code>Causal Decoder</code>的掩码机制，以实现对前缀<code>token</code>的双向关注和仅对生成的<code>token</code>的单向关注。这样，与<code>Encoder-Decoder</code>架构一样，前缀解码器可以对前缀序列进行双向编码，并自回归地逐个预测输出<code>token</code>，其中在编码和解码期间共享相同的参数。与其从头开始预训练，一个实用的建议是不断训练因果解码器，然后将它们转换为前缀解码器以加速收敛，例如，U-PaLM 源自 PaLM。现有的基于前缀解码器的代表性 LLM 包括 ChatGLM和 U-PaLM。</li>
</ol>
<div align='center' style='display: flex; justify-content: center; align-items: center;'><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/v2-0af88beb0cc280317e06b24c2582eb60_720w.webp" alt="img" style="zoom:50%; margin-right: 2%" /><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/eac4b74543a982263a2cf99edf6977044890eb88.jpeg@f_auto" alt="img" style="zoom:50%; margin-left: 2%" /></div>

<h3 id="2-2-适配微调"><a href="#2-2-适配微调" class="headerlink" title="2.2 适配微调"></a>2.2 适配微调</h3><blockquote>
<p>大语言模型(LLM)可以获得解决各种任务的通用能力，但是研究表明，可以通过进一步的适配是的大模型能够更好的解决特定的问题。</p>
<p>综述中主要谈及了两种常见的大语言模型的微调方法，分别是指令微调(instruction tuning)和对齐微调(alignment tuning)</p>
</blockquote>
<h4 id="2-2-1-指令微调-instruction-tuning"><a href="#2-2-1-指令微调-instruction-tuning" class="headerlink" title="2.2.1 指令微调(instruction tuning)"></a>2.2.1 指令微调(instruction tuning)</h4><blockquote>
<p>指令微调是在自然语言格式的实例集合上微调预训练后的LLM的方法。这种发方法与有监督微调和多任务提示训练密切相关，旨在增强（或解锁） LLM的能力。</p>
</blockquote>
<h4 id="2-2-2-对齐微调-alignment-tuning"><a href="#2-2-2-对齐微调-alignment-tuning" class="headerlink" title="2.2.2 对齐微调(alignment tuning)"></a>2.2.2 对齐微调(alignment tuning)</h4><blockquote>
<p>对齐微调旨在将LLM的行为与人类的价值观或偏好对齐。减少大语言模型生成一些有毒，有攻击性，有种族或者性别歧视等多种有悖于人类价值观的结果。</p>
</blockquote>
<h3 id="2-3-使用"><a href="#2-3-使用" class="headerlink" title="2.3 使用"></a>2.3 使用</h3><blockquote>
<p>经过预训练或适配微调之后，使用LLM的主要方法是为解决各种任务设计适当的提示策略。本综述介绍了两种典型的提示策略，分别是：上下文学习(in-contextlearning, ICL)和思维链提示(chain-of-thought prompting)。</p>
</blockquote>
<h4 id="2-3-1-上下文学习-in-context-learning-ICL"><a href="#2-3-1-上下文学习-in-context-learning-ICL" class="headerlink" title="2.3.1 上下文学习(in-context learning, ICL)"></a>2.3.1 上下文学习(in-context learning, ICL)</h4><blockquote>
<p>上下文学习(ICL)是典型的提示方法是将任务描述以自然语言文本的形式表达的上下文学习。上下文学习(ICL)使用一种由任务描述和作为示范的几个任务样例构成的自然语言提示。</p>
<p><strong>我的理解：</strong>简单来说，上下文学习(ICL)就是给一段上下文，然后给一个问题，让大模型回答这个问题。没有中间的推理过程，只是回答给出的问题。</p>
</blockquote>
<h4 id="2-3-2-思维链提示-chain-of-thought-prompting"><a href="#2-3-2-思维链提示-chain-of-thought-prompting" class="headerlink" title="2.3.2 思维链提示(chain-of-thought prompting)"></a>2.3.2 思维链提示(chain-of-thought prompting)</h4><blockquote>
<p>思维链提示(chain-of-thought prompting)可以通过将一系列中间推理步骤加入提示中来增强上下文学习(ICL)。</p>
<p>思维链(CoT)是一种改进的提示策略，旨在提高大语言模型(LLM)在复杂推理任务中的性能，例如算术推理，常识推理和符号推理。</p>
<p>不同于上下文学习(ICL)中仅使用输入输出对来构造提示，思维链(CoT)将可以导出最终输出的中间推理步骤纳入提示中。</p>
<p><strong>我的理解：</strong>思维链提示(chain-of-thought prompting)是一种特殊的上下文学习(ICL)。思维链将中间的推理过程也用于提示，可以提高大语言模型在复杂推理任务中的性能。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%80%9D%E7%BB%B4%E9%93%BE%E6%8F%90%E7%A4%BA.png" alt="上下文学习和思维链提示" style="zoom:100%;" />

<blockquote>
<p>上下文学习（ICL）和思维链（CoT）提示的比较说明。ICL用自然语言描述、几个演示和一个测试查询来提示LLM，而CoT提示涉及提示中的一系列中间推理步骤。</p>
<ol>
<li>绿色部分表示任务的描述</li>
<li>浅蓝色部分表示问题的示例</li>
<li>蓝色部分表示中间推理的步骤(思维链)</li>
<li>黄色部分表示需要回答的问题</li>
</ol>
</blockquote>
<h3 id="2-4-能力评估"><a href="#2-4-能力评估" class="headerlink" title="2.4 能力评估"></a>2.4 能力评估</h3><blockquote>
<p>为了检验LLM的有效性和优越性，已有研究采用了大量的任 务和基准数据集来进行实证评估和分析。综述中介绍了大语言模型(LLM)在<code>语言生成</code>和<code>语言理解</code>方面的三种基本评估任务。</p>
</blockquote>
<h4 id="2-4-1-语言生成"><a href="#2-4-1-语言生成" class="headerlink" title="2.4.1 语言生成"></a>2.4.1 语言生成</h4><blockquote>
<p>现有语言生成的任务主要可以分为语言建模、 条件文本生成和代码合成任务。需要注意的是，代码合成不 是典型的自然语言处理任务，但可以直接地用（经过代码数 据训练的）LLM以类似自然语言文本生成的方法解决。</p>
<ol>
<li>语言建模：语言建模是大语言模型(LLM)的基本能力，旨在基于前一个 token 预测下一个 token，主要关注基本的语言理解和生 成能力。</li>
<li>条件文本生成：条件文本生成旨在基于给定的条件生成满足特定任务需求的文本， 通常包括机器翻译、文本摘要和问答系统等。</li>
<li>代码合成：除了生成高质量的自然语言外，现有的大语言模型(LLM)还表现出强大的生成形式语言的能力，尤其是满足特定条件的计算机程序，这种能力被称为代码合成。</li>
</ol>
</blockquote>
<h4 id="2-4-2-知识利用"><a href="#2-4-2-知识利用" class="headerlink" title="2.4.2 知识利用"></a>2.4.2 知识利用</h4><blockquote>
<p>知识利用是一种智能系统基于事实证据的支撑，完成知识密集型任务的重要能力（例如常识问题回答和事实补全）。具体而言，它要求大语言模型(LLM)适当地利用来自预训练语料库的丰富事实知识，或在必要的时候检索外部数据。现有的知识利用任务分为三种类型，即闭卷问答，开卷问答和知识补全。</p>
<ol>
<li>闭卷问答：闭卷问答任务测试大语言模型(LLM)从预训练语料库中习得的事实知识。大语言模型(LLM)只能基于给定的上下文回答问题， 而不能使用外部资源。</li>
<li>开卷问答：与闭卷问答不同，在开卷问答任务中，大语言模型大语言模型(LLM)可以从外部知识库或文档集合中提取有用的证据，然后基于提取的证据回答问题。</li>
<li>知识补全：在知识补全任务中，大语言模型(LLM)可以被视为一个知识库，补全或预测知识单元的缺失部分。这种任务可以探索和评估大语言模型(LLM)从预训 练数据中学习到的知识的数量和种类。</li>
</ol>
</blockquote>
<h4 id="2-4-3-复杂推理"><a href="#2-4-3-复杂推理" class="headerlink" title="2.4.3 复杂推理"></a>2.4.3 复杂推理</h4><blockquote>
<p>复杂推理是指理解和利用相关的证据或逻辑来推导结论或做出决策的能力。根据推理过程中涉及的逻辑和证据类型，我们考虑将现有的评估任务分为三个主要类别，即知识推理、符号推理和数学推理。</p>
<ol>
<li>知识推理：知识推理任务依赖于逻辑关系和事实知识的证据来回答给定的问题。</li>
<li>符号推理：符号推理任务主要关注于在形式化规则设定中操作符号以实现某些特定目标，且这些操作和规则可能在大语言模型(LLM)预训练期间从未被看到过。</li>
<li>数学推理：数学推理任务需要综合利用数学知识、逻辑和计算来解决问题或生成证明过程。</li>
</ol>
</blockquote>
<p>大语言模型(LLM)的基础评测任务和相应的代表性数据集</p>
<table>
  <tr>
    <th>Level</th>
    <th>Ability</th>
    <th>Task</th>
    <th>Dataset</th>
  </tr>
  <tr>
    <td rowspan="9">Basic</td>
    <td rowspan="3">Language Generation</td>
    <td>Language Modeling</td>
    <td>Penn Treebank, WikiText-103, the Pile, LAMBADA</td>
  </tr>
  <tr>
    <td>Conditional Text Generation</td>
    <td>
      WMT’14,16,19,20,21,22, Flores-101, DiaBLa, CNN/DailyMail, XSum, WikiLingua
      OpenDialKG
    </td>
  </tr>
  <tr>
    <td>Code Synthesis</td>
    <td>APPS, HumanEval, MBPP, CodeContest, MTPB, DS-1000, ODEX</td>
  </tr>
  <tr>
    <td rowspan="3">Knowledge Utilization</td>
    <td>Closed-Book QA</td>
    <td>
      Natural Questions, ARC, TruthfulQA, Web Questions, TriviaQA, PIQA,
      LC-quad2.0, GrailQA, KQApro, CWQ, MKQA, ScienceQA
    </td>
  </tr>
  <tr>
    <td>Open-Book QA</td>
    <td>
      Natural Questions, OpenBookQA, ARC, TriviaQA, Web Questions, MS MARCO,
      QASC, SQuAD, WikiMovies
    </td>
  </tr>
  <tr>
    <td>Knowledge Completion</td>
    <td>WikiFact, FB15k-237, Freebase, WN18RR, WordNet, LAMA, YAGO3-10,YAGO</td>
  </tr>
  <tr>
    <td rowspan="3">Complex Reasoning</td>
    <td>Knowledge Reasoning</td>
    <td>
      CSQA, StrategyQA, HotpotQA, ARC, BoolQ, PIQA, SIQA, HellaSwag, WinoGrande,
      COPA, OpenBookQA, ScienceQA, proScript, ProPara, ExplaGraphs, ProofWriter,
      EntailmentBank, ProOntoQA
    </td>
  </tr>
  <tr>
    <td>Symbolic Reasoning</td>
    <td>
      CoinFlip, ReverseList, LastLetter, Boolean Assignment, Parity, Colored
      Object, Penguins in a Table, Repeat Copy, Object Counting
    </td>
  </tr>
  <tr>
    <td>Mathematical Reasoning</td>
    <td>
      MATH, GSM8k, SVAMP, MultiArith, ASDiv, MathQA, AQUA-RAT, MAWPS, DROP,
      NaturalProofs, PISA, miniF2F, ProofNet
    </td>
  </tr>
  <tr>
    <td rowspan="11">Advanced</td>
    <td rowspan="3">Human Alignment</td>
    <td>Honestness</td>
    <td>TruthfulQA, HaluEval</td>
  </tr>
  <tr>
    <td>Helpfulness</td>
    <td>HH-RLHF</td>
  </tr>
  <tr>
    <td>Harmlessness</td>
    <td>HH-RLHF, Crows-Pairs WinoGender, RealToxicityPrompts</td>
  </tr>
  <tr>
    <td rowspan="3">Interaction with External Environment</td>
    <td>Household</td>
    <td>VirtualHome, BEHAVIOR, ALFRED ,ALFWorld</td>
  </tr>
  <tr>
    <td>Website Environment</td>
    <td>WebShop, Mind2Web</td>
  </tr>
  <tr>
    <td>Open World</td>
    <td>MineRL, MineDojo</td>
  </tr>
  <tr>
    <td rowspan="5">Tool Manipulation</td>
    <td>Search Engine</td>
    <td>HotpotQA, TriviaQA, Natural Questions</td>
  </tr>
  <tr>
    <td>Code Executor</td>
    <td>GSM8k, TabMWP, Date Understanding</td>
  </tr>
  <tr>
    <td>Calculator</td>
    <td>GSM8k, MATH, CARP</td>
  </tr>
  <tr>
    <td>Model Interface</td>
    <td>GPT4Tools, Gorilla</td>
  </tr>
  <tr>
    <td>Data Interface</td>
    <td>WebQSP, MetaQA, WTQ WikiSQL, TabFact, Spider</td>
  </tr>
</table>


<h2 id="3-总结与未来方向"><a href="#3-总结与未来方向" class="headerlink" title="3 总结与未来方向"></a>3 总结与未来方向</h2><h3 id="3-1-总结"><a href="#3-1-总结" class="headerlink" title="3.1 总结"></a>3.1 总结</h3><p>本文的主要贡献：</p>
<ol>
<li>本文综述了大语言模型(LLM)的最新进展，并介绍了大语言模型(LLM)的主要概念、研究成果以及理解和利用大语言模型(LLM)的技术。</li>
<li>本文主要介绍了大小超过10B的大语言模型，没有考虑早期的预训练语言模型，例如：Bert、GPT-2等。</li>
<li>本文讨论了大语言模型(LLM)的四个重要方面，分别是：预训练、适配微调、使用和能力评估。</li>
<li>本文总结了开发大语言模型(LLM)的可用资源，并讨论了实现大语言模型(LLM)的重要技术以便复现大语言模型(LLM)。</li>
<li>本文的目标是涵盖关于大语言模型(LLM)的最新文献，并为研究人员和工程师提供一份有关这个主题的优质参考资料。</li>
</ol>
<h3 id="3-2-未来方向"><a href="#3-2-未来方向" class="headerlink" title="3.2 未来方向"></a>3.2 未来方向</h3><p>本文最后在一下几个方面，介绍了大语言模型(LLM)的挑战和未来方向：</p>
<ol>
<li>理论和原理：<ul>
<li>挑战：<ul>
<li>大语言模型(LLM)的运行机制目前还不是非常的明朗，例如：大模型的涌现能力出现的原因。</li>
<li>大语言模型(LLM)如何通过非常大且深的神经网络分配、组织和利用信息。</li>
<li>理解、描述和解释大语言模型(LLM)的能力或行为的正式理论和原理仍然缺失。</li>
</ul>
</li>
<li>未来方向：<ul>
<li>对于大语言模型(LLM)的涌现能力的解释和研究。</li>
<li>对于大语言模型(LLM)对于信息的利用、分配、组织方式进行研究。</li>
<li>建立和完善理解、描述和解释大语言模型(LLM)的能力或行为的理论和原理。</li>
</ul>
</li>
</ul>
</li>
<li>模型架构：<ul>
<li>挑战：<ul>
<li>减少标准自注意力机制所带来的时间复杂度是一个实际应用时重要的考虑因素。</li>
<li><code>灾难性遗忘</code>一直是神经网络的长期挑战，其对大语言模型(LLM)也有负面影响。</li>
</ul>
</li>
<li>未来方向：<ul>
<li>研究如何构建大语言模型(LLM)中更高效的<code>Transformer</code>变体十分重要，例如 GPT-3 中已经使用了<code>稀疏注意力</code>。</li>
<li>考虑将现有架构扩展到更具灵活性的机制或模块，以有效支持数据更新和任务专用化。</li>
</ul>
</li>
</ul>
</li>
<li>模型训练：<ul>
<li>挑战：<ul>
<li>预训练强大的大语言模型(LLM)需要消耗巨大的算力，并且对<code>数据质量</code>和<code>训练技巧</code>要求很高。</li>
</ul>
</li>
<li>未来方向：<ul>
<li>开发更系统、经济的预训练方法以优化大语言模型(LLM)变得尤为重要，同时考虑到模型有效性、效率优化和训练稳定性等因素。</li>
</ul>
</li>
</ul>
</li>
<li>模型应用：<ul>
<li>挑战：<ul>
<li>由于在实际应用中微调的成本非常高，提示已成 为使用大语言模型(LLM)的主要方法，但是提示设计时需要大量人力。</li>
<li>一些复杂任务（例如形式证明和数值计算）需要特定的知识或逻辑规则，这些规则可能无法用自然语言很好地表达或通过示例演示。</li>
</ul>
</li>
<li>未来方向：<ul>
<li>研究如何自动生成有用且高校的提示以解决各种任务。</li>
<li>开发更具信息量和灵活性的任务格式化方法以进行提示非常重要。</li>
</ul>
</li>
</ul>
</li>
<li>安全与对齐：<ul>
<li>挑战：<ul>
<li>大语言模型(LLM)倾向于产生幻觉， 这些文本看似合理，但可能在事实上是错误的。例如：ChatGPT 刚发布的时候存在&quot;一本正经的胡说八道&quot;的情况。</li>
<li>现有的方法避免大语言模型(LLM)产生幻觉或者生成一些有毒，有害，有偏见的文本主要是讲人工纳入训练循环 来开发良好对齐的大语言模型(LLM)，并使用人类反馈强化学习(RLHF)。但是这严重依赖专业标注者的高质量人类反馈数据，这使得它在实践中难以适当实施。</li>
</ul>
</li>
<li>未来方向：<ul>
<li>研究如何避免大语言模型(LLM)产生幻觉或者生成一些有毒，有害，有偏见的文本。</li>
<li>有必要改进人类反馈强化学习(RLHF)框架以减少人类标注者的工作量，并寻求更高效的、具有保证数据质量的标注方法，例如LLM可以用于辅助标注工作。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="4-关于大语言模型的最新文献综述"><a href="#4-关于大语言模型的最新文献综述" class="headerlink" title="4 关于大语言模型的最新文献综述"></a>4 关于大语言模型的最新文献综述</h2><h3 id="4-1-大语言模型列表："><a href="#4-1-大语言模型列表：" class="headerlink" title="4.1 大语言模型列表："></a>4.1 大语言模型列表：</h3><table class="tg">
<thead>
  <tr>
    <th class="tg-nrix" align="center" rowspan="2">分类</th>
    <th class="tg-baqh" align="center" rowspan="2">模型</th>
    <th class="tg-0lax" align="center" rowspan="2">发表时间</th>
    <th class="tg-baqh" align="center" rowspan="2">大小(B)</th>
    <th class="tg-0lax" align="center" rowspan="2">链接</th>
  </tr>
  <tr>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-nrix" align="center" rowspan="25">开源<br/>大模型</td>
    <td class="tg-baqh" align="center">T5</td>
    <td class="tg-0lax" align="center">2019/10</td>
    <td class="tg-baqh" align="center">11</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/1910.10683">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">mT5</td>
    <td class="tg-0lax" align="center">2021/03</td>
    <td class="tg-baqh" align="center">13</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2010.11934">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">PanGu-α</td>
    <td class="tg-0lax" align="center">2021/05</td>
    <td class="tg-baqh" align="center">13</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2104.12369">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">CPM-2</td>
    <td class="tg-0lax" align="center">2021/05</td>
    <td class="tg-baqh" align="center">198</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2106.10715">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">T0</td>
    <td class="tg-0lax" align="center">2021/10</td>
    <td class="tg-baqh" align="center">11</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2110.08207">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">GPT-NeoX-20B</td>
    <td class="tg-0lax" align="center">2022/02</td>
    <td class="tg-baqh" align="center">20</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2204.06745">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">CodeGen</td>
    <td class="tg-0lax" align="center">2022/03</td>
    <td class="tg-baqh" align="center">16</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2203.13474">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">Tk-Instruct</td>
    <td class="tg-0lax" align="center">2022/04</td>
    <td class="tg-baqh" align="center" align="center">11</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2204.07705">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">UL2</td>
    <td class="tg-0lax" align="center">2022/02</td>
    <td class="tg-baqh" align="center">20</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2205.05131">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">OPT</td>
    <td class="tg-0lax" align="center">2022/05</td>
    <td class="tg-baqh" align="center">175</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2205.01068">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">YaLM</td>
    <td class="tg-0lax" align="center">2022/06</td>
    <td class="tg-baqh" align="center">100</td>
    <td class="tg-0lax" align="center"><a href="https://github.com/yandex/YaLM-100B">GitHub</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">NLLB</td>
    <td class="tg-0lax" align="center">2022/07</td>
    <td class="tg-baqh" align="center">55</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2207.04672">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">BLOOM</td>
    <td class="tg-0lax" align="center">2022/07</td>
    <td class="tg-baqh" align="center">176</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2211.05100">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">GLM</td>
    <td class="tg-0lax" align="center">2022/08</td>
    <td class="tg-baqh" align="center">130</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2210.02414">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">Flan-T5</td>
    <td class="tg-0lax" align="center">2022/10</td>
    <td class="tg-baqh" align="center">11</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2210.11416">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">mT0</td>
    <td class="tg-0lax" align="center">2022/11</td>
    <td class="tg-baqh" align="center">13</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2211.01786">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">Galatica</td>
    <td class="tg-0lax" align="center" align="center" align="center">2022/11</td>
    <td class="tg-baqh" align="center" align="center">120</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2211.09085">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">BLOOMZ</td>
    <td class="tg-0lax" align="center">2022/11</td>
    <td class="tg-baqh" align="center">176</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2211.01786">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">OPT-IML</td>
    <td class="tg-0lax" align="center">2022/12</td>
    <td class="tg-baqh" align="center">175</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2212.12017">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">Pythia</td>
    <td class="tg-0lax" align="center">2023/01</td>
    <td class="tg-baqh" align="center">12</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2304.01373">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">LLaMA</td>
    <td class="tg-0lax" align="center">2023/02</td>
    <td class="tg-baqh" align="center">65</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2302.13971v1">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">Vicuna</td>
    <td class="tg-0lax" align="center">2023/03</td>
    <td class="tg-baqh" align="center">13</td>
    <td class="tg-0lax" align="center"><a href="https://lmsys.org/blog/2023-03-30-vicuna/">Blog</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">ChatGLM</td>
    <td class="tg-0lax" align="center">2023/03</td>
    <td class="tg-baqh" align="center">6</td>
    <td class="tg-0lax" align="center"><a href="https://github.com/THUDM/ChatGLM-6B">GitHub</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">CodeGeeX</td>
    <td class="tg-0lax" align="center">2023/03</td>
    <td class="tg-baqh" align="center">13</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2303.17568">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">Koala</td>
    <td class="tg-0lax" align="center">2023/04</td>
    <td class="tg-baqh" align="center">13</td>
    <td class="tg-0lax" align="center"><a href="https://bair.berkeley.edu/blog/2023/04/03/koala/">Blog</a></td>
  </tr>
  <tr>
    <td class="tg-nrix" align="center" rowspan="31">不开源<br />大模型</td>
    <td class="tg-baqh" align="center">GShard</td>
    <td class="tg-0lax" align="center">2020/01</td>
    <td class="tg-baqh" align="center" align="center">600</td>
    <td class="tg-0lax" align="center"><a href="http://arxiv.org/abs/2006.16668v1">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">GPT-3</td>
    <td class="tg-0lax" align="center">2020/05</td>
    <td class="tg-baqh" align="center">175</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2005.14165">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">LaMDA</td>
    <td class="tg-0lax" align="center">2021/05</td>
    <td class="tg-baqh" align="center">137</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2201.08239">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">HyperCLOVA</td>
    <td class="tg-0lax" align="center">2021/06</td>
    <td class="tg-baqh" align="center">82</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2109.04650">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">Codex</td>
    <td class="tg-0lax" align="center">2021/07</td>
    <td class="tg-baqh" align="center">12</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2107.03374">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">ERNIE 3.0</td>
    <td class="tg-0lax" align="center" align="center">2021/07</td>
    <td class="tg-baqh" align="center">10</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2107.02137">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">Jurassic-1</td>
    <td class="tg-0lax" align="center">2021/08</td>
    <td class="tg-baqh" align="center">178</td>
    <td class="tg-0lax" align="center"><a href="https://assets.website-files.com/60fd4503684b466578c0d307/61138924626a6981ee09caf6_jurassic_tech_论文链接.pdf">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center" align="center">FLAN</td>
    <td class="tg-0lax" align="center">2021/10</td>
    <td class="tg-baqh" align="center">137</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2109.01652">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">MT-NLG</td>
    <td class="tg-0lax" align="center">2021/10</td>
    <td class="tg-baqh" align="center">530</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2201.11990">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">Yuan 1.0</td>
    <td class="tg-0lax" align="center">2021/10</td>
    <td class="tg-baqh" align="center">245</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2110.04725">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">Anthropic</td>
    <td class="tg-0lax" align="center">2021/12</td>
    <td class="tg-baqh" align="center">52</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2112.00861">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">WebGPT</td>
    <td class="tg-0lax" align="center">2021/12</td>
    <td class="tg-baqh" align="center">175</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2112.09332">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">Gopher</td>
    <td class="tg-0lax" align="center">2021/12</td>
    <td class="tg-baqh" align="center">280</td>
    <td class="tg-0lax" align="center"><a href="http://arxiv.org/abs/2112.11446v2">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">ERNIE 3.0 Titan</td>
    <td class="tg-0lax" align="center">2021/12</td>
    <td class="tg-baqh" align="center">260</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2112.12731">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">GLaM</td>
    <td class="tg-0lax" align="center">2021/12</td>
    <td class="tg-baqh" align="center">1200</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2112.06905">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">InstructGPT</td>
    <td class="tg-0lax" align="center">2022/01</td>
    <td class="tg-baqh" align="center">175</td>
    <td class="tg-0lax" align="center"><a href="http://arxiv.org/abs/2203.02155v1">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">AlphaCode</td>
    <td class="tg-0lax" align="center">2022/02</td>
    <td class="tg-baqh" align="center">41</td>
    <td class="tg-0lax" align="center"><a href="http://arxiv.org/abs/2203.07814v1">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">Chinchilla</td>
    <td class="tg-0lax" align="center">2022/03</td>
    <td class="tg-baqh" align="center">70</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2203.15556">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">PaLM</td>
    <td class="tg-0lax" align="center">2022/04</td>
    <td class="tg-baqh" align="center">540</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2204.02311">论文链接</a></td>
    <tr>
    <td class="tg-baqh" align="center">Cohere</td>
    <td class="tg-0lax" align="center">2022/06</td>
    <td class="tg-baqh" align="center">54</td>
    <td class="tg-0lax" align="center"><a href="https://cohere.ai/">Homepage</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">AlexaTM</td>
    <td class="tg-0lax" align="center">2022/08</td>
    <td class="tg-baqh" align="center">20</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2208.01448">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">Luminous</td>
    <td class="tg-0lax" align="center">2022/09</td>
    <td class="tg-baqh" align="center">70</td>
    <td class="tg-0lax" align="center"><a href="https://docs.aleph-alpha.com/docs/introduction/luminous/">Docs</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">Sparrow</td>
    <td class="tg-0lax" align="center">2022/09</td>
    <td class="tg-baqh" align="center">70</td>
    <td class="tg-0lax" align="center"><a href="http://arxiv.org/abs/2209.14375v1">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">WeLM</td>
    <td class="tg-0lax" align="center">2022/09</td>
    <td class="tg-baqh" align="center">10</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2209.10372">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">U-PaLM</td>
    <td class="tg-0lax" align="center">2022/10</td>
    <td class="tg-baqh" align="center">540</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2210.11399">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">Flan-PaLM</td>
    <td class="tg-0lax" align="center">2022/10</td>
    <td class="tg-baqh" align="center" align="center">540</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2210.11416">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">Flan-U-PaLM</td>
    <td class="tg-0lax" align="center">2022/10</td>
    <td class="tg-baqh" align="center">540</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2210.11416">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">Alpaca</td>
    <td class="tg-0lax" align="center">2023/03</td>
    <td class="tg-baqh" align="center">7</td>
    <td class="tg-0lax" align="center"><a href="https://crfm.stanford.edu/2023/03/13/alpaca.html">Blog</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">GPT-4</td>
    <td class="tg-0lax" align="center">2023/3</td>
    <td class="tg-baqh" align="center">-</td>
    <td class="tg-0lax" align="center"><a href="http://arxiv.org/abs/2303.08774v2">论文链接</a></td>
  </tr>
  <tr>
    <td class="tg-baqh" align="center">PanGU-Σ</td>
    <td class="tg-0lax" align="center">2023/3</td>
    <td class="tg-baqh" align="center">1085</td>
    <td class="tg-0lax" align="center"><a href="https://arxiv.org/abs/2303.10845">论文链接</a></td>
  </tr>
</tbody>
</table>


<h3 id="4-2-大模型相关论文"><a href="#4-2-大模型相关论文" class="headerlink" title="4.2 大模型相关论文"></a>4.2 大模型相关论文</h3><h4 id="4-2-1-开源大模型论文："><a href="#4-2-1-开源大模型论文：" class="headerlink" title="4.2.1 开源大模型论文："></a>4.2.1 开源大模型论文：</h4><ol>
<li><u>T5</u>: <strong>&quot;Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer&quot;</strong>. <em>Colin Raffel et al.</em> JMLR 2019. [<a href="https://arxiv.org/abs/1910.10683">Paper</a>] [<a href="https://huggingface.co/t5-11b">Checkpoint</a>]</li>
<li><u>mT5</u>: <strong>&quot;mT5: A massively multilingual pre-trained text-to-text transformer&quot;</strong>. <em>Linting Xue</em> et al. NAACL 2021. [<a href="https://arxiv.org/abs/2010.11934">Paper</a>] [<a href="https://huggingface.co/google/mt5-xxl/tree/main">Checkpoint</a>]</li>
<li><u>PanGu-α</u>: <strong>&quot;PanGu-α: Large-scale Autoregressive Pretrained Chinese Language Models with Auto-parallel Computation&quot;</strong>. <em>Wei Zeng et al.</em> arXiv 2021. [<a href="https://arxiv.org/abs/2104.12369">Paper</a>] [<a href="https://openi.pcl.ac.cn/PCL-Platform.Intelligence/PanGu-Alpha">Checkpoint</a>]</li>
<li><u>CPM-2</u>: <strong>&quot;CPM-2: Large-scale Cost-effective Pre-trained Language Models&quot;</strong>. <em>Zhengyan Zhang et al.</em> arXiv 2021. [<a href="https://arxiv.org/abs/2106.10715">Paper</a>] [<a href="https://github.com/TsinghuaAI/CPM">Checkpoint</a>]</li>
<li><u>T0</u>: <strong>&quot;Multitask Prompted Training Enables Zero-Shot Task Generalization&quot;</strong>. <em>Victor Sanh et al.</em> ICLR 2022. [<a href="https://arxiv.org/abs/2110.08207">Paper</a>] [<a href="https://huggingface.co/bigscience/T0">Checkpoint</a>]</li>
<li><u>GPT-NeoX-20B</u>: <strong>&quot;GPT-NeoX-20B: An Open-Source Autoregressive Language Model&quot;</strong>. <em>Sid Black et al.</em> arXiv 2022. [<a href="https://arxiv.org/abs/2204.06745">Paper</a>] [<a href="https://huggingface.co/EleutherAI/gpt-neox-20b/tree/main">Checkpoint</a>]</li>
<li><u>CodeGen</u>: <strong>&quot;CodeGen: An Open Large Language Model for Code with Multi-Turn Program Synthesis&quot;</strong>. <em>Erik Nijkamp et al.</em> arXiv 2022. [<a href="https://arxiv.org/abs/2203.13474">Paper</a>] [<a href="https://huggingface.co/Salesforce/codegen-16B-nl">Checkpoint</a>]</li>
<li><u>Tk-Instruct</u>: <strong>&quot;Super-NaturalInstructions: Generalization via Declarative Instructions on 1600+ NLP Tasks&quot;</strong>. <em>Yizhong Wang et al.</em> EMNLP 2022. [<a href="https://arxiv.org/abs/2204.07705">Paper</a>] [<a href="https://huggingface.co/allenai/tk-instruct-11b-def-pos">Checkpoint</a>]</li>
<li><u>UL2</u>: <strong>&quot;UL2: Unifying Language Learning Paradigms&quot;</strong>. <em>Yi Tay et al.</em> arXiv 2022. [<a href="https://arxiv.org/abs/2205.05131">Paper</a>] [<a href="https://github.com/google-research/google-research/tree/master/ul2">Checkpoint</a>]</li>
<li><u>OPT</u>: <strong>&quot;OPT: Open Pre-trained Transformer Language Models&quot;</strong>. <em>Susan Zhang et al.</em> arXiv 2022. [<a href="https://arxiv.org/abs/2205.01068">Paper</a>] [<a href="https://github.com/facebookresearch/metaseq/tree/main/projects/OPT">Checkpoint</a>]</li>
<li><u>NLLB</u>: <strong>&quot;No Language Left Behind: Scaling Human-Centered Machine Translation&quot;</strong>. <em>NLLB Team.</em> arXiv 2022. [<a href="https://arxiv.org/abs/2207.04672">Paper</a>] [<a href="https://github.com/facebookresearch/fairseq/tree/nllb">Checkpoint</a>]</li>
<li><u>BLOOM</u>: <strong>&quot;BLOOM: A 176B-Parameter Open-Access Multilingual Language Model&quot;</strong>. <em>BigScience Workshop</em>. arXiv 2022. [<a href="https://arxiv.org/abs/2211.05100">Paper</a>] [<a href="https://huggingface.co/bigscience/bloom">Checkpoint</a>]</li>
<li><u>GLM</u>: <strong>&quot;GLM-130B: An Open Bilingual Pre-trained Model&quot;</strong>. <em>Aohan Zeng et al.</em> arXiv 2022. [<a href="https://arxiv.org/abs/2210.02414">Paper</a>] [<a href="https://github.com/THUDM/GLM-130B">Checkpoint</a>]</li>
<li><u>Flan-T5</u>: <strong>&quot;Scaling Instruction-Finetuned Language Models&quot;</strong>. <em>Hyung Won Chung et al.</em> arXiv 2022. [<a href="https://arxiv.org/abs/2210.11416">Paper</a>] [<a href="https://github.com/google-research/t5x/blob/main/docs/models.md#flan-t5-checkpoints">Checkpoint</a>]</li>
<li><u>mT0 &amp;&amp; BLOOMZ</u>: <strong>&quot;Crosslingual Generalization through Multitask Finetuning&quot;</strong>. <em>Niklas Muennighoff et al.</em> arXiv 2022. [<a href="https://arxiv.org/abs/2211.01786">Paper</a>] [<a href="https://github.com/bigscience-workshop/xmtf">Checkpoint</a>]</li>
<li><u>Galactica</u>: <strong>&quot;Galactica: A Large Language Model for Science&quot;</strong>. <em>Ross Taylor et al.</em> arXiv 2022. [<a href="https://arxiv.org/abs/2211.09085">Paper</a>] [<a href="https://huggingface.co/facebook/galactica-120b">Checkpoint</a>]</li>
<li><u>OPT-IML</u>: <strong>&quot;OPT-IML: Scaling Language Model Instruction Meta Learning through the Lens of Generalization&quot;</strong>. <em>Srinivasan et al.</em> . arXiv 2022. [<a href="https://arxiv.org/abs/2212.12017">Paper</a>] [<a href="https://huggingface.co/facebook/opt-iml-30b">Checkpoint</a>]</li>
<li><u>CodeGeeX</u>: <strong>&quot;CodeGeeX: A Pre-Trained Model for Code Generation with Multilingual Evaluations on HumanEval-X&quot;</strong>. <em>Qinkai Zheng et al.</em> . arXiv 2023. [<a href="https://arxiv.org/abs/2303.17568">Paper</a>] [<a href="https://github.com/THUDM/CodeGeeX">Checkpoint</a>]</li>
<li><u>Pythia</u>: <strong>&quot;Pythia: A Suite for Analyzing Large Language Models Across Training and Scaling&quot;</strong>. <em>Stella Biderman et al.</em> . arXiv 2023. [<a href="https://arxiv.org/abs/2304.01373">Paper</a>] [<a href="https://github.com/EleutherAI/pythia">Checkpoint</a>]</li>
<li><u>LLaMA</u>: <strong>&quot;LLaMA: Open and Efficient Foundation Language Models&quot;</strong>. <em>Hugo Touvron et al.</em> arXiv 2023. [<a href="https://arxiv.org/abs/2302.13971v1">Paper</a>] [<a href="https://github.com/facebookresearch/llama">Checkpoint</a>]</li>
</ol>
<h4 id="4-2-2-不开源大模型论文："><a href="#4-2-2-不开源大模型论文：" class="headerlink" title="4.2.2 不开源大模型论文："></a>4.2.2 不开源大模型论文：</h4><ol>
<li><u>GShard</u>: <strong>&quot;GShard: Scaling Giant Models with Conditional Computation and Automatic Sharding&quot;</strong>. <em>Dmitry Lepikhin et al.</em> ICLR 2021. [<a href="http://arxiv.org/abs/2006.16668v1">Paper</a>]</li>
<li><u>GPT-3</u>: <strong>&quot;Language Models are Few-Shot Learners&quot;</strong>. <em>Tom B. Brown et al.</em> NeurIPS 2020. [<a href="https://arxiv.org/abs/2005.14165">Paper</a>]</li>
<li><u>LaMDA</u>: <strong>&quot;LaMDA: Language Models for Dialog Applications&quot;</strong>. <em>Romal Thoppilan et al.</em> arXiv 2021. [<a href="https://arxiv.org/abs/2201.08239">Paper</a>]</li>
<li><u>HyperCLOVA</u>: <strong>&quot;What Changes Can Large-scale Language Models Bring? Intensive Study on HyperCLOVA: Billions-scale Korean Generative Pretrained Transformers&quot;</strong>. <em>Boseop Kim et al.</em> EMNLP 2021. [<a href="https://arxiv.org/abs/2109.04650">Paper</a>]</li>
<li><u>CodeX</u>: <strong>&quot;Evaluating Large Language Models Trained on Code&quot;</strong>. <em>Mark Chen et al.</em> arXiv 2021. [<a href="https://arxiv.org/abs/2107.03374">Paper</a>]</li>
<li><u>ERNIE 3.0</u>: <strong>&quot;ERNIE 3.0: Large-scale Knowledge Enhanced Pre-training for Language Understanding and Generation&quot;</strong>. <em>Yu Sun et al.</em> arXiv 2021. [<a href="https://arxiv.org/abs/2107.02137">Paper</a>]</li>
<li><u>Jurassic-1</u>: <strong>&quot;Jurassic-1: Technical details and evaluation&quot;</strong>. <em>Opher Lieber et al.</em> 2021. [<a href="https://assets.website-files.com/60fd4503684b466578c0d307/61138924626a6981ee09caf6_jurassic_tech_paper.pdf">Paper</a>]</li>
<li><u>FLAN</u>: <strong>&quot;Finetuned Language Models Are Zero-Shot Learners&quot;</strong>. <em>Jason Wei et al.</em> ICLR 2021. [<a href="https://arxiv.org/abs/2109.01652">Paper</a>]</li>
<li><u>MT-NLG</u>: <strong>&quot;Using DeepSpeed and Megatron to Train Megatron-Turing NLG 530B, A Large-Scale Generative Language Model&quot;</strong>. <em>Shaden Smith et al.</em> arXiv 2021. [<a href="https://arxiv.org/abs/2201.11990">Paper</a>]</li>
<li><u>Yuan 1.0</u>: <strong>&quot;Yuan 1.0: Large-Scale Pre-trained Language Model in Zero-Shot and Few-Shot Learning&quot;</strong>. <em>Shaohua Wu et al.</em> arXiv 2021. [<a href="https://arxiv.org/abs/2110.04725">Paper</a>]</li>
<li><u>Anthropic</u>: <strong>&quot;A General Language Assistant as a Laboratory for Alignment&quot;</strong> . <em>Amanda Askell et al.</em> arXiv 2021. [<a href="https://arxiv.org/abs/2112.00861">Paper</a>]</li>
<li><u>WebGPT</u>: <strong>&quot;WebGPT: Browser-assisted question-answering with human feedback&quot;</strong> . <em>Reiichiro Nakano et al.</em> arXiv 2021. [<a href="https://arxiv.org/abs/2112.09332">Paper</a>]</li>
<li><u>Gopher</u>: <strong>&quot;Scaling Language Models: Methods, Analysis &amp; Insights from Training Gopher&quot;</strong>.  <em>Jack W. Rae et al.</em> arXiv 2021. [<a href="http://arxiv.org/abs/2112.11446v2">Paper</a>]</li>
<li><u>ERNIE 3.0 Titan</u>: <strong>&quot;ERNIE 3.0 Titan: Exploring Larger-scale Knowledge Enhanced Pre-training for Language Understanding and Generation&quot;</strong>.  *Shuohuan Wang et al. *arXiv 2021. [<a href="https://arxiv.org/abs/2112.12731">Paper</a>]</li>
<li><u>GLaM</u>: <strong>&quot;GLaM: Efficient Scaling of Language Models with Mixture-of-Experts&quot;</strong>. <em>Nan Du et al.</em> ICML 2022. [<a href="https://arxiv.org/abs/2112.06905">Paper</a>]</li>
<li><u>InstructGPT</u>: <strong>&quot;Training language models to follow instructions with human feedback&quot;</strong>. <em>Long Ouyang et al.</em> arXiv 2022. [<a href="http://arxiv.org/abs/2203.02155v1">Paper</a>]</li>
<li><u>AlphaCode</u>: <strong>&quot;Competition-Level Code Generation with AlphaCode&quot;</strong>. <em>Yujia Li et al.</em> arXiv 2022. [<a href="http://arxiv.org/abs/2203.07814v1">Paper</a>]</li>
<li><u>Chinchilla</u>: <strong>&quot;Training Compute-Optimal Large Language Models&quot;</strong>. <em>Jordan Hoffmann et al.</em> arXiv. [<a href="https://arxiv.org/abs/2203.15556">Paper</a>]</li>
<li><u>PaLM</u>: <strong>&quot;PaLM: Scaling Language Modeling with Pathways&quot;</strong>. <em>Aakanksha Chowdhery et al.</em> arXiv 2022. [<a href="https://arxiv.org/abs/2204.02311">Paper</a>]</li>
<li><u>AlexaTM</u>: <strong>&quot;AlexaTM 20B: Few-Shot Learning Using a Large-Scale Multilingual Seq2Seq Model&quot;</strong>. <em>Saleh Soltan et al.</em> arXiv 2022. [<a href="https://arxiv.org/abs/2208.01448">Paper</a>]</li>
<li><u>Sparrow</u>: <strong>&quot;Improving alignment of dialogue agents via targeted human judgements&quot;</strong>. <em>Amelia Glaese et al.</em> . arXiv 2022. [<a href="http://arxiv.org/abs/2209.14375v1">Paper</a>]</li>
<li><u>WeLM</u>: <strong>&quot;WeLM: A Well-Read Pre-trained Language Model for Chinese&quot;</strong>. <em>Hui Su et al.</em> . arXiv 2022. [<a href="https://arxiv.org/abs/2209.10372">Paper</a>]</li>
<li><u>U-PaLM</u>: <strong>&quot;Transcending Scaling Laws with 0.1% Extra Compute&quot;</strong>. <em>Yi Tay et al.</em> arXiv 2022. [<a href="https://arxiv.org/abs/2210.11399">Paper</a>]</li>
<li><u>Flan-PaLM &amp;&amp; Flan-U-PaLM</u>: <strong>&quot;Scaling Instruction-Finetuned Language Models&quot;</strong>. <em>Hyung Won Chung et al.</em> arXiv. [<a href="https://arxiv.org/abs/2210.11416">Paper</a>] </li>
<li><u>GPT-4</u>: <strong>&quot;GPT-4 Technical Report&quot;</strong>. <em>OpenAI</em>. arXiv 2023. [<a href="http://arxiv.org/abs/2303.08774v2">Paper</a>]</li>
<li><u>PanGu-Σ</u>: <strong>&quot;PanGu-Σ: Towards Trillion Parameter Language Model with Sparse Heterogeneous Computing&quot;</strong>. <em>Xiaozhe Ren et al.</em> arXiv 2023. [<a href="https://arxiv.org/abs/2303.10845">Paper</a>]</li>
</ol>
<h4 id="4-2-3-常用语料库"><a href="#4-2-3-常用语料库" class="headerlink" title="4.2.3 常用语料库"></a>4.2.3 常用语料库</h4><ol>
<li><u>BookCorpus</u>: <strong>&quot;Aligning Books and Movies: Towards Story-like Visual Explanations by Watching Movies and Reading Books&quot;</strong>. <em>Yukun Zhu et al.</em>  ICCV 2015. [<a href="http://arxiv.org/abs/1506.06724v1">Paper</a>] [<a href="https://huggingface.co/datasets/bookcorpus">Source</a>]</li>
<li><u>Guntenburg</u>: [<a href="https://www.gutenberg.org/">Source</a>]</li>
<li><u>CommonCrawl</u>: [<a href="https://commoncrawl.org/">Source</a>]</li>
<li><u>C4</u>: <strong>&quot;Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer&quot;</strong>. <em>Colin Raffel et al.</em> JMLR 2019. [<a href="http://arxiv.org/abs/1910.10683v3">Paper</a>] [<a href="https://www.tensorflow.org/datasets/catalog/c4">Source</a>]</li>
<li><u>CC-stories-R</u>: <strong>&quot;A Simple Method for Commonsense Reasoning&quot;</strong>. <em>Trieu H. Trinh el al.</em> arXiv 2018. [<a href="http://arxiv.org/abs/1806.02847v2">Paper</a>] [<a href="https://huggingface.co/datasets/spacemanidol/cc-stories">Source</a>]</li>
<li><u>CC-NEWS</u>: <strong>&quot;RoBERTa: A Robustly Optimized BERT Pretraining Approach&quot;</strong>. <em>Yinhan Liu et al.</em> arXiv 2019. [<a href="http://arxiv.org/abs/1907.11692v1">Paper</a>] [<a href="https://huggingface.co/datasets/cc_news">Source</a>]</li>
<li><u>REALNEWs</u>: <strong>&quot;Defending Against Neural Fake News&quot;</strong>. <em>Rowan Zellers et al.</em> NeurIPS 2019. [<a href="http://arxiv.org/abs/1905.12616v3">Paper</a>] [<a href="https://github.com/rowanz/grover/tree/master/realnews">Source</a>]</li>
<li><u>OpenWebText</u>: [<a href="https://skylion007.github.io/OpenWebTextCorpus/">Source</a>]</li>
<li><u>Pushshift.io</u>: <strong>&quot;The Pushshift Reddit Dataset&quot;</strong>. <em>Jason Baumgartner et al</em>. AAAI 2020. [<a href="http://arxiv.org/abs/2001.08435v1">Paper</a>] [<a href="https://files.pushshift.io/reddit/">Source</a>]</li>
<li><u>Wikipedia</u>: [<a href="https://dumps.wikimedia.org/">Source</a>]</li>
<li><u>BigQuery</u>:  [<a href="https://cloud.google.com/bigquery/public-data?hl=zh-cn">Source</a>]</li>
<li><u>The Pile</u>: <strong>&quot;The Pile: An 800GB Dataset of Diverse Text for Language Modeling&quot;</strong>. <em>Leo Gao et al</em>. arxiv 2021. [<a href="http://arxiv.org/abs/2101.00027v1">Paper</a>] [<a href="https://pile.eleuther.ai/">Source</a>]</li>
<li><u>ROOTS</u>: <strong>&quot;The BigScience ROOTS Corpus: A 1.6TB Composite Multilingual Dataset&quot;</strong>. <em>Laurençon et al</em>. NeurIPS 2022 Datasets and Benchmarks Track. [<a href="https://arxiv.org/abs/2303.03915">paper</a>]</li>
</ol>
<h4 id="4-2-4-深度学习框架"><a href="#4-2-4-深度学习框架" class="headerlink" title="4.2.4 深度学习框架"></a>4.2.4 深度学习框架</h4><ol>
<li><u>Pytorch</u>: <strong>&quot;PyTorch: An Imperative Style, High-Performance Deep Learning Library&quot;</strong>. <em>Adam Paszke el al.</em> NeurIPS 2019. [<a href="https://arxiv.org/abs/1912.01703">Paper</a>] [<a href="https://pytorch.org/">Source</a>]</li>
<li><u>TensorFlow</u>: <strong>&quot;TensorFlow: A system for large-scale machine learning&quot;</strong>. <em>Martín Abadi et al.</em> OSDI 2016. [<a href="https://arxiv.org/abs/1605.08695">Paper</a>] [<a href="https://www.tensorflow.org/">Source</a>] </li>
<li><u>MXNet</u>: <strong>&quot;MXNet: A Flexible and Efficient Machine Learning Library for Heterogeneous Distributed Systems&quot;</strong>. <em>Tianqi Chen et al.</em> arXiv 2015. [<a href="https://arxiv.org/abs/1512.01274">Paper</a>] [<a href="https://github.com/apache/mxnet">Source</a>] </li>
<li><u>PaddlePaddle</u>: <strong>&quot;PaddlePaddle: An Open-Source Deep Learning Platform from Industrial Practice&quot;</strong> . <em>Yanjun Ma et al.</em> Frontiers of Data and Domputing 2019.  [<a href="http://www.jfdc.cnic.cn/EN/abstract/abstract2.shtml">Paper</a>] [<a href="https://github.com/PaddlePaddle/Paddle">Source</a>] </li>
<li><u>MindSpore</u>: <strong>&quot;Huawei MindSpore AI Development Framework&quot;</strong> . <em>Huawei Technologies Co., Ltd.</em> Artificial Intelligence Technology 2022. [<a href="https://link.springer.com/chapter/10.1007/978-981-19-2879-6_5">Paper</a>] [<a href="https://github.com/mindspore-ai/mindspore">Source</a>] </li>
<li><u>OneFlow</u>: <strong>&quot;OneFlow: Redesign the Distributed Deep Learning Framework from Scratch&quot;</strong> . <em>Jinhui Yuan et al.</em> arXiv 2021. [<a href="https://arxiv.org/abs/2110.15032">Paper</a>] [<a href="https://github.com/Oneflow-Inc/oneflow">Source</a>] </li>
</ol>
<hr>
<ol>
<li>原文地址：<a href="https://arxiv.org/abs/2303.18223">A Survey of Large Language Models (arxiv.org)</a></li>
<li>知乎地址：<a href="https://zhuanlan.zhihu.com/p/641376419">大模型综述升级啦 (zhihu.com)</a></li>
<li>Github link：<a href="https://github.com/RUCAIBox/LLMSurvey">A Survey of Large Language Models(github.com)</a></li>
<li>中文版本：<a href="https://github.com/RUCAIBox/LLMSurvey/blob/main/assets/LLM_Survey_Chinese.pdf">LLM_Survey_Chinese.pdf (github.com)</a></li>
</ol>
<p>如果觉得文章对你有帮助的话，欢迎引用文章的原文</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">@article&#123;LLMSurvey,</span><br><span class="line">    title=&#123;A Survey of Large Language Models&#125;,</span><br><span class="line">    author=&#123;Zhao, Wayne Xin and Zhou, Kun and Li, Junyi and Tang, Tianyi and Wang, Xiaolei and Hou, Yupeng and Min, Yingqian and Zhang, Beichen and Zhang, Junjie and Dong, Zican and Du, Yifan and Yang, Chen and Chen, Yushuo and Chen, Zhipeng and Jiang, Jinhao and Ren, Ruiyang and Li, Yifan and Tang, Xinyu and Liu, Zikang and Liu, Peiyu and Nie, Jian-Yun and Wen, Ji-Rong&#125;,</span><br><span class="line">    year=&#123;2023&#125;,</span><br><span class="line">    journal=&#123;arXiv preprint arXiv:2303.18223&#125;,</span><br><span class="line">    url=&#123;http://arxiv.org/abs/2303.18223&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>头歌 - 机器学习 - 随机森林</title>
    <url>//2023/05/26/educoder-ml-homework/</url>
    <content><![CDATA[<h1 id="【educoder】-机器学习-随机森林"><a href="#【educoder】-机器学习-随机森林" class="headerlink" title="【educoder】 机器学习 --- 随机森林"></a>【educoder】 机器学习 --- 随机森林</h1><h2 id="第1关：Bagging"><a href="#第1关：Bagging" class="headerlink" title="第1关：Bagging"></a>第1关：Bagging</h2><h3 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：补充 python 代码，完成 BaggingClassifier 类中的 fit 和 predict 函数。<strong>请不要修改 Begin-End 段之外的代码。</strong></p>
<h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握：</p>
<ul>
<li>什么是 Bagging；</li>
<li>Bagging 算法如何训练与预测。</li>
</ul>
<h4 id="什么是Bagging"><a href="#什么是Bagging" class="headerlink" title="什么是Bagging"></a>什么是Bagging</h4><p> Bagging 是 Bootstrap Aggregating 的英文缩写，刚接触的童鞋不要误认为 Bagging 是一种算法， Bagging 和 Boosting 都是集成学习中的学习框架，代表着不同的思想。与 Boosting 这种串行集成学习算法不同， Bagging 是并行式集成学习方法。大名鼎鼎的随机森林算法就是在 Bagging 的基础上修改的算法。</p>
<p><strong>Bagging 方法的核心思想就是三个臭皮匠顶个诸葛亮</strong>。如果使用 Bagging 解决分类问题，就是将多个分类器的结果整合起来进行投票，选取票数最高的结果作为最终结果。如果使用 Bagging 解决回归问题，就将多个回归器的结果加起来然后求平均，将平均值作为最终结果。</p>
<p>那么 Bagging 方法如此有效呢，举个例子。狼人杀我相信大家都玩过，在天黑之前，村民们都要根据当天所发生的事和别人的发现来投票决定谁可能是狼人。</p>
<p>如果我们将每个村民看成是一个分类器，那么每个村民的任务就是二分类，假设<em>h**i</em>(<em>x</em>)表示第 i 个村民认为 x 是不是狼人( -1 代表不是狼人，1 代表是狼人)，<em>f</em>(<em>x</em>)表示 x 真正的身份(是不是狼人)，<em>ϵ</em>表示为村民判断错误的错误率。则有<em>P</em>(<em>h**i</em>(<em>x</em>)=<em>f</em>(<em>x</em>))=<em>ϵ</em>。</p>
<p>根据狼人杀的规则，村民们需要投票决定天黑前谁是狼人，也就是说如果有超过半数的村民投票时猜对了，那么这一轮就猜对了。那么假设现在有<em>T</em>个村民，<em>H</em>(<em>x</em>)表示投票后最终的结果，则有<em>H</em>(<em>x</em>)=<em>s<strong>i</strong>g**n</em>(∑<em>i</em>=1<em>T<strong>h</strong>i</em>(<em>x</em>))。</p>
<p>现在假设每个村民都是有主见的人，对于谁是狼人都有自己的想法，那么他们的错误率也是相互独立的。那么根据 Hoeffding不等式 可知，<em>H</em>(<em>x</em>)的错误率为：</p>
<p><em>P</em>(<em>H</em>(<em>x</em>)=<em>f</em>(<em>x</em>))=<em>k</em>=0∑<em>T</em>/2<em>C<strong>T</strong>k</em>(1−<em>ϵ</em>)<em>k<strong>ϵ</strong>T</em>−<em>k</em>≤<em>e<strong>x</strong>p</em>(−21<em>T</em>(1−2<em>ϵ</em>)2)</p>
<p>根据上式可知，如果 5 个村民，每个村民的错误率为 0.33，那么投票的错误率为 0.749；如果 20 个村民，每个村民的错误率为 0.33，那么投票的错误率为 0.315；如果 50 个村民，每个村民的错误率为 0.33，那么投票的错误率为 0.056；如果 100 个村民，每个村民的错误率为 0.33，那么投票的错误率为 0.003。<strong>从结果可以看出，村民的数量越大，那么投票后犯错的错误率就越小。</strong>这也是 Bagging 性能强的原因之一。</p>
<h4 id="Bagging方法如何训练与预测"><a href="#Bagging方法如何训练与预测" class="headerlink" title="Bagging方法如何训练与预测"></a>Bagging方法如何训练与预测</h4><h4 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h4><p> Bagging 在训练时的特点就是<strong>随机有放回采样</strong>和<strong>并行</strong>。</p>
<ul>
<li><p><strong>随机有放回采样：</strong>假设训练数据集有 m 条样本数据，每次从这 m 条数据中随机取一条数据放入采样集，然后将其返回，让下一次采样有机会仍然能被采样。然后重复 m 次，就能得到拥有 m 条数据的采样集，该采样集作为 Bagging 的众多分类器中的一个作为训练数据集。假设有 T 个分类器（随便什么分类器），那么就重复 T 此随机有放回采样，构建出 T 个采样集分别作为 T 个分类器的训练数据集。</p>
</li>
<li><p><strong>并行：</strong>假设有 10 个分类器，在 Boosting 中，1 号分类器训练完成之后才能开始 2 号分类器的训练，而在 Bagging 中，分类器可以同时进行训练，当所有分类器训练完成之后，整个 Bagging 的训练过程就结束了。</p>
<p>Bagging 训练过程如下图所示：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog294338" alt="img"> </p>
<h4 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h4><p> Bagging 在预测时非常简单，就是<strong>投票</strong>！比如现在有 5 个分类器，有 3 个分类器认为当前样本属于 A 类，1 个分类器认为属于 B 类，1 个分类器认为属于 C 类，那么 Bagging 的结果会是 A 类（因为 A 类的票数最高）。</p>
<p> Bagging 预测过程如下图所示:</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog294341" alt="img"> </p>
<h3 id="编程要求"><a href="#编程要求" class="headerlink" title="编程要求"></a>编程要求</h3><p>在 begin-end 中完成 BaggingClassifier 类中的 fit 和 predict 函数。分类器可使用 sklearn 提供的 DecisionTreeClassifier。要求模型保存在 self.models 中。</p>
<p> fit 函数用于 Bagging 的训练过程，其中：</p>
<ul>
<li><p>feature ：训练集数据，类型为 ndarray；</p>
</li>
<li><p>label ：训练集标签，类型为 ndarray。</p>
<p>predict 函数，实现预测功能，并将标签返回，其中：</p>
</li>
<li><p>feature ：测试集数据，类型为 ndarray 。<strong>（PS：feature中有多条数据）</strong></p>
</li>
</ul>
<h3 id="测试说明"><a href="#测试说明" class="headerlink" title="测试说明"></a>测试说明</h3><p>只需完成 fit 与 predict 函数即可，程序内部会调用您所完成的 fit 函数构建模型并调用 predict 函数来对数据进行预测。预测的准确率高于 0.9 视为过关。</p>
<h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaggingClassifier</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n_model=<span class="number">10</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            初始化函数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 分类器的数量，默认为10</span></span><br><span class="line">        self.n_model = n_model</span><br><span class="line">        <span class="comment"># 用于保存模型的列表，训练好分类器后将对象append进去即可</span></span><br><span class="line">        self.models = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, feature, label</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            训练模型</span></span><br><span class="line"><span class="string">            :param feature: 训练数据集所有特征组成的ndarray</span></span><br><span class="line"><span class="string">            :param label:训练数据集中所有标签组成的ndarray</span></span><br><span class="line"><span class="string">            :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># ************* Begin ************#</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n_model):</span><br><span class="line">            m = <span class="built_in">len</span>(feature)</span><br><span class="line">            index = np.random.choice(m, m)</span><br><span class="line">            sample_data = feature[index]</span><br><span class="line">            sample_lable = label[index]</span><br><span class="line">            model = DecisionTreeClassifier()</span><br><span class="line">            model = model.fit(sample_data, sample_lable)</span><br><span class="line">            self.models.append(model)</span><br><span class="line">        <span class="comment"># ************* End **************#</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, feature</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            :param feature:训练数据集所有特征组成的ndarray</span></span><br><span class="line"><span class="string">            :return:预测结果，如np.array([0, 1, 2, 2, 1, 0])</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># ************* Begin ************#</span></span><br><span class="line">        result = []</span><br><span class="line">        vote = []</span><br><span class="line">        <span class="keyword">for</span> model <span class="keyword">in</span> self.models:</span><br><span class="line">            r = model.predict(feature)</span><br><span class="line">            vote.append(r)</span><br><span class="line">        vote = np.array(vote)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(feature)):</span><br><span class="line">            v = <span class="built_in">sorted</span>(Counter(vote[:, i]).items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">            result.append(v[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> np.array(result)</span><br><span class="line">        <span class="comment"># ************* End **************#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第2关：随机森林算法流程"><a href="#第2关：随机森林算法流程" class="headerlink" title="第2关：随机森林算法流程"></a>第2关：随机森林算法流程</h2><h3 id="任务描述-1"><a href="#任务描述-1" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：补充 python 代码，完成 RandomForestClassifier 类中的 fit 和 predict 函数。<strong>请不要修改 Begin-End 段之外的代码。</strong></p>
<h3 id="相关知识-1"><a href="#相关知识-1" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握随机森林的训练与预测流程</p>
<h4 id="随机森林的训练流程"><a href="#随机森林的训练流程" class="headerlink" title="随机森林的训练流程"></a>随机森林的训练流程</h4><p>随机森林是 Bagging 的一种扩展变体，随机森林的训练过程相对与 Bagging 的训练过程的改变有：</p>
<ul>
<li>基学习器： Bagging 的基学习器可以是<strong>任意学习器</strong>，而随机森林则是以<strong>决策树作为基学习器</strong>。</li>
<li>随机属性选择：假设原始训练数据集有 10 个特征，从这 10 个特征中随机选取 k 个特征构成训练数据子集，然后将这个子集作为训练集扔给决策树去训练。其中 k 的取值一般为 log2(特征数量) 。</li>
</ul>
<p>这样的改动通常会使得<strong>随机森林具有更加强的泛化性</strong>，因为每一棵决策树的训练数据集是随机的，而且训练数据集中的特征也是随机抽取的。如果每一棵决策树模型的差异比较大，那么就很容易能够解决决策树容易过拟合的问题。</p>
<p>随机森林训练过程伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#假设数据集为D，标签集为A，需要构造的决策树为tree</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">D, A</span>):</span><br><span class="line">    models = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(决策树的数量):</span><br><span class="line">        有放回的随机采样数据，得到数据集sample_D和标签sample_A</span><br><span class="line">        从采样到的数据中随机抽取K个特征构成训练集sub_D</span><br><span class="line">        构建决策树tree</span><br><span class="line">        tree.fit(sub_D, sample_A)</span><br><span class="line">        models.append(tree)</span><br><span class="line">    <span class="keyword">return</span> models</span><br></pre></td></tr></table></figure>

<h4 id="随机森林的预测流程"><a href="#随机森林的预测流程" class="headerlink" title="随机森林的预测流程"></a>随机森林的预测流程</h4><p>随机森林的预测流程与 Bagging 的预测流程基本一致，如果是回归，就将结果基学习器的预测结果全部加起来算平均；如果是分类，就投票，票数最多的结果作为最终结果。<strong>但需要注意的是，在预测时所用到的特征必须与训练模型时所用到的特征保持一致。</strong>例如，第 3 棵决策树在训练时用到了训练集的第 2，5，8 这 3 个特征。那么在预测时也要用第 2，5，8 这 3 个特征所组成的测试集传给第 3 棵决策树进行预测。</p>
<h3 id="编程要求-1"><a href="#编程要求-1" class="headerlink" title="编程要求"></a>编程要求</h3><p>在 begin-end 中完成 RandomForestClassifier 类中的 fit 和 predict 函数。分类器可使用 sklearn 提供的 DecisionTreeClassifier ，要求模型保存在 self.models 中。</p>
<p> fit 函数用于随机森林的训练过程，其中：</p>
<ul>
<li><p>feature ：训练集数据，类型为 ndarray；</p>
</li>
<li><p>label ：训练集标签，类型为 ndarray。</p>
<p>predict 函数，实现预测功能，并将标签返回，其中：</p>
</li>
<li><p>feature ：测试集数据，类型为 ndarray 。<strong>（PS：feature中有多条数据）</strong></p>
</li>
</ul>
<h3 id="测试说明-1"><a href="#测试说明-1" class="headerlink" title="测试说明"></a>测试说明</h3><p>只需完成 fit 与 predict 函数即可，程序内部会调用您所完成的 fit 函数构建模型并调用 predict 函数来对数据进行预测。预测的准确率高于 0.9 视为过关。</p>
<h3 id="参考答案-1"><a href="#参考答案-1" class="headerlink" title="参考答案"></a>参考答案</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomForestClassifier</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n_model=<span class="number">10</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            初始化函数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 分类器的数量，默认为10</span></span><br><span class="line">        self.n_model = n_model</span><br><span class="line">        <span class="comment"># 用于保存模型的列表，训练好分类器后将对象append进去即可</span></span><br><span class="line">        self.models = []</span><br><span class="line">        <span class="comment"># 用于保存决策树训练时随机选取的列的索引</span></span><br><span class="line">        self.col_indexs = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, feature, label</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            训练模型</span></span><br><span class="line"><span class="string">            :param feature: 训练数据集所有特征组成的ndarray</span></span><br><span class="line"><span class="string">            :param label:训练数据集中所有标签组成的ndarray</span></span><br><span class="line"><span class="string">            :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># ************* Begin ************#</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n_model):</span><br><span class="line">            m = <span class="built_in">len</span>(feature)</span><br><span class="line">            index = np.random.choice(m, m)</span><br><span class="line">            col_index = np.random.permutation(<span class="built_in">len</span>(feature[<span class="number">0</span>]))[:<span class="built_in">int</span>(np.log2(<span class="built_in">len</span>(feature[<span class="number">0</span>])))]</span><br><span class="line">            sample_data = feature[index]</span><br><span class="line">            sample_data = sample_data[:, col_index]</span><br><span class="line">            sample_lable = label[index]</span><br><span class="line">            model = DecisionTreeClassifier()</span><br><span class="line">            model = model.fit(sample_data, sample_lable)</span><br><span class="line">            self.models.append(model)</span><br><span class="line">            self.col_indexs.append(col_index)</span><br><span class="line">        <span class="comment"># ************* End **************#</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, feature</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            :param feature:训练数据集所有特征组成的ndarray</span></span><br><span class="line"><span class="string">            :return:预测结果，如np.array([0, 1, 2, 2, 1, 0])</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># ************* Begin ************#</span></span><br><span class="line">        result = []</span><br><span class="line">        vote = []</span><br><span class="line">        <span class="keyword">for</span> i, model <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.models):</span><br><span class="line">            f = feature[:, self.col_indexs[i]]</span><br><span class="line">            r = model.predict(f)</span><br><span class="line">            vote.append(r)</span><br><span class="line">        vote = np.array(vote)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(feature)):</span><br><span class="line">            v = <span class="built_in">sorted</span>(Counter(vote[:, i]).items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">            result.append(v[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> np.array(result)</span><br><span class="line">        <span class="comment"># ************* End **************#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第3关：手写数字识别"><a href="#第3关：手写数字识别" class="headerlink" title="第3关：手写数字识别"></a>第3关：手写数字识别</h2><h3 id="任务描述-2"><a href="#任务描述-2" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：使用 sklearn 中的 RandomForestClassifier 类完成手写数字识别任务。<strong>请不要修改Begin-End段之外的代码。</strong></p>
<h3 id="相关知识-2"><a href="#相关知识-2" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握如何使用 sklearn 提供的 RandomForestClassifier 类。</p>
<h4 id="数据简介"><a href="#数据简介" class="headerlink" title="数据简介"></a>数据简介</h4><p>本关使用的是手写数字数据集，该数据集有 1797 个样本，每个样本包括 8*8 像素（实际上是一条样本有 64 个特征，每个像素看成是一个特征，每个特征都是 float 类型的数值）的图像和一个 [0, 9] 整数的标签。比如下图的标签是 2 ：</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog294852" alt="img"> </p>
<h4 id="RandomForestClassifier"><a href="#RandomForestClassifier" class="headerlink" title="RandomForestClassifier"></a>RandomForestClassifier</h4><p> RandomForestClassifier 的构造函数中有两个常用的参数可以设置：</p>
<ul>
<li><p> n_estimators ：森林中决策树的数量；</p>
</li>
<li><p> criterion ：构建决策树时，划分节点时用到的指标。有 gini （<strong>基尼系数</strong>）, entropy (<strong>信息增益</strong>)。若不设置，默认为 gini；</p>
</li>
<li><p> max_depth ：决策树的最大深度，如果发现模型已经出现过拟合，可以尝试将该参数调小。若不设置，默认为 None；</p>
</li>
<li><p>max_features ：随机选取特征时选取特征的数量，一般传入 auto 或者 log2，默认为 auto ， auto 表示 max_features=sqrt(训练集中特征的数量) ；log2 表示 max_features=log2(训练集中特征的数量)。 </p>
<p>RandomForestClassifier 类中的 fit 函数实现了随机森林分类器训练模型的功能，predict 函数实现了模型预测的功能。</p>
</li>
</ul>
<p>其中 fit 函数的参数如下：</p>
<ul>
<li>X ：大小为 [样本数量,特征数量] 的 ndarry，存放训练样本；</li>
<li>Y ：值为整型，大小为 [样本数量] 的 ndarray，存放训练样本的分类标签。</li>
</ul>
<p>而 predict 函数有一个向量输入：</p>
<ul>
<li><p>X ：大小为 [样本数量,特征数量] 的 ndarry，存放预测样本。</p>
<p>RandomForestClassifier 的使用代码如下：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"></span><br><span class="line">clf = RandomForestClassifier(n_estimators=<span class="number">50</span>)</span><br><span class="line">clf.fit(X_train, Y_train)</span><br><span class="line">result = clf.predict(X_test)</span><br></pre></td></tr></table></figure>

<h3 id="编程要求-2"><a href="#编程要求-2" class="headerlink" title="编程要求"></a>编程要求</h3><p>在右侧区域的 begin-end 之间填写<code>digit_predict(train_image, train_label, test_image)</code>函数完成手写数字分类任务，其中：</p>
<ul>
<li> train_image ：包含多条训练样本的样本集，类型为 ndarray ， shape 为 [-1, 8, 8] ，<strong>在喂给分类器之前请记得将其变形</strong>；</li>
<li> train_label ：包含多条训练样本标签的标签集，类型为 ndarray；</li>
<li> test_image ：包含多条测试样本的测试集，类型为 ndarray；</li>
<li> return ： test_image 对应的预测标签，类型为 ndarray。 </li>
</ul>
<h3 id="测试说明-2"><a href="#测试说明-2" class="headerlink" title="测试说明"></a>测试说明</h3><p>只需完成 digit_predict 函数即可，程序内部会检测您的代码，预测正确率高于 0.98 视为过关。</p>
<h3 id="参考答案-2"><a href="#参考答案-2" class="headerlink" title="参考答案"></a>参考答案</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">digit_predict</span>(<span class="params">train_image, train_label, test_image</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        实现功能：训练模型并输出预测结果</span></span><br><span class="line"><span class="string">        :param train_image: 包含多条训练样本的样本集，类型为ndarray,shape为[-1, 8, 8]</span></span><br><span class="line"><span class="string">        :param train_label: 包含多条训练样本标签的标签集，类型为ndarray</span></span><br><span class="line"><span class="string">        :param test_image: 包含多条测试样本的测试集，类型为ndarry</span></span><br><span class="line"><span class="string">        :return: test_image对应的预测标签，类型为ndarray</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ************* Begin ************#</span></span><br><span class="line">    X = np.reshape(train_image, newshape=(-<span class="number">1</span>, <span class="number">64</span>))</span><br><span class="line">    clf = RandomForestClassifier(n_estimators=<span class="number">500</span>, max_depth=<span class="number">10</span>)</span><br><span class="line">    clf.fit(X, y=train_label)</span><br><span class="line">    <span class="keyword">return</span> clf.predict(test_image)</span><br><span class="line">    <span class="comment"># ************* End **************#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Educoder</category>
        <category>ML</category>
      </categories>
      <tags>
        <tag>Educoder</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>//2023/10/30/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="二分查找的概念"><a href="#二分查找的概念" class="headerlink" title="二分查找的概念"></a>二分查找的概念</h2><blockquote>
<p>一些网站对于二分查找的解释</p>
<ol>
<li><p><a href="https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">百度百科</a>：二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081?fromModule=lemma_inlink">线性表</a>必须采用<a href="https://baike.baidu.com/item/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/1347176?fromModule=lemma_inlink">顺序存储结构</a>，而且表中元素按关键字有序排列。</p>
</li>
<li><p><a href="https://www.runoob.com/python3/python-binary-search.html">菜鸟教程</a>：二分搜索是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/Binary_search_into_array.png" alt="binary search"></p>
</li>
<li><p><a href="https://zh.wikipedia.org/zh-hans/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95">wikipedia</a>：在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中，<strong>二分查找算法</strong>（英语：binary search algorithm），也称<strong>折半搜索算法</strong>（英语：half-interval search algorithm）[<a href="https://zh.wikipedia.org/zh-hans/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95#cite_note-1">1]</a>、<strong>对数搜索算法</strong>（英语：logarithmic search algorithm）[<a href="https://zh.wikipedia.org/zh-hans/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95#cite_note-FOOTNOTEKnuth1998%C2%A76.2.1_(%22Searching_an_ordered_table%22),_subsection_%22Binary_search%22-2">2]</a>，是一种在<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E5%BA%8F%E6%95%B0%E5%AF%B9">有序数组</a>中查找某一特定元素的搜索<a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95">算法</a>。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>我的一些理解：</p>
<ol>
<li>二分查找，又称折半查找或者对数搜索等等。目的是从有序的数组中快速的找出目标值(target)</li>
<li>所以从上面的定义中我们知道，二分查找是一种搜索算法，并且要求数组是有序的(从大到小或者从小到大都行)</li>
<li>二分查找的<code>时间复杂度</code>通常的 <code>O(log n)</code>，<code>空间复杂度</code>通常是 <code>O(1)</code></li>
<li><code>一般在题目中出现数组有序，或者数组可以进行排序时使用。能够极大的提高查找的效率。</code></li>
</ol>
</blockquote>
<blockquote>
<p>网友的看法： <code>关键不在于区间里的元素具有什么性质，而是区间外面的元素具有什么性质。</code></p>
<p>也就是看最终左右指针会停在哪里。<br>如果我们要找第一个大于等于x的位置，那么我就假设L最终会停在第一个大于等于x的位置，R停在L的左边。<br>这样按照上面那句话，可以把循环不变式描述为“L的左边恒小于x，R的右边恒大于等于x”，这样一来，其他的各种条件就不言自明了。<br>比如循环条件肯定是L小于R，因为我假设R停在L的左边。<br>而L和R转移的时候，根据循环不变式，如果mid小于x，肯定要令L等于mid+1，如果大于等于x，就令R等于mid-1。<br>至于初始的时候L和R怎么选，也是看循环不变式，只需要保证初始L和R的选择满足“L的左边恒小于x，R的右边恒大于等于x”，并且不会出现越界的情况即可，L必为0，因为0左边可以看作负无穷，恒小于x，R取第一个一定满足条件的（防止mid取到非法值），例如n-1（n开始可以看作正无穷，恒大于等于x，如果保证x在数组里可以选择n-2，其实大于等于n也满足不变式，但是mid可能会取非法值），而且这样一来即使是搜索数组的某一段，也可以很方便根据这个条件地找到初始位置。</p>
<p>如果假设L最终会停在第一个大于等于x的位置，R停在L的位置，那么循环不变式就是“L的左边恒小于x，R以及R的右边恒大于等于x”，这样的话，循环条件就是L等于R的时候退出；转移的时候R=mid；初始时，一般取R=n（如果保证x在数组里，也可以取n-1）。</p>
<p>其他的情况也类似，比较直观的推导方法就是在要找的位置的分界处（比如在第一个大于等于x的位置后面）画一条线，然后假定L和R最终会停在这条线的左边还是右边，接着倒推各种条件即可。</p>
</blockquote>
<h2 id="二分查找的相关题目"><a href="#二分查找的相关题目" class="headerlink" title="二分查找的相关题目"></a>二分查找的相关题目</h2><h3 id="题目：275-H-指数-II-力扣（LeetCode）"><a href="#题目：275-H-指数-II-力扣（LeetCode）" class="headerlink" title="题目：275. H 指数 II - 力扣（LeetCode）"></a><a href="https://leetcode.cn/problems/h-index-ii/description/">题目：275. H 指数 II - 力扣（LeetCode）</a></h3><h4 id="1-题目要求："><a href="#1-题目要求：" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20231030155054847.png" alt="题目要求"></p>
<h4 id="2-问题分析："><a href="#2-问题分析：" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><p>首先，题目中有两个关键点让我们知道这题需要使用<code>二分查找</code>来解决</p>
<ol>
<li>题目中提到<code>citations</code>是有序的</li>
<li>题目要求在对数时间复杂度内解决问题</li>
</ol>
<p>这两点就可以确定，这题只能使用<code>二分查找</code>来解决。</p>
<p>具体的题目分析如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/1698492370-tnIhCf-lc275-c.png" alt="lc275-c.png"></p>
<h4 id="3-问题解决："><a href="#3-问题解决：" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><p>根据视频 <a href="https://www.bilibili.com/video/BV1AP41137w7/">二分查找 红蓝染色法 - 哔哩哔哩 (bilibili.com)</a> 我们可以知道，二分查找存在三种写法以及四种情况。</p>
<p>三种写法分别是：</p>
<ol>
<li>闭区间</li>
<li>半开半闭区间</li>
<li>开区间</li>
</ol>
<p>四种情况分别是：</p>
<ol>
<li>大于等于(≥)</li>
<li>大于(＞)</li>
<li>小于等于(≤)</li>
<li>小于(＜)</li>
</ol>
<p>其中四种情况可以相互进行转化，具体的转化方式可以参考上面提到的视频中 <a href="https://www.bilibili.com/video/BV1AP41137w7?t=580.7">如何处理不是≥的情况</a> 部分。下面将使用三种不同的写法，解决这道题目。</p>
<h5 id="1-闭区间"><a href="#1-闭区间" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hIndex</span>(<span class="params">self, citations: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 在区间 [left, right] 内询问</span></span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        right = <span class="built_in">len</span>(citations)</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 区间不为空</span></span><br><span class="line">            <span class="comment"># 循环不变量：</span></span><br><span class="line">            <span class="comment"># left-1 的回答一定为「是」</span></span><br><span class="line">            <span class="comment"># right+1 的回答一定为「否」</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 引用次数最多的 mid 篇论文，引用次数均 &gt;= mid</span></span><br><span class="line">            <span class="keyword">if</span> citations[-mid] &gt;= mid:</span><br><span class="line">                left = mid + <span class="number">1</span>  <span class="comment"># 询问范围缩小到 [mid+1, right]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span>  <span class="comment"># 询问范围缩小到 [left, mid-1]</span></span><br><span class="line">        <span class="comment"># 循环结束后 right 等于 left-1，回答一定为「是」</span></span><br><span class="line">        <span class="comment"># 根据循环不变量，right 现在是最大的回答为「是」的数</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h5 id="2-半开半闭区间"><a href="#2-半开半闭区间" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左闭右开区间写法"><a href="#1-左闭右开区间写法" class="headerlink" title="1. 左闭右开区间写法"></a>1. 左闭右开区间写法</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hIndex</span>(<span class="params">self, citations: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 在区间 [left, right) 内询问</span></span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        right = <span class="built_in">len</span>(citations) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:  <span class="comment"># 区间不为空</span></span><br><span class="line">            <span class="comment"># 循环不变量：</span></span><br><span class="line">            <span class="comment"># left-1 的回答一定为「是」</span></span><br><span class="line">            <span class="comment"># right 的回答一定为「否」</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 引用次数最多的 mid 篇论文，引用次数均 &gt;= mid</span></span><br><span class="line">            <span class="keyword">if</span> citations[-mid] &gt;= mid:</span><br><span class="line">                left = mid + <span class="number">1</span>  <span class="comment"># 询问范围缩小到 [mid+1, right)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid  <span class="comment"># 询问范围缩小到 [left, mid)</span></span><br><span class="line">        <span class="comment"># 根据循环不变量，left-1 现在是最大的回答为「是」的数</span></span><br><span class="line">        <span class="keyword">return</span> left - <span class="number">1</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h6 id="2-左开右闭区间写法"><a href="#2-左开右闭区间写法" class="headerlink" title="2. 左开右闭区间写法"></a>2. 左开右闭区间写法</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hIndex</span>(<span class="params">self, citations: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 在区间 (left, right] 内询问</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(citations)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:  <span class="comment"># 区间不为空</span></span><br><span class="line">            <span class="comment"># 循环不变量：</span></span><br><span class="line">            <span class="comment"># left 的回答一定为「是」</span></span><br><span class="line">            <span class="comment"># right+1 的回答一定为「否」</span></span><br><span class="line">            mid = (left + right + <span class="number">1</span>) // <span class="number">2</span>  <span class="comment"># 保证 mid 在二分区间内</span></span><br><span class="line">            <span class="comment"># 引用次数最多的 mid 篇论文，引用次数均 &gt;= mid</span></span><br><span class="line">            <span class="keyword">if</span> citations[-mid] &gt;= mid:</span><br><span class="line">                left = mid  <span class="comment"># 询问范围缩小到 (mid, right]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span>  <span class="comment"># 询问范围缩小到 (left, mid-1]</span></span><br><span class="line">        <span class="comment"># 根据循环不变量，left 现在是最大的回答为「是」的数</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h5 id="3-开区间"><a href="#3-开区间" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hIndex</span>(<span class="params">self, citations: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 在区间 (left, right) 内询问</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(citations) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:  <span class="comment"># 区间不为空</span></span><br><span class="line">            <span class="comment"># 循环不变量：</span></span><br><span class="line">            <span class="comment"># left 的回答一定为「是」</span></span><br><span class="line">            <span class="comment"># right 的回答一定为「否」</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 引用次数最多的 mid 篇论文，引用次数均 &gt;= mid</span></span><br><span class="line">            <span class="keyword">if</span> citations[-mid] &gt;= mid:</span><br><span class="line">                left = mid  <span class="comment"># 询问范围缩小到 (mid, right)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid  <span class="comment"># 询问范围缩小到 (left, mid)</span></span><br><span class="line">        <span class="comment"># 根据循环不变量，left 现在是最大的回答为「是」的数</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细的题解可以参考：<a href="https://leetcode.cn/problems/h-index-ii/solutions/2504326/tu-jie-yi-tu-zhang-wo-er-fen-da-an-si-ch-d15k/">275. H 指数 II - 力扣（LeetCode）</a></p>
<h3 id="题目：34-在排序数组中查找元素的第一个和最后一个位置"><a href="#题目：34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="题目：34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">题目：34. 在排序数组中查找元素的第一个和最后一个位置</a></h3><h4 id="1-题目要求：-1"><a href="#1-题目要求：-1" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20231030205656237.png" alt="题目要求"></p>
<h4 id="2-问题分析：-1"><a href="#2-问题分析：-1" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><ol>
<li>数组 <code>nums </code> 是有序的，有序的数组就可以考虑使用二分查找的方法</li>
<li>问题的要求是找到第一个和最后一个元素，所以可以使用二分查找方法，快速定位问题中的要求的位置</li>
</ol>
<p>具体的问题分析可以查看 <a href="https://www.bilibili.com/video/BV1AP41137w7">二分查找 红蓝染色法</a></p>
<h4 id="3-问题解决：-1"><a href="#3-问题解决：-1" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-1"><a href="#1-闭区间-1" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*-coding: Utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Packages: leetcode-daily-algorithm-challenge</span></span><br><span class="line"><span class="comment"># @File : __init__.py.py</span></span><br><span class="line"><span class="comment"># @Author: David</span></span><br><span class="line"><span class="comment"># @Date: 2023/10/29 14:36</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    下界(lower bound)函数, 闭区间写法</span></span><br><span class="line"><span class="string">    找到第一个大于等于 target 元素的下标</span></span><br><span class="line"><span class="string">    问题分析</span></span><br><span class="line"><span class="string">        循环不变量:</span></span><br><span class="line"><span class="string">            left 的左边全部都是小于 target 的元素</span></span><br><span class="line"><span class="string">            right 右边全部都是大于等于 target 的元素</span></span><br><span class="line"><span class="string">        最后的结果会是 right + 1 = left, 所以既可以返回 left, 也可以返回 right + 1</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :param target:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>  <span class="comment"># 搜索的范围 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 如果区间不为空</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span>  <span class="comment"># 这种写法可以避免 (right + left) // 2 导致的溢出问题</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt;= target:</span><br><span class="line">            right = mid - <span class="number">1</span>  <span class="comment"># 收缩右边界</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span>  <span class="comment"># 收缩左边界</span></span><br><span class="line">    <span class="keyword">return</span> left  <span class="comment"># 返回结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        start = lower_bound(nums, target)</span><br><span class="line">        <span class="keyword">if</span> start == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[start] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        end = lower_bound(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [start, end]</span><br></pre></td></tr></table></figure>



<h5 id="2-半开半闭区间-1"><a href="#2-半开半闭区间-1" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左闭右开区间写法-1"><a href="#1-左闭右开区间写法-1" class="headerlink" title="1. 左闭右开区间写法"></a>1. 左闭右开区间写法</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*-coding: Utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Packages: leetcode-daily-algorithm-challenge</span></span><br><span class="line"><span class="comment"># @File : __init__.py.py</span></span><br><span class="line"><span class="comment"># @Author: David</span></span><br><span class="line"><span class="comment"># @Date: 2023/10/29 14:36</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    下界(lower bound)函数, 左闭右开区间写法</span></span><br><span class="line"><span class="string">    找到第一个大于等于 target 元素的下标</span></span><br><span class="line"><span class="string">    问题分析</span></span><br><span class="line"><span class="string">        循环不变量:</span></span><br><span class="line"><span class="string">            left 的左边全部都是小于 target 的元素</span></span><br><span class="line"><span class="string">            right 右边全部都是大于等于 target 的元素</span></span><br><span class="line"><span class="string">        最后的结果会是 right = left, 所以既可以返回 left, 也可以返回 right</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :param target:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr)  <span class="comment"># 搜索的范围 [left, right)</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:  <span class="comment"># 如果区间不为空</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span>  <span class="comment"># 这种写法可以避免 (right + left) // 2 导致的溢出问题</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt;= target:</span><br><span class="line">            right = mid  <span class="comment"># 收缩右边界</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span>  <span class="comment"># 收缩左边界</span></span><br><span class="line">    <span class="keyword">return</span> left  <span class="comment"># 返回结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        start = lower_bound(nums, target)</span><br><span class="line">        <span class="keyword">if</span> start == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[start] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        end = lower_bound(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [start, end]</span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间写法"><a href="#2-左闭右开区间写法" class="headerlink" title="2. 左闭右开区间写法"></a>2. 左闭右开区间写法</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*-coding: Utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Packages: leetcode-daily-algorithm-challenge</span></span><br><span class="line"><span class="comment"># @File : __init__.py.py</span></span><br><span class="line"><span class="comment"># @Author: David</span></span><br><span class="line"><span class="comment"># @Date: 2023/10/29 14:36</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    下界(lower bound)函数, 左闭右开区间写法</span></span><br><span class="line"><span class="string">    找到第一个大于等于 target 元素的下标</span></span><br><span class="line"><span class="string">    问题分析</span></span><br><span class="line"><span class="string">        循环不变量:</span></span><br><span class="line"><span class="string">            left 的左边全部都是小于 target 的元素</span></span><br><span class="line"><span class="string">            right 右边全部都是大于等于 target 的元素</span></span><br><span class="line"><span class="string">        最后的结果会是 (right - 1) + 1 = left, 所以既可以返回 left, 也可以返回 right</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :param target:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr)  <span class="comment"># 搜索的范围 [left, right)</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right - <span class="number">1</span>:  <span class="comment"># 如果区间不为空</span></span><br><span class="line">        mid = left + ((right - <span class="number">1</span>) - left) // <span class="number">2</span>  <span class="comment"># 这种写法可以避免 (right + left) // 2 导致的溢出问题</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt;= target:</span><br><span class="line">            right = mid  <span class="comment"># 收缩右边界</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span>  <span class="comment"># 收缩左边界</span></span><br><span class="line">    <span class="keyword">return</span> left  <span class="comment"># 返回结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        start = lower_bound(nums, target)</span><br><span class="line">        <span class="keyword">if</span> start == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[start] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        end = lower_bound(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [start, end]</span><br></pre></td></tr></table></figure>

<h6 id="3-左开右闭区间写法"><a href="#3-左开右闭区间写法" class="headerlink" title="3. 左开右闭区间写法"></a>3. 左开右闭区间写法</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*-coding: Utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Packages: leetcode-daily-algorithm-challenge</span></span><br><span class="line"><span class="comment"># @File : __init__.py.py</span></span><br><span class="line"><span class="comment"># @Author: David</span></span><br><span class="line"><span class="comment"># @Date: 2023/10/29 14:36</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    下界(lower bound)函数, 左开右闭区间写法</span></span><br><span class="line"><span class="string">    找到第一个大于等于 target 元素的下标</span></span><br><span class="line"><span class="string">    问题分析</span></span><br><span class="line"><span class="string">        循环不变量:</span></span><br><span class="line"><span class="string">            left 的左边全部都是小于 target 的元素</span></span><br><span class="line"><span class="string">            right 右边全部都是大于等于 target 的元素</span></span><br><span class="line"><span class="string">        最后的结果会是 right + 1 = left + 1, 所以既可以返回 right + 1, 也可以返回 left + 1</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :param target:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = -<span class="number">1</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>  <span class="comment"># 搜索的范围 (left, right]</span></span><br><span class="line">    <span class="keyword">while</span> left + <span class="number">1</span> &lt;= right:  <span class="comment"># 如果区间不为空</span></span><br><span class="line">        mid = (left + <span class="number">1</span>) + (right - (left + <span class="number">1</span>)) // <span class="number">2</span>  <span class="comment"># 这种写法可以避免 (right + left) // 2 导致的溢出问题</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt;= target:</span><br><span class="line">            right = mid - <span class="number">1</span>  <span class="comment"># 收缩右边界</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid  <span class="comment"># 收缩左边界</span></span><br><span class="line">    <span class="keyword">return</span> left + <span class="number">1</span>  <span class="comment"># 返回结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        start = lower_bound(nums, target)</span><br><span class="line">        <span class="keyword">if</span> start == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[start] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        end = lower_bound(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [start, end]</span><br></pre></td></tr></table></figure>



<h5 id="3-开区间-1"><a href="#3-开区间-1" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    <span class="comment"># -*-coding: Utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Packages: leetcode-daily-algorithm-challenge</span></span><br><span class="line"><span class="comment"># @File : __init__.py.py</span></span><br><span class="line"><span class="comment"># @Author: David</span></span><br><span class="line"><span class="comment"># @Date: 2023/10/29 14:36</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    下界(lower bound)函数, 开区间写法</span></span><br><span class="line"><span class="string">    找到第一个大于等于 target 元素的下标</span></span><br><span class="line"><span class="string">    问题分析</span></span><br><span class="line"><span class="string">        循环不变量:</span></span><br><span class="line"><span class="string">            left 的左边全部都是小于 target 的元素</span></span><br><span class="line"><span class="string">            right 右边全部都是大于等于 target 的元素</span></span><br><span class="line"><span class="string">        最后的结果会是 right = left + 1, 所以既可以返回 right, 也可以返回 left + 1</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :param target:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = -<span class="number">1</span>, <span class="built_in">len</span>(arr)  <span class="comment"># 搜索的范围 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> left + <span class="number">1</span> &lt;= right - <span class="number">1</span>:  <span class="comment"># 如果区间不为空</span></span><br><span class="line">        mid = (left + <span class="number">1</span>) + ((right - <span class="number">1</span>) - (left + <span class="number">1</span>)) // <span class="number">2</span>  <span class="comment"># 这种写法可以避免 (right + left) // 2 导致的溢出问题</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] &gt;= target:</span><br><span class="line">            right = mid  <span class="comment"># 收缩右边界</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid  <span class="comment"># 收缩左边界</span></span><br><span class="line">    <span class="keyword">return</span> left + <span class="number">1</span>  <span class="comment"># 返回结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        start = lower_bound(nums, target)</span><br><span class="line">        <span class="keyword">if</span> start == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[start] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        end = lower_bound(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [start, end]</span><br></pre></td></tr></table></figure>



<h3 id="题目：1283-使结果不超过阈值的最小除数-力扣（LeetCode）"><a href="#题目：1283-使结果不超过阈值的最小除数-力扣（LeetCode）" class="headerlink" title="题目：1283. 使结果不超过阈值的最小除数 - 力扣（LeetCode）"></a>题目：<a href="https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/description/">1283. 使结果不超过阈值的最小除数 - 力扣（LeetCode）</a></h3><h4 id="1-题目要求：-2"><a href="#1-题目要求：-2" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20231103161142018.png" alt="image-20231103161142018"></p>
<h4 id="2-问题分析：-2"><a href="#2-问题分析：-2" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><ol>
<li>求解最大化最小值问题，数组<code>nums</code>的顺序可以是有序的也可以是无序的。</li>
<li>阈值<code>threshold</code>的取值范围是<code>[nums.length, 10^6]</code>我们需要求解的答案是是的除数之和小于等于阈值的最小正整数</li>
<li>通过分析得知，我们除数越大，得到的<code>商的和</code>越小，越能够满足题目的条件，但是题目要求除数<code>最小</code>，所以得到的<code>商最大</code>，这就是典型的最大化最小值问题</li>
<li>我们可以在<code>[1, 10^6]</code>范围内找到需要求的正整数，且<code>越靠近右边，得到的商越小</code>，越能够满足商的和小于<code>threshold</code>的要求。并且答案的取值范围天然的有序，所以我们可以使用二分查找的方式求解问题。</li>
</ol>
<h4 id="3-问题解决：-2"><a href="#3-问题解决：-2" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-2"><a href="#1-闭区间-2" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> math.ceil(a / b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    最小化最大值类型：</span></span><br><span class="line"><span class="string">        给你一个整数数组 nums 和一个正整数 threshold  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。</span></span><br><span class="line"><span class="string">        请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。</span></span><br><span class="line"><span class="string">        每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。 题目保证一定有解。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestDivisor</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], threshold: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        最小化最大值问题，使用二分法求解：</span></span><br><span class="line"><span class="string">        1. 先将数组从小到达排序</span></span><br><span class="line"><span class="string">        2. 循环不变量:</span></span><br><span class="line"><span class="string">            1. left 的左边都是满足题目要求小于等于阈值的正整数, 但是除数之和从大到小进行排序</span></span><br><span class="line"><span class="string">            2. right 的右边都是不满足题目条件的正整数</span></span><br><span class="line"><span class="string">        :param nums:</span></span><br><span class="line"><span class="string">        :param threshold:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left, right = <span class="number">1</span>, <span class="number">10</span> ** <span class="number">6</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(divide(num, mid) <span class="keyword">for</span> num <span class="keyword">in</span> nums) &gt; threshold:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-2"><a href="#2-半开半闭区间-2" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间"><a href="#1-左开右闭区间" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], threshold: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        最小化最大值问题，使用二分法求解, 左开右闭区间写法：</span></span><br><span class="line"><span class="string">        1. 循环不变量:</span></span><br><span class="line"><span class="string">            1. left 的左边都是满足题目要求小于等于阈值的正整数, 但是除数之和从大到小进行排序</span></span><br><span class="line"><span class="string">            2. right 的右边都是不满足题目条件的正整数</span></span><br><span class="line"><span class="string">        最终的结果是 left + 1 = right + 1 所以返回 left + 1 或者 right + 1 都行</span></span><br><span class="line"><span class="string">        :param nums:</span></span><br><span class="line"><span class="string">        :param threshold:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">10</span> ** <span class="number">6</span></span><br><span class="line">    <span class="keyword">while</span> left + <span class="number">1</span> &lt;= right:</span><br><span class="line">        mid = (left + right + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(math.ceil(num / mid) <span class="keyword">for</span> num <span class="keyword">in</span> nums) &gt; threshold:</span><br><span class="line">            left = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    最小化最大值类型：</span></span><br><span class="line"><span class="string">        给你一个整数数组 nums 和一个正整数 threshold  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。</span></span><br><span class="line"><span class="string">        请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。</span></span><br><span class="line"><span class="string">        每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。 题目保证一定有解。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestDivisor</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], threshold: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> lower_bound(nums, threshold)</span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间"><a href="#2-左闭右开区间" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], threshold: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        最小化最大值问题，使用二分法求解, 左闭右开区间写法：</span></span><br><span class="line"><span class="string">        1. 循环不变量:</span></span><br><span class="line"><span class="string">            1. left 的左边都是满足题目要求小于等于阈值的正整数, 但是除数之和从大到小进行排序</span></span><br><span class="line"><span class="string">            2. right 的右边都是不满足题目条件的正整数</span></span><br><span class="line"><span class="string">        最终的结果是 left = right + 2 所以返回 left 或者 right + 2 都行</span></span><br><span class="line"><span class="string">        :param nums:</span></span><br><span class="line"><span class="string">        :param threshold:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">1</span>, <span class="number">10</span> ** <span class="number">6</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right + <span class="number">1</span>:</span><br><span class="line">        mid = (left + right + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(math.ceil(num / mid) <span class="keyword">for</span> num <span class="keyword">in</span> nums) &gt; threshold:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    最小化最大值类型：</span></span><br><span class="line"><span class="string">        给你一个整数数组 nums 和一个正整数 threshold  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。</span></span><br><span class="line"><span class="string">        请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。</span></span><br><span class="line"><span class="string">        每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。 题目保证一定有解。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestDivisor</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], threshold: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> lower_bound(nums, threshold)</span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-2"><a href="#3-开区间-2" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], threshold: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        最小化最大值问题，使用二分法求解, 开区间写法：</span></span><br><span class="line"><span class="string">        1. 循环不变量:</span></span><br><span class="line"><span class="string">            1. left 的左边都是满足题目要求小于等于阈值的正整数, 但是除数之和从大到小进行排序</span></span><br><span class="line"><span class="string">            2. right 的右边都是不满足题目条件的正整数</span></span><br><span class="line"><span class="string">        最终的结果是 left + 1 = (right - 1) + 1 所以返回 left + 1 或者 right + 1 都行</span></span><br><span class="line"><span class="string">        :param nums:</span></span><br><span class="line"><span class="string">        :param threshold:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">10</span> ** <span class="number">6</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left + <span class="number">1</span> &lt;= right - <span class="number">1</span>:</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>(math.ceil(num / mid) <span class="keyword">for</span> num <span class="keyword">in</span> nums) &gt; threshold:</span><br><span class="line">            left = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">return</span> left + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    最小化最大值类型：</span></span><br><span class="line"><span class="string">        给你一个整数数组 nums 和一个正整数 threshold  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。</span></span><br><span class="line"><span class="string">        请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。</span></span><br><span class="line"><span class="string">        每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。 题目保证一定有解。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestDivisor</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], threshold: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> lower_bound(nums, threshold)</span><br></pre></td></tr></table></figure>



<h3 id="题目：2187-完成旅途的最少时间-leetcode-cn"><a href="#题目：2187-完成旅途的最少时间-leetcode-cn" class="headerlink" title="题目：2187. 完成旅途的最少时间 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/minimum-time-to-complete-trips/">2187. 完成旅途的最少时间 (leetcode.cn)</a></h3><h4 id="1-题目要求：-3"><a href="#1-题目要求：-3" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20231103162536304.png" alt="image-20231103162536304"></p>
<h4 id="2-问题分析：-3"><a href="#2-问题分析：-3" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><ol>
<li>求解最大化最小值问题，花费时间越长，能够完成的最大旅行次数越多，我们需要求解的是能够完成 <code>totalTrips</code>次旅途花费最少的时间。</li>
<li>设花费的最少时间为<code>t</code>，则 <code>t</code> 的取值范围是: <code>[1, time[-1] * totalTrips]</code> 其中<code>time</code>已经从小到大排序</li>
<li>所以我们知道答案<code>t</code>的取值范围天然是有序的，可以使用二分查找的方法求解。</li>
</ol>
<h4 id="3-问题解决：-3"><a href="#3-问题解决：-3" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-3"><a href="#1-闭区间-3" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">time: <span class="type">List</span>[<span class="built_in">int</span>], totalTrips: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    最大化最小值，使用二分法求解，闭区间写法</span></span><br><span class="line"><span class="string">    循环不变量:</span></span><br><span class="line"><span class="string">        1. left 的左边的所有值都不满足题目的要求, 即 t = left 时刻不能完成 totalTrips 次旅途</span></span><br><span class="line"><span class="string">        2. right 的右边的所有值都满足题目的要求, 即 t = right 时刻可以完成 totalTrips 次旅途</span></span><br><span class="line"><span class="string">    :param time:</span></span><br><span class="line"><span class="string">    :param totalTrips:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(time) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> time[<span class="number">0</span>] * totalTrips</span><br><span class="line">    time.sort()</span><br><span class="line">    left, right = <span class="number">1</span>, time[-<span class="number">1</span>] * totalTrips</span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:  <span class="comment"># 区间不为空, 搜索的区间为: [left, right]</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        max_trips = <span class="built_in">sum</span>(mid // t <span class="keyword">for</span> t <span class="keyword">in</span> time)</span><br><span class="line">        <span class="keyword">if</span> max_trips &gt;= totalTrips:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumTime</span>(<span class="params">self, time: <span class="type">List</span>[<span class="built_in">int</span>], totalTrips: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> lower_bound(time, totalTrips)</span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-3"><a href="#2-半开半闭区间-3" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-1"><a href="#1-左开右闭区间-1" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">time: <span class="type">List</span>[<span class="built_in">int</span>], totalTrips: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    最大化最小值，使用二分法求解，左开右闭区间写法</span></span><br><span class="line"><span class="string">    循环不变量:</span></span><br><span class="line"><span class="string">        1. left 的左边的所有值都不满足题目的要求, 即 t = left 时刻不能完成 totalTrips 次旅途</span></span><br><span class="line"><span class="string">        2. right 的右边的所有值都满足题目的要求, 即 t = right 时刻可以完成 totalTrips 次旅途</span></span><br><span class="line"><span class="string">    最终的结果 left + 1 = right + 1, 所以既可以返回 left + 1, 也可以返回 right + 1</span></span><br><span class="line"><span class="string">    :param time:</span></span><br><span class="line"><span class="string">    :param totalTrips:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(time) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> time[<span class="number">0</span>] * totalTrips</span><br><span class="line">    time.sort()</span><br><span class="line">    left, right = <span class="number">0</span>, time[-<span class="number">1</span>] * totalTrips</span><br><span class="line">    <span class="keyword">while</span> left + <span class="number">1</span> &lt;= right:  <span class="comment"># 区间不为空, 搜索的区间为: (left, right]</span></span><br><span class="line">        mid = left + <span class="number">1</span> + (right - left - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        max_trips = <span class="built_in">sum</span>(mid // t <span class="keyword">for</span> t <span class="keyword">in</span> time)</span><br><span class="line">        <span class="keyword">if</span> max_trips &gt;= totalTrips:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid</span><br><span class="line">    <span class="keyword">return</span> left + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumTime</span>(<span class="params">self, time: <span class="type">List</span>[<span class="built_in">int</span>], totalTrips: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> lower_bound(time, totalTrips)</span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-1"><a href="#2-左闭右开区间-1" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">time: <span class="type">List</span>[<span class="built_in">int</span>], totalTrips: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    最大化最小值，使用二分法求解，左闭右开区间写法</span></span><br><span class="line"><span class="string">    循环不变量:</span></span><br><span class="line"><span class="string">        1. left 的左边的所有值都不满足题目的要求, 即 t = left 时刻不能完成 totalTrips 次旅途</span></span><br><span class="line"><span class="string">        2. right 的右边的所有值都满足题目的要求, 即 t = right 时刻可以完成 totalTrips 次旅途</span></span><br><span class="line"><span class="string">    最终的结果 left = (right - 1) + 1, 所以既可以返回 left, 也可以返回 right</span></span><br><span class="line"><span class="string">    :param time:</span></span><br><span class="line"><span class="string">    :param totalTrips:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(time) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> time[<span class="number">0</span>] * totalTrips</span><br><span class="line">    time.sort()</span><br><span class="line">    left, right = <span class="number">1</span>, time[-<span class="number">1</span>] * totalTrips + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right - <span class="number">1</span>:  <span class="comment"># 区间不为空, 搜索的区间为: [left, right)</span></span><br><span class="line">        mid = left + (right - <span class="number">1</span> - left) // <span class="number">2</span></span><br><span class="line">        max_trips = <span class="built_in">sum</span>(mid // t <span class="keyword">for</span> t <span class="keyword">in</span> time)</span><br><span class="line">        <span class="keyword">if</span> max_trips &gt;= totalTrips:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumTime</span>(<span class="params">self, time: <span class="type">List</span>[<span class="built_in">int</span>], totalTrips: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> lower_bound(time, totalTrips)</span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-3"><a href="#3-开区间-3" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">time: <span class="type">List</span>[<span class="built_in">int</span>], totalTrips: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    最大化最小值，使用二分法求解，开区间写法</span></span><br><span class="line"><span class="string">    循环不变量:</span></span><br><span class="line"><span class="string">        1. left 的左边的所有值都不满足题目的要求, 即 t = left 时刻不能完成 totalTrips 次旅途</span></span><br><span class="line"><span class="string">        2. right 的右边的所有值都满足题目的要求, 即 t = right 时刻可以完成 totalTrips 次旅途</span></span><br><span class="line"><span class="string">    最终的结果 left + 1 = (right - 1) + 1, 所以既可以返回 left + 1, 也可以返回 right</span></span><br><span class="line"><span class="string">    :param time:</span></span><br><span class="line"><span class="string">    :param totalTrips:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(time) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> time[<span class="number">0</span>] * totalTrips</span><br><span class="line">    time.sort()</span><br><span class="line">    left, right = <span class="number">0</span>, time[-<span class="number">1</span>] * totalTrips + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left + <span class="number">1</span> &lt;= right - <span class="number">1</span>:  <span class="comment"># 区间不为空, 搜索的区间为: (left, right)</span></span><br><span class="line">        mid = (right + left) // <span class="number">2</span></span><br><span class="line">        max_trips = <span class="built_in">sum</span>(mid // t <span class="keyword">for</span> t <span class="keyword">in</span> time)</span><br><span class="line">        <span class="keyword">if</span> max_trips &gt;= totalTrips:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumTime</span>(<span class="params">self, time: <span class="type">List</span>[<span class="built_in">int</span>], totalTrips: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> lower_bound(time, totalTrips)</span><br></pre></td></tr></table></figure>



<h3 id="题目：2226-每个小孩最多能分到多少糖果-leetcode-cn"><a href="#题目：2226-每个小孩最多能分到多少糖果-leetcode-cn" class="headerlink" title="题目：2226. 每个小孩最多能分到多少糖果 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/">2226. 每个小孩最多能分到多少糖果 (leetcode.cn)</a></h3><h4 id="1-题目要求：-4"><a href="#1-题目要求：-4" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20231216154151715.png" alt="image-20231216154151715"></p>
<h4 id="2-问题分析：-4"><a href="#2-问题分析：-4" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><ol>
<li>求解最大值问题，题目要求的要求是：<ul>
<li>每个小孩拿到的糖果数量相同</li>
<li>每个小孩拿到的糖果数量尽量最大</li>
<li>每堆糖果只能拆分不能合并</li>
</ul>
</li>
<li>根据题目的要求，我们可以使用二分的方式求解(==<strong>注：</strong>== 一般遇到求最大值 or 最小值的问题，尽量使用二分法求解，这样时间复杂度会比较小)</li>
<li>我们枚举每个小孩能够拿到的最多的糖果数量，记作：<code>x</code>， <code>x</code> 的取值范围是<code>[1， max(candies)]</code> </li>
<li>每次枚举中间值 <code>mid</code> 的时候，需要判断中间值 <code>mid</code> 是否能够满足题目的要求。 </li>
</ol>
<p>==<strong>注：</strong>== 代码中使用的 <code>mid</code> 表示想要分配给每个小孩的糖果数量，<code>cnt</code> 表示<code>candies</code>能够分配给<code>cnt</code>个小孩数量为<code>mid</code> 的糖果</p>
<h4 id="3-问题解决：-4"><a href="#3-问题解决：-4" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-4"><a href="#1-闭区间-4" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">candies: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    求最大值问题, 使用二分法求解, 闭区间写法</span></span><br><span class="line"><span class="string">    循环不变量：</span></span><br><span class="line"><span class="string">        1. left 的左边的所有值都能满足题目的要求, 即 res = left 时 k 个小孩肯定能够拿到 left 颗糖果</span></span><br><span class="line"><span class="string">        2. right 的右边的所有值都不满足题目的要求, 即 res = right 时, k 个小孩肯定不能能够拿到 right 颗糖果</span></span><br><span class="line"><span class="string">        left 和 right 都表示 k 个小孩能够拿到的糖果数量, 题目要求所有小孩能够拿到的糖果数量相同并且尽量最大</span></span><br><span class="line"><span class="string">        所以最后的结果 left = right + 1, 既可以返回 right 也可以返回 left - 1</span></span><br><span class="line"><span class="string">    :param candies:</span></span><br><span class="line"><span class="string">    :param k:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">1</span>, candies[-<span class="number">1</span>]  <span class="comment"># 左右边界</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        cnt, mid = <span class="number">0</span>, (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> candies:</span><br><span class="line">            cnt += x // mid</span><br><span class="line">        <span class="keyword">if</span> cnt &gt;= k:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumCandies</span>(<span class="params">self, candies: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="built_in">sum</span>(candies):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># 特殊情况的判断</span></span><br><span class="line">        candies.sort()  <span class="comment"># 将 candies 数组排序</span></span><br><span class="line">        <span class="keyword">return</span> lower_bound(candies, k)</span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-4"><a href="#2-半开半闭区间-4" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-2"><a href="#1-左开右闭区间-2" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">candies: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    求最大值问题, 使用二分法求解, 左开右闭区间写法</span></span><br><span class="line"><span class="string">    循环不变量：</span></span><br><span class="line"><span class="string">        1. left 的左边的所有值都能满足题目的要求, 即 res = left 时 k 个小孩肯定能够拿到 left 颗糖果</span></span><br><span class="line"><span class="string">        2. right 的右边的所有值都不满足题目的要求, 即 res = right 时, k 个小孩肯定不能能够拿到 right 颗糖果</span></span><br><span class="line"><span class="string">        left 和 right 都表示 k 个小孩能够拿到的糖果数量, 题目要求所有小孩能够拿到的糖果数量相同并且尽量最大</span></span><br><span class="line"><span class="string">        所以最后的结果 left + 1 = right + 1 ==&gt; left = right , 既可以返回 right 也可以返回 left</span></span><br><span class="line"><span class="string">    :param candies:</span></span><br><span class="line"><span class="string">    :param k:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">0</span>, candies[-<span class="number">1</span>]  <span class="comment"># 左右边界</span></span><br><span class="line">    <span class="keyword">while</span> left + <span class="number">1</span> &lt;= right:</span><br><span class="line">        cnt, mid = <span class="number">0</span>, ((left + <span class="number">1</span>) + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> candies:</span><br><span class="line">            cnt += x // mid</span><br><span class="line">        <span class="keyword">if</span> cnt &gt;= k:</span><br><span class="line">            left = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="comment"># return (left + 1) - 1</span></span><br><span class="line">    <span class="keyword">return</span> left  <span class="comment"># +1 -1 抵消, 直接返回 left</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumCandies</span>(<span class="params">self, candies: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="built_in">sum</span>(candies):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># 特殊情况的判断</span></span><br><span class="line">        candies.sort()  <span class="comment"># 将 candies 数组排序</span></span><br><span class="line">        <span class="keyword">return</span> lower_bound(candies, k)</span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-2"><a href="#2-左闭右开区间-2" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">candies: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    求最大值问题, 使用二分法求解, 左闭右开区间写法</span></span><br><span class="line"><span class="string">    循环不变量：</span></span><br><span class="line"><span class="string">        1. left 的左边的所有值都能满足题目的要求, 即 res = left 时 k 个小孩肯定能够拿到 left 颗糖果</span></span><br><span class="line"><span class="string">        2. right 的右边的所有值都不满足题目的要求, 即 res = right 时, k 个小孩肯定不能能够拿到 right 颗糖果</span></span><br><span class="line"><span class="string">        left 和 right 都表示 k 个小孩能够拿到的糖果数量, 题目要求所有小孩能够拿到的糖果数量相同并且尽量最大</span></span><br><span class="line"><span class="string">        所以最后的结果 left = (right - 1) + 1 ==&gt; left = right, 既可以返回 right - 1 也可以返回 left - 1</span></span><br><span class="line"><span class="string">    :param candies:</span></span><br><span class="line"><span class="string">    :param k:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">1</span>, candies[-<span class="number">1</span>] + <span class="number">1</span>  <span class="comment"># 左右边界</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= (right - <span class="number">1</span>):</span><br><span class="line">        cnt, mid = <span class="number">0</span>, ((right - <span class="number">1</span>) + left) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> candies:</span><br><span class="line">            cnt += x // mid</span><br><span class="line">        <span class="keyword">if</span> cnt &gt;= k:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumCandies</span>(<span class="params">self, candies: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="built_in">sum</span>(candies):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># 特殊情况的判断</span></span><br><span class="line">        candies.sort()  <span class="comment"># 将 candies 数组排序</span></span><br><span class="line">        <span class="keyword">return</span> lower_bound(candies, k)</span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-4"><a href="#3-开区间-4" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">candies: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    求最大值问题, 使用二分法求解, 开区间写法</span></span><br><span class="line"><span class="string">    循环不变量：</span></span><br><span class="line"><span class="string">        1. left 的左边的所有值都能满足题目的要求, 即 res = left 时 k 个小孩肯定能够拿到 left 颗糖果</span></span><br><span class="line"><span class="string">        2. right 的右边的所有值都不满足题目的要求, 即 res = right 时, k 个小孩肯定不能能够拿到 right 颗糖果</span></span><br><span class="line"><span class="string">        left 和 right 都表示 k 个小孩能够拿到的糖果数量, 题目要求所有小孩能够拿到的糖果数量相同并且尽量最大</span></span><br><span class="line"><span class="string">        所以最后的结果 (left + 1) = (right - 1) + 1 ==&gt; left = right - 1, 既可以返回 right 也可以返回 left</span></span><br><span class="line"><span class="string">    :param candies:</span></span><br><span class="line"><span class="string">    :param k:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">0</span>, candies[-<span class="number">1</span>] + <span class="number">1</span>  <span class="comment"># 左右边界</span></span><br><span class="line">    <span class="keyword">while</span> left + <span class="number">1</span> &lt;= right - <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># cnt, mid = 0, ((left + 1) + (right - 1)) &gt;&gt; 1</span></span><br><span class="line">        cnt, mid = <span class="number">0</span>, (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> candies:</span><br><span class="line">            cnt += x // mid</span><br><span class="line">        <span class="keyword">if</span> cnt &gt;= k:</span><br><span class="line">            left = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="comment"># return (left + 1) - 1</span></span><br><span class="line">    <span class="keyword">return</span> right - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumCandies</span>(<span class="params">self, candies: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="built_in">sum</span>(candies):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># 特殊情况的判断</span></span><br><span class="line">        candies.sort()  <span class="comment"># 将 candies 数组排序</span></span><br><span class="line">        <span class="keyword">return</span> lower_bound(candies, k)</span><br></pre></td></tr></table></figure>



<h3 id="题目：1870-准时到达的列车最小时速-leetcode-cn"><a href="#题目：1870-准时到达的列车最小时速-leetcode-cn" class="headerlink" title="题目：1870. 准时到达的列车最小时速 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/">1870. 准时到达的列车最小时速 (leetcode.cn)</a></h3><h4 id="1-题目要求：-5"><a href="#1-题目要求：-5" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-5"><a href="#2-问题分析：-5" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-5"><a href="#3-问题解决：-5" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-5"><a href="#1-闭区间-5" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-5"><a href="#2-半开半闭区间-5" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-3"><a href="#1-左开右闭区间-3" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-3"><a href="#2-左闭右开区间-3" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-5"><a href="#3-开区间-5" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="TODO-未完待续"><a href="#TODO-未完待续" class="headerlink" title="TODO 未完待续 ..."></a>TODO 未完待续 ...</h2><h3 id="题目：1011-在-D-天内送达包裹的能力-leetcode-cn"><a href="#题目：1011-在-D-天内送达包裹的能力-leetcode-cn" class="headerlink" title="题目：1011. 在 D 天内送达包裹的能力 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力 (leetcode.cn)</a></h3><h4 id="1-题目要求：-6"><a href="#1-题目要求：-6" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-6"><a href="#2-问题分析：-6" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-6"><a href="#3-问题解决：-6" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-6"><a href="#1-闭区间-6" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-6"><a href="#2-半开半闭区间-6" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-4"><a href="#1-左开右闭区间-4" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-4"><a href="#2-左闭右开区间-4" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-6"><a href="#3-开区间-6" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：875-爱吃香蕉的珂珂-leetcode-cn"><a href="#题目：875-爱吃香蕉的珂珂-leetcode-cn" class="headerlink" title="题目：875. 爱吃香蕉的珂珂 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/koko-eating-bananas/">875. 爱吃香蕉的珂珂 (leetcode.cn)</a></h3><h4 id="1-题目要求：-7"><a href="#1-题目要求：-7" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-7"><a href="#2-问题分析：-7" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-7"><a href="#3-问题解决：-7" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-7"><a href="#1-闭区间-7" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-7"><a href="#2-半开半闭区间-7" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-5"><a href="#1-左开右闭区间-5" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-5"><a href="#2-左闭右开区间-5" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-7"><a href="#3-开区间-7" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：1898-可移除字符的最大数目-leetcode-cn"><a href="#题目：1898-可移除字符的最大数目-leetcode-cn" class="headerlink" title="题目：1898. 可移除字符的最大数目 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/maximum-number-of-removable-characters/">1898. 可移除字符的最大数目 (leetcode.cn)</a></h3><h4 id="1-题目要求：-8"><a href="#1-题目要求：-8" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-8"><a href="#2-问题分析：-8" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-8"><a href="#3-问题解决：-8" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-8"><a href="#1-闭区间-8" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-8"><a href="#2-半开半闭区间-8" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-6"><a href="#1-左开右闭区间-6" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-6"><a href="#2-左闭右开区间-6" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-8"><a href="#3-开区间-8" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：1482-制作-m-束花所需的最少天数-leetcode-cn"><a href="#题目：1482-制作-m-束花所需的最少天数-leetcode-cn" class="headerlink" title="题目：1482. 制作 m 束花所需的最少天数 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/">1482. 制作 m 束花所需的最少天数 (leetcode.cn)</a></h3><h4 id="1-题目要求：-9"><a href="#1-题目要求：-9" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-9"><a href="#2-问题分析：-9" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-9"><a href="#3-问题解决：-9" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-9"><a href="#1-闭区间-9" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-9"><a href="#2-半开半闭区间-9" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-7"><a href="#1-左开右闭区间-7" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-7"><a href="#2-左闭右开区间-7" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-9"><a href="#3-开区间-9" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：1642-可以到达的最远建筑-leetcode-cn"><a href="#题目：1642-可以到达的最远建筑-leetcode-cn" class="headerlink" title="题目：1642. 可以到达的最远建筑 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/furthest-building-you-can-reach/">1642. 可以到达的最远建筑 (leetcode.cn)</a></h3><h4 id="1-题目要求：-10"><a href="#1-题目要求：-10" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-10"><a href="#2-问题分析：-10" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-10"><a href="#3-问题解决：-10" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-10"><a href="#1-闭区间-10" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-10"><a href="#2-半开半闭区间-10" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-8"><a href="#1-左开右闭区间-8" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-8"><a href="#2-左闭右开区间-8" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-10"><a href="#3-开区间-10" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：2258-逃离火灾-leetcode-cn"><a href="#题目：2258-逃离火灾-leetcode-cn" class="headerlink" title="题目：2258. 逃离火灾 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/escape-the-spreading-fire/">2258. 逃离火灾 (leetcode.cn)</a></h3><h4 id="1-题目要求：-11"><a href="#1-题目要求：-11" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-11"><a href="#2-问题分析：-11" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-11"><a href="#3-问题解决：-11" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-11"><a href="#1-闭区间-11" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-11"><a href="#2-半开半闭区间-11" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-9"><a href="#1-左开右闭区间-9" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-9"><a href="#2-左闭右开区间-9" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-11"><a href="#3-开区间-11" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：2064-分配给商店的最多商品的最小值-leetcode-cn"><a href="#题目：2064-分配给商店的最多商品的最小值-leetcode-cn" class="headerlink" title="题目：2064. 分配给商店的最多商品的最小值 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/minimized-maximum-of-products-distributed-to-any-store/">2064. 分配给商店的最多商品的最小值 (leetcode.cn)</a></h3><h4 id="1-题目要求：-12"><a href="#1-题目要求：-12" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-12"><a href="#2-问题分析：-12" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-12"><a href="#3-问题解决：-12" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-12"><a href="#1-闭区间-12" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-12"><a href="#2-半开半闭区间-12" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-10"><a href="#1-左开右闭区间-10" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-10"><a href="#2-左闭右开区间-10" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-12"><a href="#3-开区间-12" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：1760-袋子里最少数目的球-leetcode-cn"><a href="#题目：1760-袋子里最少数目的球-leetcode-cn" class="headerlink" title="题目：1760. 袋子里最少数目的球 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/">1760. 袋子里最少数目的球 (leetcode.cn)</a></h3><h4 id="1-题目要求：-13"><a href="#1-题目要求：-13" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-13"><a href="#2-问题分析：-13" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-13"><a href="#3-问题解决：-13" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-13"><a href="#1-闭区间-13" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-13"><a href="#2-半开半闭区间-13" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-11"><a href="#1-左开右闭区间-11" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-11"><a href="#2-左闭右开区间-11" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-13"><a href="#3-开区间-13" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：2439-最小化数组中的最大值-leetcode-cn"><a href="#题目：2439-最小化数组中的最大值-leetcode-cn" class="headerlink" title="题目：2439. 最小化数组中的最大值 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/minimize-maximum-of-array/">2439. 最小化数组中的最大值 (leetcode.cn)</a></h3><h4 id="1-题目要求：-14"><a href="#1-题目要求：-14" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-14"><a href="#2-问题分析：-14" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-14"><a href="#3-问题解决：-14" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-14"><a href="#1-闭区间-14" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-14"><a href="#2-半开半闭区间-14" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-12"><a href="#1-左开右闭区间-12" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-12"><a href="#2-左闭右开区间-12" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-14"><a href="#3-开区间-14" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：2560-打家劫舍-IV-leetcode-cn"><a href="#题目：2560-打家劫舍-IV-leetcode-cn" class="headerlink" title="题目：2560. 打家劫舍 IV (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/house-robber-iv/">2560. 打家劫舍 IV (leetcode.cn)</a></h3><h4 id="1-题目要求：-15"><a href="#1-题目要求：-15" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-15"><a href="#2-问题分析：-15" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-15"><a href="#3-问题解决：-15" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-15"><a href="#1-闭区间-15" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-15"><a href="#2-半开半闭区间-15" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-13"><a href="#1-左开右闭区间-13" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-13"><a href="#2-左闭右开区间-13" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-15"><a href="#3-开区间-15" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：778-水位上升的泳池中游泳-leetcode-cn"><a href="#题目：778-水位上升的泳池中游泳-leetcode-cn" class="headerlink" title="题目：778. 水位上升的泳池中游泳 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/swim-in-rising-water/">778. 水位上升的泳池中游泳 (leetcode.cn)</a></h3><h4 id="1-题目要求：-16"><a href="#1-题目要求：-16" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-16"><a href="#2-问题分析：-16" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-16"><a href="#3-问题解决：-16" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-16"><a href="#1-闭区间-16" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-16"><a href="#2-半开半闭区间-16" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-14"><a href="#1-左开右闭区间-14" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-14"><a href="#2-左闭右开区间-14" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-16"><a href="#3-开区间-16" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：2616-最小化数对的最大差值-leetcode-cn"><a href="#题目：2616-最小化数对的最大差值-leetcode-cn" class="headerlink" title="题目：2616. 最小化数对的最大差值 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/">2616. 最小化数对的最大差值 (leetcode.cn)</a></h3><h4 id="1-题目要求：-17"><a href="#1-题目要求：-17" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-17"><a href="#2-问题分析：-17" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-17"><a href="#3-问题解决：-17" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-17"><a href="#1-闭区间-17" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-17"><a href="#2-半开半闭区间-17" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-15"><a href="#1-左开右闭区间-15" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-15"><a href="#2-左闭右开区间-15" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-17"><a href="#3-开区间-17" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：2513-最小化两个数组中的最大值-leetcode-cn"><a href="#题目：2513-最小化两个数组中的最大值-leetcode-cn" class="headerlink" title="题目：2513. 最小化两个数组中的最大值 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/minimize-the-maximum-of-two-arrays/">2513. 最小化两个数组中的最大值 (leetcode.cn)</a></h3><h4 id="1-题目要求：-18"><a href="#1-题目要求：-18" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-18"><a href="#2-问题分析：-18" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-18"><a href="#3-问题解决：-18" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-18"><a href="#1-闭区间-18" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-18"><a href="#2-半开半闭区间-18" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-16"><a href="#1-左开右闭区间-16" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-16"><a href="#2-左闭右开区间-16" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-18"><a href="#3-开区间-18" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：1552-两球之间的磁力-leetcode-cn"><a href="#题目：1552-两球之间的磁力-leetcode-cn" class="headerlink" title="题目：1552. 两球之间的磁力 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/magnetic-force-between-two-balls/">1552. 两球之间的磁力 (leetcode.cn)</a></h3><h4 id="1-题目要求：-19"><a href="#1-题目要求：-19" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-19"><a href="#2-问题分析：-19" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-19"><a href="#3-问题解决：-19" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-19"><a href="#1-闭区间-19" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-19"><a href="#2-半开半闭区间-19" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-17"><a href="#1-左开右闭区间-17" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-17"><a href="#2-左闭右开区间-17" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-19"><a href="#3-开区间-19" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：2861-最大合金数-leetcode-cn"><a href="#题目：2861-最大合金数-leetcode-cn" class="headerlink" title="题目：2861. 最大合金数 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/maximum-number-of-alloys/">2861. 最大合金数 (leetcode.cn)</a></h3><h4 id="1-题目要求：-20"><a href="#1-题目要求：-20" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-20"><a href="#2-问题分析：-20" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-20"><a href="#3-问题解决：-20" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-20"><a href="#1-闭区间-20" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-20"><a href="#2-半开半闭区间-20" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-18"><a href="#1-左开右闭区间-18" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-18"><a href="#2-左闭右开区间-18" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-20"><a href="#3-开区间-20" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：2517-礼盒的最大甜蜜度-leetcode-cn"><a href="#题目：2517-礼盒的最大甜蜜度-leetcode-cn" class="headerlink" title="题目：2517. 礼盒的最大甜蜜度 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/">2517. 礼盒的最大甜蜜度 (leetcode.cn)</a></h3><h4 id="1-题目要求：-21"><a href="#1-题目要求：-21" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-21"><a href="#2-问题分析：-21" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-21"><a href="#3-问题解决：-21" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-21"><a href="#1-闭区间-21" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-21"><a href="#2-半开半闭区间-21" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-19"><a href="#1-左开右闭区间-19" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-19"><a href="#2-左闭右开区间-19" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-21"><a href="#3-开区间-21" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：2812-找出最安全路径-leetcode-cn"><a href="#题目：2812-找出最安全路径-leetcode-cn" class="headerlink" title="题目：2812. 找出最安全路径 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/find-the-safest-path-in-a-grid/">2812. 找出最安全路径 (leetcode.cn)</a></h3><h4 id="1-题目要求：-22"><a href="#1-题目要求：-22" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-22"><a href="#2-问题分析：-22" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-22"><a href="#3-问题解决：-22" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-22"><a href="#1-闭区间-22" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-22"><a href="#2-半开半闭区间-22" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-20"><a href="#1-左开右闭区间-20" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-20"><a href="#2-左闭右开区间-20" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-22"><a href="#3-开区间-22" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：2528-最大化城市的最小供电站数目-leetcode-cn"><a href="#题目：2528-最大化城市的最小供电站数目-leetcode-cn" class="headerlink" title="题目：2528. 最大化城市的最小供电站数目 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/maximize-the-minimum-powered-city/">2528. 最大化城市的最小供电站数目 (leetcode.cn)</a></h3><h4 id="1-题目要求：-23"><a href="#1-题目要求：-23" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-23"><a href="#2-问题分析：-23" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-23"><a href="#3-问题解决：-23" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-23"><a href="#1-闭区间-23" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-23"><a href="#2-半开半闭区间-23" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-21"><a href="#1-左开右闭区间-21" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-21"><a href="#2-左闭右开区间-21" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-23"><a href="#3-开区间-23" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：378-有序矩阵中第-K-小的元素-leetcode-cn"><a href="#题目：378-有序矩阵中第-K-小的元素-leetcode-cn" class="headerlink" title="题目：378. 有序矩阵中第 K 小的元素 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第 K 小的元素 (leetcode.cn)</a></h3><h4 id="1-题目要求：-24"><a href="#1-题目要求：-24" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-24"><a href="#2-问题分析：-24" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-24"><a href="#3-问题解决：-24" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-24"><a href="#1-闭区间-24" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-24"><a href="#2-半开半闭区间-24" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-22"><a href="#1-左开右闭区间-22" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-22"><a href="#2-左闭右开区间-22" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-24"><a href="#3-开区间-24" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：373-查找和最小的-K-对数字-leetcode-cn"><a href="#题目：373-查找和最小的-K-对数字-leetcode-cn" class="headerlink" title="题目：373. 查找和最小的 K 对数字 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/">373. 查找和最小的 K 对数字 (leetcode.cn)</a></h3><h4 id="1-题目要求：-25"><a href="#1-题目要求：-25" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-25"><a href="#2-问题分析：-25" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-25"><a href="#3-问题解决：-25" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-25"><a href="#1-闭区间-25" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-25"><a href="#2-半开半闭区间-25" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-23"><a href="#1-左开右闭区间-23" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-23"><a href="#2-左闭右开区间-23" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-25"><a href="#3-开区间-25" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：719-找出第-K-小的数对距离-leetcode-cn"><a href="#题目：719-找出第-K-小的数对距离-leetcode-cn" class="headerlink" title="题目：719. 找出第 K 小的数对距离 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/find-k-th-smallest-pair-distance/">719. 找出第 K 小的数对距离 (leetcode.cn)</a></h3><h4 id="1-题目要求：-26"><a href="#1-题目要求：-26" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-26"><a href="#2-问题分析：-26" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-26"><a href="#3-问题解决：-26" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-26"><a href="#1-闭区间-26" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-26"><a href="#2-半开半闭区间-26" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-24"><a href="#1-左开右闭区间-24" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-24"><a href="#2-左闭右开区间-24" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-26"><a href="#3-开区间-26" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：1439-有序矩阵中的第-k-个最小数组和-leetcode-cn"><a href="#题目：1439-有序矩阵中的第-k-个最小数组和-leetcode-cn" class="headerlink" title="题目：1439. 有序矩阵中的第 k 个最小数组和 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/">1439. 有序矩阵中的第 k 个最小数组和 (leetcode.cn)</a></h3><h4 id="1-题目要求：-27"><a href="#1-题目要求：-27" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-27"><a href="#2-问题分析：-27" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-27"><a href="#3-问题解决：-27" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-27"><a href="#1-闭区间-27" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-27"><a href="#2-半开半闭区间-27" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-25"><a href="#1-左开右闭区间-25" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-25"><a href="#2-左闭右开区间-25" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-27"><a href="#3-开区间-27" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：786-第-K-个最小的素数分数-leetcode-cn"><a href="#题目：786-第-K-个最小的素数分数-leetcode-cn" class="headerlink" title="题目：786. 第 K 个最小的素数分数 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/k-th-smallest-prime-fraction/">786. 第 K 个最小的素数分数 (leetcode.cn)</a></h3><h4 id="1-题目要求：-28"><a href="#1-题目要求：-28" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-28"><a href="#2-问题分析：-28" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-28"><a href="#3-问题解决：-28" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-28"><a href="#1-闭区间-28" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-28"><a href="#2-半开半闭区间-28" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-26"><a href="#1-左开右闭区间-26" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-26"><a href="#2-左闭右开区间-26" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-28"><a href="#3-开区间-28" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：2040-两个有序数组的第-K-小乘积-leetcode-cn"><a href="#题目：2040-两个有序数组的第-K-小乘积-leetcode-cn" class="headerlink" title="题目：2040. 两个有序数组的第 K 小乘积 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/kth-smallest-product-of-two-sorted-arrays/">2040. 两个有序数组的第 K 小乘积 (leetcode.cn)</a></h3><h4 id="1-题目要求：-29"><a href="#1-题目要求：-29" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-29"><a href="#2-问题分析：-29" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-29"><a href="#3-问题解决：-29" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-29"><a href="#1-闭区间-29" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-29"><a href="#2-半开半闭区间-29" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-27"><a href="#1-左开右闭区间-27" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-27"><a href="#2-左闭右开区间-27" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-29"><a href="#3-开区间-29" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="题目：2386-找出数组的第-K-大和-leetcode-cn"><a href="#题目：2386-找出数组的第-K-大和-leetcode-cn" class="headerlink" title="题目：2386. 找出数组的第 K 大和 (leetcode.cn)"></a>题目：<a href="https://leetcode.cn/problems/find-the-k-sum-of-an-array/">2386. 找出数组的第 K 大和 (leetcode.cn)</a></h3><h4 id="1-题目要求：-30"><a href="#1-题目要求：-30" class="headerlink" title="1. 题目要求："></a>1. 题目要求：</h4><h4 id="2-问题分析：-30"><a href="#2-问题分析：-30" class="headerlink" title="2. 问题分析："></a>2. 问题分析：</h4><h4 id="3-问题解决：-30"><a href="#3-问题解决：-30" class="headerlink" title="3. 问题解决："></a>3. 问题解决：</h4><h5 id="1-闭区间-30"><a href="#1-闭区间-30" class="headerlink" title="1. 闭区间"></a>1. 闭区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-半开半闭区间-30"><a href="#2-半开半闭区间-30" class="headerlink" title="2. 半开半闭区间"></a>2. 半开半闭区间</h5><h6 id="1-左开右闭区间-28"><a href="#1-左开右闭区间-28" class="headerlink" title="1. 左开右闭区间"></a>1. 左开右闭区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-左闭右开区间-28"><a href="#2-左闭右开区间-28" class="headerlink" title="2. 左闭右开区间"></a>2. 左闭右开区间</h6><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-开区间-30"><a href="#3-开区间-30" class="headerlink" title="3. 开区间"></a>3. 开区间</h5><p><code>Python </code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="参考资料-amp-链接："><a href="#参考资料-amp-链接：" class="headerlink" title="参考资料&amp;链接："></a>参考资料&amp;链接：</h2><ol>
<li><a href="https://space.bilibili.com/206214">灵茶山艾府的个人空间-灵茶山艾府个人主页-哔哩哔哩视频 (bilibili.com)</a></li>
<li><a href="https://github.com/EndlessCheng/codeforces-go/tree/master">EndlessCheng/codeforces-go: 算法竞赛模板库 by 灵茶山艾府 💭💡🎈 (github.com)</a></li>
<li><a href="https://blog.csdn.net/groovy2007/article/details/78309120">二分查找中的循环不变式_二分搜索的循环不变式-CSDN博客</a></li>
<li><a href="https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找_百度百科 (baidu.com)</a></li>
<li><a href="https://www.runoob.com/python3/python-binary-search.html">Python 二分查找 | 菜鸟教程 (runoob.com)</a></li>
<li><a href="https://zh.wikipedia.org/zh-hans/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95">二分搜寻演算法 - 维基百科，自由的百科全书 (wikipedia.org)</a></li>
<li><a href="https://www.bilibili.com/video/BV1AP41137w7/">二分查找 红蓝染色法 - 哔哩哔哩 (bilibili.com)</a></li>
<li><a href="https://leetcode.cn/problems/h-index-ii/solutions/2504326/tu-jie-yi-tu-zhang-wo-er-fen-da-an-si-ch-d15k/">275. H 指数 II - 力扣（LeetCode）</a></li>
</ol>
<hr>
<p>我的<code>LeetCode</code>主页：<a href="https://leetcode.cn/u/david-deng-01/">熬夜冠军🏆 - 力扣（LeetCode）</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>宝塔面板失效</title>
    <url>//2023/11/24/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%A4%B1%E6%95%88/</url>
    <content><![CDATA[<h1 id="宝塔面板失效"><a href="#宝塔面板失效" class="headerlink" title="宝塔面板失效"></a>宝塔面板失效</h1><h2 id="1-问题起因："><a href="#1-问题起因：" class="headerlink" title="1. 问题起因："></a>1. 问题起因：</h2><p>由于服务器的硬盘容量不足，所以新增了两块硬盘。看着新增硬盘里面空荡荡的，就想着把之前硬盘里面的东西移一些到新硬盘里面，减轻之前硬盘的压力。所以想当然的把<code>/www</code>移动到了新硬盘上面，然后通过<code>ln</code>命令创建一个硬链接过去，完美解决之前硬盘容量不够和新硬盘空荡荡的问题。</p>
<p>这时就出现了一个问题: <code>/www</code> 目录下的一些文件没有访问的权限，并且在<code>root</code>用户权限下也没有访问的权限，导致移动失败，并且文件无法删除，显示没有权限删除。</p>
<h2 id="2-问题解决："><a href="#2-问题解决：" class="headerlink" title="2. 问题解决："></a>2. 问题解决：</h2><p>通过查看服务器上的文件发现，没有权限访问的文件是使用<code>宝塔面板</code>创建网站时自动创建的<code>.user.ini</code>文件。</p>
<p>知道文件怎么创建的以后，就凭直觉的想到使用<code>宝塔面板</code>肯定能删除，因为这个文件其实对于网站来说的作用并不大，并且可以后面再手动创建一个新的<code>.user.ini</code>文件。</p>
<p>然后，打开浏览器，访问<code>宝塔面板</code>管理界面，就尴尬了...</p>
<p>页面无法访问(404 not found)</p>
<p>突然，脑子都懵了...</p>
<p>然后手动把<code>/www</code> 文件夹移动回去，想着文件都没有修改，应该问题不大</p>
<p>然后，再次打开浏览器，访问<code>宝塔面板</code>管理界面，又尴住了...</p>
<p>页面显示<code>宝塔面板</code>被损坏了，可以点击右上角的修复按钮进行修复或者去官方论坛发帖求助，但是右上角并没有修复按钮...(因为当时忘记截图了，所以没有把报错的界面放在这)</p>
<p>最后，通过命令行输入<code>bt</code> 然后修复并升级<code>宝塔面板</code>，显示修复成功</p>
<p>怀着忐忑的心情，打开浏览器，访问<code>宝塔面板</code>管理界面，奇迹出现了，显示了登录界面并且数据啥的全部没有丢失</p>
<p>至此，这个问题算是完美解决了</p>
<h2 id="3-问题总结"><a href="#3-问题总结" class="headerlink" title="3. 问题总结"></a>3. 问题总结</h2><p>首先，出现这个问题纯属自己手贱，想着移动<code>/www</code>文件夹之后创建一个硬链接就行了，但是并没有成功。这件事情告诉我们能够运行的代码，千万不要动它！不然就会出现意想不到的问题。</p>
<p>其次，如果遇到了<code>宝塔面板</code>界面无法访问的情况，及时使用<code>ssh工具</code>进入服务器的后台，将<code>宝塔面板</code>进行修复，有较大概率是可以自动修复好的，如果没有修复成功那就只能备份数据，重新安装<code>宝塔面板</code>了。</p>
<p>最后，千万不要手贱！千万不要手贱！千万不要手贱！能运行的代码千万不要手贱去动它，不然分分钟崩溃给你看。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>宝塔面板</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>多模态讽刺识别基线模型复现</title>
    <url>//2023/11/24/%E5%A4%9A%E6%A8%A1%E6%80%81%E8%AE%BD%E5%88%BA%E8%AF%86%E5%88%AB%E5%9F%BA%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="多模态讽刺识别基线模型复现"><a href="#多模态讽刺识别基线模型复现" class="headerlink" title="多模态讽刺识别基线模型复现"></a>多模态讽刺识别基线模型复现</h1><h2 id="0-文章简介"><a href="#0-文章简介" class="headerlink" title="0. 文章简介"></a>0. 文章简介</h2><p>文章名称：<a href="https://aclanthology.org/2023.findings-acl.689/">MMSD2.0: Towards a Reliable Multi-modal Sarcasm Detection System</a></p>
<p>原文发表在2023年的 <a href="https://aclanthology.org/events/acl-2023/">ACL</a> 上的 Findings 中。文章使用&quot;文本-图像对&quot;进行讽刺检测，使用<code>CLIP</code>编码器对文本和对象进行特征抽取。使用文本，图像和文本图像融合三种模态进行讽刺检测。</p>
<p>如果觉得文章对您有帮助的话，欢迎引用原文:</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">@inproceedings&#123;qin-etal-2023-mmsd2,</span><br><span class="line">    title = &quot;&#123;MMSD&#125;2.0: Towards a Reliable Multi-modal Sarcasm Detection System&quot;,</span><br><span class="line">    author = &quot;Qin, Libo  and</span><br><span class="line">      Huang, Shijue  and</span><br><span class="line">      Chen, Qiguang  and</span><br><span class="line">      Cai, Chenran  and</span><br><span class="line">      Zhang, Yudi  and</span><br><span class="line">      Liang, Bin  and</span><br><span class="line">      Che, Wanxiang  and</span><br><span class="line">      Xu, Ruifeng&quot;,</span><br><span class="line">    booktitle = &quot;Findings of the Association for Computational Linguistics: ACL 2023&quot;,</span><br><span class="line">    month = jul,</span><br><span class="line">    year = &quot;2023&quot;,</span><br><span class="line">    address = &quot;Toronto, Canada&quot;,</span><br><span class="line">    publisher = &quot;Association for Computational Linguistics&quot;,</span><br><span class="line">    url = &quot;https://aclanthology.org/2023.findings-acl.689&quot;,</span><br><span class="line">    pages = &quot;10834--10845&quot;,</span><br><span class="line">    abstract = &quot;Multi-modal sarcasm detection has attracted much recent attention. Nevertheless, the existing benchmark (MMSD) has some shortcomings that hinder the development of reliable multi-modal sarcasm detection system: (1) There are some spurious cues in MMSD, leading to the model bias learning; (2) The negative samples in MMSD are not always reasonable. To solve the aforementioned issues, we introduce MMSD2.0, a correction dataset that fixes the shortcomings of MMSD, by removing the spurious cues and re-annotating the unreasonable samples. Meanwhile, we present a novel framework called multi-view CLIP that is capable of leveraging multi-grained cues from multiple perspectives (i.e., text, image, and text-image interaction view) for multi-modal sarcasm detection. Extensive experiments show that MMSD2.0 is a valuable benchmark for building reliable multi-modal sarcasm detection systems and multi-view CLIP can significantly outperform the previous best baselines.&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><h3 id="1-1-环境配置"><a href="#1-1-环境配置" class="headerlink" title="1.1 环境配置"></a>1.1 环境配置</h3><p>原文的代码链接：<a href="https://github.com/JoeYing1019/MMSD2.0">JoeYing1019/MMSD2.0: Code and dataset for ACL23 Findings paper &quot;MMSD2.0: Towards a Reliable Multi-modal Sarcasm Detection System&quot; (github.com)</a></p>
<p>根据原文代码仓库中的<code>README.md</code>和<code>requirement.txt</code>，创建代码运行的环境。</p>
<p>作者的代码基于 <code>PyTorch 1.12 </code> 实现，需要依赖的软件包如下:</p>
<ul>
<li>numpy==1.21.6</li>
<li>tqdm==4.64.0</li>
<li>pytorch==1.12.0</li>
<li>python==3.7.4</li>
<li>pillow==9.2.0</li>
<li>transformers==4.23.1</li>
<li>wandb==0.13.3</li>
<li>scikit-learn==1.0.2</li>
</ul>
<p>作者强烈推荐使用 <a href="https://www.anaconda.com/">Anaconda</a> 管理和创建 <code>Python</code> 环境，可以直接使用下面的命令在终端中直接创建代码运行的环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n env_name python=3.7.4   </span><br><span class="line"><span class="built_in">source</span> activate env_name     </span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>



<h3 id="1-2-数据集准备"><a href="#1-2-数据集准备" class="headerlink" title="1.2 数据集准备"></a>1.2 数据集准备</h3><p>作者使用的数据集链接： <a href="https://drive.google.com/file/d/1mK0Nf-jv_h2bgHUCRM4_EsdTiiitZ_Uj/view?usp=sharing_eil&ts=5d480e04">1</a> <a href="https://drive.google.com/file/d/1AOWzlOz5hmdO39dEmzhQ4z_nabgzi7Tu/view?usp=sharing_eil&ts=5d480e04">2</a> <a href="https://drive.google.com/file/d/1dJERrVlp7DlNSXk-uvbbG6Rv7uvqTOKd/view?usp=sharing_eil&ts=5d480e04">3</a> <a href="https://drive.google.com/file/d/1pODuKC4gP6-QDQonG8XTqI8w8ds68mE3/view?usp=sharing_eil&ts=5d480e04">4</a> ,下载完成后将数据解压到<code>data/dataset_image</code>目录下。</p>
<p>因为是复现基线模型，并且我们的目标是构建数据集，所以直接使用自己构建好的数据集即可，不需要下载作者提供的数据集。</p>
<p>但是使用自己的数据集也存在一些问题，我们需要修改一些原文的代码，才能使得基线模型能够运行在我们自己构建的数据集上。</p>
<h2 id="2-代码复现"><a href="#2-代码复现" class="headerlink" title="2. 代码复现"></a>2. 代码复现</h2><h2 id="x-遇到的问题以及解决的方案"><a href="#x-遇到的问题以及解决的方案" class="headerlink" title="x. 遇到的问题以及解决的方案"></a>x. 遇到的问题以及解决的方案</h2><h3 id="1-环境准备-1"><a href="#1-环境准备-1" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h4><p>一开始，我直接使用作者推荐的方式，用<code>Anaconda</code>构建和管理自己的<code>Python</code>环境，但是不出意外的是，出现了很多问题。</p>
<p>总结来说就是：</p>
<ol>
<li>很多第三方包存在冲突，安装不了</li>
<li><code>Python 3.7</code> 和 <code>Pytorch 1.12</code> 不兼容</li>
</ol>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>首先，我推荐使用Anaconda创建和管理虚拟环境，如果使用其他方式创建，请自行探索和解决第三方包冲突问题。使用下面的代码创建和激活你的虚拟环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n env_name python=3.8 </span><br><span class="line">conda  activate env_name     </span><br></pre></td></tr></table></figure>

<p>其次，安装依赖，只安装一些必要的依赖，作者提供的<code>requirement.txt</code>存在很多不必要的包，所以不需要全部都安装，我只安装了下面这几种包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install numpy tqdm torch torchvision pillow transformers wandb scikit-learn</span><br></pre></td></tr></table></figure>



<h2 id="参考文献和链接"><a href="#参考文献和链接" class="headerlink" title="参考文献和链接"></a>参考文献和链接</h2><ol>
<li><a href="https://aclanthology.org/2023.findings-acl.689/">MMSD2.0: Towards a Reliable Multi-modal Sarcasm Detection System</a></li>
<li><a href="https://github.com/JoeYing1019/MMSD2.0">JoeYing1019/MMSD2.0: Code and dataset for ACL23 Findings paper &quot;MMSD2.0: Towards a Reliable Multi-modal Sarcasm Detection System&quot; (github.com)</a></li>
<li><a href="https://avmedia.0voice.com/?id=42710">使用python如何截断想要时段的语音并且生成对应的梅尔谱图-音视频开发中文网 (0voice.com)</a></li>
<li><a href="https://librosa.org/doc/latest/index.html">librosa — librosa 0.10.1 documentation</a></li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
        <category>讽刺识别</category>
        <category>基线模型</category>
      </categories>
      <tags>
        <tag>基线模型</tag>
        <tag>讽刺识别</tag>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>heapq 堆队列算法</title>
    <url>//2023/10/28/heapq-%E5%A0%86%E9%98%9F%E5%88%97%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Python-heapq-堆队列算法"><a href="#Python-heapq-堆队列算法" class="headerlink" title="Python heapq 堆队列算法"></a>Python <code>heapq </code>堆队列算法</h1><h2 id="模块解释说明"><a href="#模块解释说明" class="headerlink" title="模块解释说明"></a>模块解释说明</h2><p>源码：<a href="https://github.com/python/cpython/tree/3.12/Lib/heapq.py">Lib/heapq.py</a></p>
<blockquote>
<p>这个模块实现了堆队列算法，即优先队列算法。</p>
<p>堆是一棵完全二叉树，其中每个节点的值都小于等于其各个子节点的值。这个使用数组的实现，索引从 0 开始，且对所有的 <em>k</em> 都有 <code>heap[k] &lt;= heap[2*k+1]</code> 和 <code>heap[k] &lt;= heap[2*k+2]</code>。比较时不存在的元素被认为是无限大。堆最有趣的特性在于最小的元素总是在根结点：<code>heap[0]</code>。</p>
<p>这个API与教材的堆算法实现有所不同，具体区别有两方面：（a）我们使用了从零开始的索引。这使得节点和其孩子节点索引之间的关系不太直观但更加适合，因为 Python 使用从零开始的索引。 （b）我们的 pop 方法返回最小的项而不是最大的项（这在教材中称为“最小堆”；而“最大堆”在教材中更为常见，因为它更适用于原地排序）。</p>
<p>基于这两方面，把堆看作原生的Python list也没什么奇怪的： <code>heap[0]</code> 表示最小的元素，同时 <code>heap.sort()</code> 维护了堆的不变性！</p>
<p>要创建一个堆，可以新建一个空列表 <code>[]</code>，或者用函数 <a href="https://docs.python.org/zh-cn/3/library/heapq.html#heapq.heapify"><code>heapify()</code></a> 把一个非空列表变为堆。</p>
</blockquote>
<p>总结如下：</p>
<ol>
<li><code>heapq</code> 模块实现了堆队列算法(优先队列算法)，进一步说，<code>heapq</code> 模块实现了小顶堆(小根堆)</li>
<li>介绍了堆的基本概念，堆是一个完全二叉树，满足对于所有的 <em>k</em> 都有 <code>heap[k] &lt;= heap[2*k+1]</code> 和 <code>heap[k] &lt;= heap[2*k+2]</code>。</li>
<li>由于<code>heapq</code> 模块实现的是小根堆，并且<code>heap[0]</code>表示根节点，所以可以得出结论: <code>heap[0]</code> 是最小的元素。</li>
<li>堆可以看作原生的Python list：<code>heap[0]</code> 表示最小的元素，同时 <code>heap.sort()</code> 维护了堆的不变性！要创建一个堆，可以新建一个空列表 <code>[]</code>，或者用函数 <a href="https://docs.python.org/zh-cn/3/library/heapq.html#heapq.heapify"><code>heapify()</code></a> 把一个非空列表变为堆。</li>
</ol>
<h2 id="heapq-模块中的函数"><a href="#heapq-模块中的函数" class="headerlink" title="heapq 模块中的函数"></a><code>heapq</code> 模块中的函数</h2><h3 id="heapq-heapify-x"><a href="#heapq-heapify-x" class="headerlink" title="heapq.heapify(x)"></a><code>heapq.heapify(x)</code></h3><blockquote>
<p>将list <em>x</em> 转换成堆，原地，线性时间内。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heapify</span><br><span class="line">hq = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">56</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">66</span>, <span class="number">12</span>, <span class="number">98</span>, <span class="number">34</span>, <span class="number">6</span>, <span class="number">35</span>]  <span class="comment"># 创建一个 Python list</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;转换前, list hq 为 &gt;&gt; <span class="subst">&#123;hq&#125;</span>&quot;</span>)</span><br><span class="line">heapify(hq)  <span class="comment"># 将 hq 转换成堆队列(构建小顶堆)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;转换后, 堆队列为 &gt;&gt; <span class="subst">&#123;hq&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">运行结果:</span></span><br><span class="line"><span class="string">转换前, list hq 为 &gt;&gt; [1, 4, 56, 2, 3, 66, 12, 98, 34, 6, 35]</span></span><br><span class="line"><span class="string">转换后, 堆队列为 &gt;&gt; [1, 2, 12, 4, 3, 66, 56, 98, 34, 6, 35]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="heapq-heappush-heap-item"><a href="#heapq-heappush-heap-item" class="headerlink" title="heapq.heappush(heap, item)"></a><code>heapq.heappush(heap, item)</code></h3><blockquote>
<p> 将 <em>item</em> 的值加入 <em>heap</em> 中，保持堆的不变性。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappush, heapify</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hq = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">56</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">66</span>, <span class="number">12</span>, <span class="number">98</span>, <span class="number">34</span>, <span class="number">6</span>, <span class="number">35</span>]  <span class="comment"># 创建一个 Python list</span></span><br><span class="line"></span><br><span class="line">heapify(hq)  <span class="comment"># 将 hq 转换成堆队列(构建小顶堆)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;添加元素前, 堆队列为 &gt;&gt; <span class="subst">&#123;hq&#125;</span>&quot;</span>)</span><br><span class="line">heappush(hq, <span class="number">88</span>)  <span class="comment"># 将 item 的值加入 hq 中，保持堆的不变性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;添加元素后, 堆队列为 &gt;&gt; <span class="subst">&#123;hq&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">运行结果:</span></span><br><span class="line"><span class="string">添加元素前, 堆队列为 &gt;&gt; [1, 2, 12, 4, 3, 66, 56, 98, 34, 6, 35]</span></span><br><span class="line"><span class="string">添加元素后, 堆队列为 &gt;&gt; [1, 2, 12, 4, 3, 66, 56, 98, 34, 6, 35, 88]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="heapq-heappop-heap"><a href="#heapq-heappop-heap" class="headerlink" title="heapq.heappop(heap)"></a><code>heapq.heappop(heap)</code></h3><blockquote>
<p>弹出并返回 <em>heap</em> 的最小的元素，保持堆的不变性。如果堆为空，抛出 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#IndexError"><code>IndexError</code></a> 。使用 <code>heap[0]</code> ，可以只访问最小的元素而不弹出它。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappop, heapify</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hq = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">56</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">66</span>, <span class="number">12</span>, <span class="number">98</span>, <span class="number">34</span>, <span class="number">6</span>, <span class="number">35</span>]  <span class="comment"># 创建一个 Python list</span></span><br><span class="line"></span><br><span class="line">heapify(hq)  <span class="comment"># 将 hq 转换成堆队列(构建小顶堆)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;堆队列为 &gt;&gt; <span class="subst">&#123;hq&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;弹出前, 根节点元素为 &gt;&gt; <span class="subst">&#123;hq[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">res = heappop(hq) <span class="comment"># 弹出并返回 hq 的最小的元素，保持堆的不变性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;弹出元素为 &gt;&gt; <span class="subst">&#123;hq[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;弹出后, 根节点元素为 &gt;&gt; <span class="subst">&#123;hq[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">运行结果:</span></span><br><span class="line"><span class="string">堆队列为 &gt;&gt; [1, 2, 12, 4, 3, 66, 56, 98, 34, 6, 35]</span></span><br><span class="line"><span class="string">弹出前, 根节点元素为 &gt;&gt; 1</span></span><br><span class="line"><span class="string">弹出元素为 &gt;&gt; 2</span></span><br><span class="line"><span class="string">弹出后, 根节点元素为 &gt;&gt; 2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="heapq-heappushpop-heap-item"><a href="#heapq-heappushpop-heap-item" class="headerlink" title="heapq.heappushpop(heap, item)"></a><code>heapq.heappushpop(heap, item)</code></h3><blockquote>
<p>将 <em>item</em> 放入堆中，然后弹出并返回 <em>heap</em> 的最小元素。该组合操作比先调用 <a href="https://docs.python.org/zh-cn/3/library/heapq.html#heapq.heappush"><code>heappush()</code></a> 再调用 <a href="https://docs.python.org/zh-cn/3/library/heapq.html#heapq.heappop"><code>heappop()</code></a> 运行起来更有效率。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappushpop, heapify</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hq = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">56</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">66</span>, <span class="number">12</span>, <span class="number">98</span>, <span class="number">34</span>, <span class="number">6</span>, <span class="number">35</span>]  <span class="comment"># 创建一个 Python list</span></span><br><span class="line"></span><br><span class="line">heapify(hq)  <span class="comment"># 将 hq 转换成堆队列(构建小顶堆)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;插入前, 堆队列为 &gt;&gt; <span class="subst">&#123;hq&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;弹出前, 根节点元素为 &gt;&gt; <span class="subst">&#123;hq[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">res = heappushpop(hq, <span class="number">88</span>) <span class="comment"># 将 item 放入堆中，然后弹出并返回 hq 的最小元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;弹出元素为 &gt;&gt; <span class="subst">&#123;res&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;插入并弹出根节点后, 堆队列为 &gt;&gt; <span class="subst">&#123;hq&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;弹出后, 根节点元素为 &gt;&gt; <span class="subst">&#123;hq[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">运行结果:</span></span><br><span class="line"><span class="string">插入前, 堆队列为 &gt;&gt; [1, 2, 12, 4, 3, 66, 56, 98, 34, 6, 35]</span></span><br><span class="line"><span class="string">弹出前, 根节点元素为 &gt;&gt; 1</span></span><br><span class="line"><span class="string">弹出元素为 &gt;&gt; 1</span></span><br><span class="line"><span class="string">插入并弹出根节点后, 堆队列为 &gt;&gt; [2, 3, 12, 4, 6, 66, 56, 98, 34, 88, 35]</span></span><br><span class="line"><span class="string">弹出后, 根节点元素为 &gt;&gt; 2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="heapq-heapreplace-heap-item"><a href="#heapq-heapreplace-heap-item" class="headerlink" title="heapq.heapreplace(heap, item)"></a><code>heapq.heapreplace(heap, item)</code></h3><blockquote>
<p>弹出并返回 <em>heap</em> 中最小的一项，同时推入新的 <em>item</em>。 堆的大小不变。 如果堆为空则引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#IndexError"><code>IndexError</code></a>。</p>
<p>这个单步骤操作比 <a href="https://docs.python.org/zh-cn/3/library/heapq.html#heapq.heappop"><code>heappop()</code></a> 加 <a href="https://docs.python.org/zh-cn/3/library/heapq.html#heapq.heappush"><code>heappush()</code></a> 更高效，并且在使用固定大小的堆时更为适宜。 pop/push 组合总是会从堆中返回一个元素并将其替换为 <em>item</em>。</p>
<p>返回的值可能会比新加入的值大。如果不希望如此，可改用 <a href="https://docs.python.org/zh-cn/3/library/heapq.html#heapq.heappushpop"><code>heappushpop()</code></a>。它的 push/pop 组合返回两个值中较小的一个，将较大的留在堆中。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heapreplace, heapify</span><br><span class="line"></span><br><span class="line">hq = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">56</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">66</span>, <span class="number">12</span>, <span class="number">98</span>, <span class="number">34</span>, <span class="number">6</span>, <span class="number">35</span>]  <span class="comment"># 创建一个 Python list</span></span><br><span class="line"></span><br><span class="line">heapify(hq)  <span class="comment"># 将 hq 转换成堆队列(构建小顶堆)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;插入前, 堆队列为 &gt;&gt; <span class="subst">&#123;hq&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;弹出前, 根节点元素为 &gt;&gt; <span class="subst">&#123;hq[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">res = heapreplace(hq, <span class="number">88</span>) <span class="comment"># 弹出并返回 hq 中最小的一项，同时推入新的 item</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;弹出元素为 &gt;&gt; <span class="subst">&#123;res&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;插入并弹出根节点后, 堆队列为 &gt;&gt; <span class="subst">&#123;hq&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;弹出后, 根节点元素为 &gt;&gt; <span class="subst">&#123;hq[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">运行结果:</span></span><br><span class="line"><span class="string">插入前, 堆队列为 &gt;&gt; [1, 2, 12, 4, 3, 66, 56, 98, 34, 6, 35]</span></span><br><span class="line"><span class="string">弹出前, 根节点元素为 &gt;&gt; 1</span></span><br><span class="line"><span class="string">弹出元素为 &gt;&gt; 1</span></span><br><span class="line"><span class="string">插入并弹出根节点后, 堆队列为 &gt;&gt; [2, 3, 12, 4, 6, 66, 56, 98, 34, 88, 35]</span></span><br><span class="line"><span class="string">弹出后, 根节点元素为 &gt;&gt; 2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="heapq-模块三个基于堆的通用目的函数"><a href="#heapq-模块三个基于堆的通用目的函数" class="headerlink" title="heapq 模块三个基于堆的通用目的函数"></a><code>heapq</code> 模块三个基于堆的通用目的函数</h2><h3 id="heapq-merge-iterables-key-None-reverse-False"><a href="#heapq-merge-iterables-key-None-reverse-False" class="headerlink" title="heapq.merge(iterables, key=None, reverse=False)"></a><code>heapq.merge(iterables, key=None, reverse=False)</code></h3><blockquote>
<p>将多个<code>已排序的输入</code>合并为一个<code>已排序的输出</code>（例如，合并来自多个日志文件的带时间戳的条目）。 返回已排序值的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-iterator">iterator</a>。</p>
<p>类似于 <code>sorted(itertools.chain(*iterables))</code> 但返回一个可迭代对象，不会一次性地将数据全部放入内存，并假定每个输入流都是已排序的（从小到大）。</p>
<p>具有两个可选参数，它们都必须指定为关键字参数。</p>
<p><em>key</em> 指定带有单个参数的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-key-function">key function</a>，用于从每个输入元素中提取比较键。 默认值为 <code>None</code> (直接比较元素)。</p>
<p><em>reverse</em> 为一个布尔值。 如果设为 <code>True</code>，则输入元素将按比较结果逆序进行合并。 要达成与 <code>sorted(itertools.chain(*iterables), reverse=True)</code> 类似的行为，所有可迭代对象必须是已从大到小排序的。</p>
<p><em>在 3.5 版更改:</em> 添加了可选的 <em>key</em> 和 <em>reverse</em> 形参。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span>  merge</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">代码功能描述：</span></span><br><span class="line"><span class="string">  1. 随机生成 4 个数组，每个数组包括 5 个数，数组中每个数的取值都在 [-100, 100] 之间</span></span><br><span class="line"><span class="string">  2. 将生成的数组按照绝对值从小到大进行排序</span></span><br><span class="line"><span class="string">  3. 使用 heapq.merge 函数合并 4 个有序的数组</span></span><br><span class="line"><span class="string">注意:</span></span><br><span class="line"><span class="string">  sorted 函数中的参数 key 和 reverse 必须和 heapq.merge 中的参数 key 和 reverse 相同</span></span><br><span class="line"><span class="string">  如果不同，则会导致排序失败，排序后的数组将是无序的数组。</span></span><br><span class="line"><span class="string">  从 heapq.merge 函数的描述中我们可以找到为啥 sorted 函数中的参数 key 和 reverse 必须和 heapq.merge 中的参数 key 和 reverse 相同</span></span><br><span class="line"><span class="string">  因为 heapq.merge 函数是将多个 **已排序的输入** 合并为一个 **已排序的输出** ，返回已排序值的 iterator。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">min_value, max_value, row, column = -<span class="number">100</span>, <span class="number">100</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">key, reverse = <span class="keyword">lambda</span> x: x <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> -x, <span class="literal">False</span></span><br><span class="line">data = [</span><br><span class="line">    <span class="built_in">sorted</span>(<span class="built_in">list</span>(random.sample(<span class="built_in">range</span>(min_value, max_value + <span class="number">1</span>), column)), key=key, reverse=reverse)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(row)</span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> i, d <span class="keyword">in</span> <span class="built_in">enumerate</span>(data):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>: <span class="subst">&#123;d&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Merged: &gt;&gt; <span class="subst">&#123;<span class="built_in">list</span>(merge(*data, key=key, reverse=reverse))&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;s</span></span><br><span class="line"><span class="string">运行结果:</span></span><br><span class="line"><span class="string">0: [8, -9, 37, 60, -76]</span></span><br><span class="line"><span class="string">1: [16, -18, -28, 43, 64]</span></span><br><span class="line"><span class="string">2: [-6, 19, -41, -52, 77]</span></span><br><span class="line"><span class="string">3: [32, -75, -85, -91, 91]</span></span><br><span class="line"><span class="string">Merged: &gt;&gt; [-6, 8, -9, 16, -18, 19, -28, 32, 37, -41, 43, -52, 60, 64, -75, -76, 77, -85, -91, 91]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="heapq-nlargest-n-iterable-key-None"><a href="#heapq-nlargest-n-iterable-key-None" class="headerlink" title="heapq.nlargest(n, iterable, key=None)"></a><code>heapq.nlargest(n, iterable, key=None)</code></h3><blockquote>
<p>从 <em>iterable</em> 所定义的数据集中返回前 <em>n</em> 个最大元素组成的列表。 如果提供了 <em>key</em> 则其应指定一个单参数的函数，用于从 <em>iterable</em> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key, reverse=True)[:n]</code>。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> nlargest, heapify</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">代码功能描述：</span></span><br><span class="line"><span class="string">  1. 随机生成 1 个包括 5 个数的数组，每个数的取值都在 [-100, 100] 之间</span></span><br><span class="line"><span class="string">  2. 将数组转换成堆队列</span></span><br><span class="line"><span class="string">  3. 取出堆队列中绝对值最大的 3 个值</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">min_value, max_value, count,n = -<span class="number">100</span>, <span class="number">100</span>, <span class="number">10</span>,<span class="number">3</span></span><br><span class="line">hq = random.sample(<span class="built_in">range</span>(min_value, max_value + <span class="number">1</span>), count)  <span class="comment"># 创建一个 Python list</span></span><br><span class="line">key = <span class="keyword">lambda</span> a: a <span class="keyword">if</span> a &gt;= <span class="number">0</span> <span class="keyword">else</span> -a</span><br><span class="line"></span><br><span class="line">heapify(hq)  <span class="comment"># 将 hq 转换成堆队列(构建小顶堆)</span></span><br><span class="line">largest = nlargest(n, hq, key=key)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;堆队列为 &gt;&gt; <span class="subst">&#123;hq&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;绝对值最大的 <span class="subst">&#123;n&#125;</span> 个数 &gt;&gt; <span class="subst">&#123;largest&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">运行结果:</span></span><br><span class="line"><span class="string">堆队列为 &gt;&gt; [-86, -61, -6, -33, 8, 11, 97, 88, 82, 62]</span></span><br><span class="line"><span class="string">绝对值最大的 3 个数 &gt;&gt; [97, 88, -86]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="heapq-nsmallest-n-iterable-key-None"><a href="#heapq-nsmallest-n-iterable-key-None" class="headerlink" title="heapq.nsmallest(n, iterable, key=None)"></a><code>heapq.nsmallest(n, iterable, key=None)</code></h3><blockquote>
<p>从 <em>iterable</em> 所定义的数据集中返回前 <em>n</em> 个最小元素组成的列表。 如果提供了 <em>key</em> 则其应指定一个单参数的函数，用于从 <em>iterable</em> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key)[:n]</code>。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> nsmallest, heapify</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">代码功能描述：</span></span><br><span class="line"><span class="string">  1. 随机生成 1 个包括 5 个数的数组，每个数的取值都在 [-100, 100] 之间</span></span><br><span class="line"><span class="string">  2. 将数组转换成堆队列</span></span><br><span class="line"><span class="string">  3. 取出堆队列中绝对值最小的 3 个值</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">min_value, max_value, count,n = -<span class="number">100</span>, <span class="number">100</span>, <span class="number">10</span>,<span class="number">3</span></span><br><span class="line">hq = random.sample(<span class="built_in">range</span>(min_value, max_value + <span class="number">1</span>), count)  <span class="comment"># 创建一个 Python list</span></span><br><span class="line">key = <span class="keyword">lambda</span> a: a <span class="keyword">if</span> a &gt;= <span class="number">0</span> <span class="keyword">else</span> -a</span><br><span class="line"></span><br><span class="line">heapify(hq)  <span class="comment"># 将 hq 转换成堆队列(构建小顶堆)</span></span><br><span class="line">smallest = nsmallest(n, hq, key=key)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;堆队列为 &gt;&gt; <span class="subst">&#123;hq&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;绝对值最小的 <span class="subst">&#123;n&#125;</span> 个数 &gt;&gt; <span class="subst">&#123;smallest&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">运行结果:</span></span><br><span class="line"><span class="string">堆队列为 &gt;&gt; [-86, -61, -6, -33, 8, 11, 97, 88, 82, 62]</span></span><br><span class="line"><span class="string">绝对值最小的 3 个数 &gt;&gt; [-6, 8, 11]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li><code>heapq.nlargest</code>和<code>heapq.nsmallest</code>函数在 <em>n</em> 值较小时性能最好。 </li>
<li>对于更大的值，使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#sorted"><code>sorted()</code></a> 函数会更有效率。</li>
<li>当 <code>n==1</code> 时，使用内置的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#min"><code>min()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#max"><code>max()</code></a> 函数会更有效率。</li>
<li> 如果需要重复使用这些函数，请考虑将可迭代对象转为真正的堆。</li>
</ol>
<h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><p><a href="https://en.wikipedia.org/wiki/Heapsort">堆排序</a> 可以通过将所有值推入堆中然后每次弹出一个最小值项来实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappush, heappop, heapify</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">iterable</span>):</span><br><span class="line">    hq = []</span><br><span class="line">    heapify(hq)</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> iterable:</span><br><span class="line">        heappush(hq, value)</span><br><span class="line">    <span class="keyword">return</span> [heappop(hq) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(hq))]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    min_value, max_value, count = -<span class="number">100</span>, <span class="number">100</span>, <span class="number">10</span></span><br><span class="line">    arr = random.sample(<span class="built_in">range</span>(min_value, max_value + <span class="number">1</span>), count)  <span class="comment"># 创建一个 Python list</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;堆排序前的结果 &gt;&gt; <span class="subst">&#123;arr&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;堆排序后的结果 &gt;&gt; <span class="subst">&#123;heap_sort(arr)&#125;</span>&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">运行结果:</span></span><br><span class="line"><span class="string">堆排序前的结果 &gt;&gt; [-87, 81, 100, 56, 10, 67, -19, -14, -7, -40]</span></span><br><span class="line"><span class="string">堆排序后的结果 &gt;&gt; [-87, -40, -19, -14, -7, 10, 56, 67, 81, 100]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>这类似于 <code>sorted(iterable)</code>，但与 <a href="https://docs.python.org/zh-cn/3/library/functions.html#sorted"><code>sorted()</code></a> 不同的是这个实现是不稳定的。</p>
<p>堆元素可以为元组。这有利于以下做法——在被跟踪的主记录旁边添一个额外的值（例如任务的优先级）用于互相比较：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappop, heapify</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr = [(<span class="number">5</span>, <span class="string">&#x27;write code&#x27;</span>), (<span class="number">7</span>, <span class="string">&#x27;release product&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;write spec&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;create tests&#x27;</span>)] <span class="comment"># 创建一个 list</span></span><br><span class="line">heapify(arr) <span class="comment"># 将 list 转换成小顶堆</span></span><br><span class="line"><span class="built_in">print</span>(heappop(arr)) <span class="comment"># 输出小顶堆的根节点</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">运行结果:</span></span><br><span class="line"><span class="string">(1, &#x27;write spec&#x27;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="优先队列实现说明"><a href="#优先队列实现说明" class="headerlink" title="优先队列实现说明"></a>优先队列实现说明</h2><p><a href="https://en.wikipedia.org/wiki/Priority_queue">优先队列</a> 是堆的常用场合，并且它的实现包含了多个挑战：</p>
<ul>
<li>排序稳定性：如何让两个相同优先级的任务按它们最初被加入队列的顺序返回？</li>
<li>如果 priority 相同且 task 之间未定义默认比较顺序，则两个 (priority, task) 元组之间的比较会报错。</li>
<li>如果任务优先级发生改变，你该如何将其移至堆中的新位置？</li>
<li>或者如果一个挂起的任务需要被删除，你该如何找到它并将其移出队列？</li>
</ul>
<p>针对前两项挑战的一种解决方案是将条目保存为包含优先级、条目计数和任务对象 3 个元素的列表。 条目计数可用来打破平局，这样具有相同优先级的任务将按它们的添加顺序返回。 并且由于没有哪两个条目计数是相同的，元组比较将永远不会直接比较两个任务。</p>
<p>两个 task 之间不可比的问题的另一种解决方案是——创建一个忽略 task，只比较 priority 字段的包装器类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, field</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass(<span class="params">order=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrioritizedItem</span>:</span><br><span class="line">    priority: <span class="built_in">int</span></span><br><span class="line">    item: <span class="type">Any</span>=field(compare=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>其余的挑战主要包括找到挂起的任务并修改其优先级或将其完全移除。 找到一个任务可使用一个指向队列中条目的字典来实现。</p>
<p>移除条目或改变其优先级的操作实现起来更为困难，因为它会破坏堆结构不变量。 因此，一种可能的解决方案是将条目标记为已移除，再添加一个改变了优先级的新条目:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq = []                         <span class="comment"># list of entries arranged in a heap</span></span><br><span class="line">entry_finder = &#123;&#125;               <span class="comment"># mapping of tasks to entries</span></span><br><span class="line">REMOVED = <span class="string">&#x27;&lt;removed-task&gt;&#x27;</span>      <span class="comment"># placeholder for a removed task</span></span><br><span class="line">counter = itertools.count()     <span class="comment"># unique sequence count</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_task</span>(<span class="params">task, priority=<span class="number">0</span></span>):</span><br><span class="line">    <span class="string">&#x27;Add a new task or update the priority of an existing task&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> task <span class="keyword">in</span> entry_finder:</span><br><span class="line">        remove_task(task)</span><br><span class="line">    count = <span class="built_in">next</span>(counter)</span><br><span class="line">    entry = [priority, count, task]</span><br><span class="line">    entry_finder[task] = entry</span><br><span class="line">    heappush(pq, entry)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove_task</span>(<span class="params">task</span>):</span><br><span class="line">    <span class="string">&#x27;Mark an existing task as REMOVED.  Raise KeyError if not found.&#x27;</span></span><br><span class="line">    entry = entry_finder.pop(task)</span><br><span class="line">    entry[-<span class="number">1</span>] = REMOVED</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop_task</span>():</span><br><span class="line">    <span class="string">&#x27;Remove and return the lowest priority task. Raise KeyError if empty.&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> pq:</span><br><span class="line">        priority, count, task = heappop(pq)</span><br><span class="line">        <span class="keyword">if</span> task <span class="keyword">is</span> <span class="keyword">not</span> REMOVED:</span><br><span class="line">            <span class="keyword">del</span> entry_finder[task]</span><br><span class="line">            <span class="keyword">return</span> task</span><br><span class="line">    <span class="keyword">raise</span> KeyError(<span class="string">&#x27;pop from an empty priority queue&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>堆是通过数组来实现的，其中的元素从 0 开始计数，对于所有的 <em>k</em> 都有 <code>a[k] &lt;= a[2*k+1]</code> 且 <code>a[k] &lt;= a[2*k+2]</code>。 为了便于比较，不存在的元素被视为无穷大。 堆最有趣的特性在于 <code>a[0]</code> 总是其中最小的元素。</p>
<p>上面的特殊不变量是用来作为一场锦标赛的高效内存表示。 下面的数字是 <em>k</em> 而不是 <code>a[k]</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">                               <span class="number">0</span></span><br><span class="line"></span><br><span class="line">              <span class="number">1</span>                                 <span class="number">2</span></span><br><span class="line"></span><br><span class="line">      <span class="number">3</span>               <span class="number">4</span>                <span class="number">5</span>               <span class="number">6</span></span><br><span class="line"></span><br><span class="line">  <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span>      <span class="number">11</span>      <span class="number">12</span>      <span class="number">13</span>      <span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span> <span class="number">16</span>   <span class="number">17</span> <span class="number">18</span>   <span class="number">19</span> <span class="number">20</span>   <span class="number">21</span> <span class="number">22</span>   <span class="number">23</span> <span class="number">24</span>   <span class="number">25</span> <span class="number">26</span>   <span class="number">27</span> <span class="number">28</span>   <span class="number">29</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>

<p>在上面的树中，每个 <em>k</em> 单元都位于 <code>2*k+1</code> 和 <code>2*k+2</code> 之上。 体育运动中我们经常见到二元锦标赛模式，每个胜者单元都位于另两个单元之上，并且我们可以沿着树形图向下追溯胜者所遇到的所有对手。 但是，在许多采用这种锦标赛模式的计算机应用程序中，我们并不需要追溯胜者的历史。 为了获得更高的内存利用效率，当一个胜者晋级时，我们会用较低层级的另一条目来替代它，因此规则变为一个单元和它之下的两个单元包含三个不同条目，上方单元“胜过”了两个下方单元。</p>
<p>如果此堆的不变性质始终受到保护，则序号 0 显然是总的赢家。 删除它并找出“下一个”赢家的最简单算法方式是将某个输家（让我们假定是上图中的 30 号单元）移至 0 号位置，然后将这个新的 0 号沿树下行，不断进行值的交换，直到不变性质得到重建。 这显然会是树中条目总数的对数。 通过迭代所有条目，你将得到一个 O(n log n) 复杂度的排序。</p>
<p>此排序有一个很好的特性就是你可以在排序进行期间高效地插入新条目，前提是插入的条目不比你最近取出的 0 号元素“更好”。 这在模拟上下文时特别有用，在这种情况下树保存的是所有传入事件，“胜出”条件是最小调度时间。 当一个事件将其他事件排入执行计划时，它们的调试时间向未来方向延长，这样它们可方便地入堆。 因此，堆结构很适宜用来实现调度器，我的 MIDI 音序器就是用的这个 :-)。</p>
<p>用于实现调度器的各种结构都得到了充分的研究，堆是非常适宜的一种，因为它们的速度相当快，并且几乎是恒定的，最坏的情况与平均情况没有太大差别。 虽然还存在其他总体而言更高效的实现方式，但其最坏的情况却可能非常糟糕。</p>
<p>堆在大磁盘排序中也非常有用。 你应该已经了解大规模排序会有多个“运行轮次”（即预排序的序列，其大小通常与 CPU 内存容量相关），随后这些轮次会进入合并通道，轮次合并的组织往往非常巧妙 <a href="https://docs.python.org/zh-cn/3/library/heapq.html#id2">1</a>。 非常重要的一点是初始排序应产生尽可能长的运行轮次。 锦标赛模式是达成此目标的好办法。 如果你使用全部有用内存来进行锦标赛，替换和安排恰好适合当前运行轮次的条目，你将可以对于随机输入生成两倍于内存大小的运行轮次，对于模糊排序的输入还会有更好的效果。</p>
<p>另外，如果你输出磁盘上的第 0 个条目并获得一个可能不适合当前锦标赛的输入（因为其值要“胜过”上一个输出值），它无法被放入堆中，因此堆的尺寸将缩小。 被释放的内存可以被巧妙地立即重用以逐步构建第二个堆，其增长速度与第一个堆的缩减速度正好相同。 当第一个堆完全消失时，你可以切换新堆并启动新的运行轮次。 这样做既聪明又高效！</p>
<p>总之，堆是值得了解的有用内存结构。 我在一些应用中用到了它们，并且认为保留一个 &#39;heap&#39; 模块是很有意义的。 :-)</p>
<h2 id="异常解释"><a href="#异常解释" class="headerlink" title="异常解释"></a>异常解释</h2><h3 id="exception-IndexError"><a href="#exception-IndexError" class="headerlink" title="exception IndexError"></a><code>exception IndexError</code></h3><blockquote>
<p>当序列抽取超出范围时将被引发。 （切片索引会被静默截短到允许的范围；如果指定索引不是整数则 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError"><code>TypeError</code></a> 会被引发。）</p>
</blockquote>
<h3 id="exception-TypeError"><a href="#exception-TypeError" class="headerlink" title="exception TypeError"></a><code>exception TypeError</code></h3><blockquote>
<p>当一个操作或函数被应用于类型不适当的对象时将被引发。 关联的值是一个字符串，给出有关类型不匹配的详情。</p>
<p>此异常可以由用户代码引发，以表明尝试对某个对象进行的操作不受支持也不应当受支持。 如果某个对象应当支持给定的操作但尚未提供相应的实现，所要引发的适当异常应为 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#NotImplementedError"><code>NotImplementedError</code></a>。</p>
<p>传入参数的类型错误 (例如在要求 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int"><code>int</code></a> 时却传入了 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#list"><code>list</code></a>) 应当导致 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError"><code>TypeError</code></a>，但传入参数的值错误 (例如传入要求范围之外的数值) 则应当导致 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError"><code>ValueError</code></a>。</p>
</blockquote>
<h3 id="exception-ValueError"><a href="#exception-ValueError" class="headerlink" title="exception ValueError"></a><code>exception ValueError</code></h3><blockquote>
<p>当操作或函数接收到具有正确类型但值不适合的参数，并且情况不能用更精确的异常例如 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#IndexError"><code>IndexError</code></a> 来描述时将被引发。</p>
</blockquote>
<hr>
<p>参考文章：<a href="https://docs.python.org/zh-cn/3/library/heapq.html">heapq --- 堆队列算法 — Python 3.12.0 文档</a></p>
<p>如有侵权行为，请告知删除。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>heapq</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>heapq</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题200道打卡</title>
    <url>//2023/01/31/other-leetcode-%E3%80%902023-01-31-LeetCode-%E5%88%B7%E9%A2%98-200%E9%A2%98%E6%89%93%E5%8D%A1%E3%80%91/</url>
    <content><![CDATA[<h1 id="LeetCode-刷题-200-道打卡"><a href="#LeetCode-刷题-200-道打卡" class="headerlink" title="LeetCode 刷题 200 道打卡"></a>LeetCode 刷题 200 道打卡</h1><h2 id="记录一下-LeetCode-刷题-200-道"><a href="#记录一下-LeetCode-刷题-200-道" class="headerlink" title="记录一下 LeetCode 刷题 200 道"></a>记录一下 LeetCode 刷题 200 道</h2><p><a href="https://leetcode.cn/u/david-beckham/">我的 LeetCode 主页</a><br><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/8403030b379146cd970931f0161bebf5.png" alt="200题记录"></p>
<h3 id="书山有路勤为径，学海无涯苦作舟。诸君共勉之！"><a href="#书山有路勤为径，学海无涯苦作舟。诸君共勉之！" class="headerlink" title="书山有路勤为径，学海无涯苦作舟。诸君共勉之！"></a>书山有路勤为径，学海无涯苦作舟。诸君共勉之！</h3><h3 id="再接再厉吧！"><a href="#再接再厉吧！" class="headerlink" title="再接再厉吧！"></a>再接再厉吧！</h3><blockquote>
<p><strong>时间：2023-01-31</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>多模态基础模型：从专家到通用助理</title>
    <url>//2024/01/04/2024-01-05%20%E5%A4%9A%E6%A8%A1%E6%80%81%E6%A8%A1%E5%9E%8B%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="Multimodal-Foundation-Models-From-Specialists-to-General-Purpose-Assistants-1-多模态基础模型：从专家到通用助理"><a href="#Multimodal-Foundation-Models-From-Specialists-to-General-Purpose-Assistants-1-多模态基础模型：从专家到通用助理" class="headerlink" title="Multimodal Foundation Models: From Specialists to General-Purpose Assistants[^1]多模态基础模型：从专家到通用助理"></a>Multimodal Foundation Models: From Specialists to General-Purpose Assistants[^1]<br/><span style="font-size: 24px;">多模态基础模型：从专家到通用助理</span ></h1><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/%E6%88%AA%E5%9B%BE-1702886821052.png" alt="截图-1702886821052" style="zoom:100%;" />

<h2 id="0-文章简介Paper-information"><a href="#0-文章简介Paper-information" class="headerlink" title="0. 文章简介Paper information"></a>0. 文章简介<br/><span style="font-size:22px;">Paper information</span></h2><blockquote>
<ol>
<li>文章<code>2023年9月18日</code>发表在 <a href="https://arxiv.org/">arxiv</a>上，目前还是预印版的状态，可以免费的从<a href="https://arxiv.org/abs/2309.10020">链接</a>下载到文章的原文</li>
<li>文章的作者是<code>7名</code>华人，都是微软公司的研究员</li>
<li>文章总长度是<code>119页</code>，其中正文<code>92 页</code>，参考文献<code>27页</code>，</li>
<li>文章一共<code>7个</code>章节，引用了<code>432篇</code>参考文献</li>
<li>关于这篇综述的适用读者，作者的原话是：<code>只要你想学习多模‍态基础模型的基础知识和最新进展，不管你是专业研究员，还是在校学生，它都是你的“菜”。</code>所以这篇文章非常适合我们现在这个阶段了解和学习多模态基础模型的基础只是和最新进展。</li>
</ol>
</blockquote>
<p>和上次我的主讲一样，我并不准备直接按照作者论文中的顺序直接念一遍，其中可能会有一些删减和我的一些看法。所以这次主讲我会分为以下三个部分进行：<code>引言</code>，<code>为特定目的预训练的多模态基础模型</code>，<code>发挥通用助理作用的多模式基础模型</code>。</p>
<h2 id="1-引言Introduction"><a href="#1-引言Introduction" class="headerlink" title="1. 引言Introduction"></a>1. 引言<br/><span style="font-size:22px;">Introduction</span></h2><blockquote>
<p>==<strong>注</strong>==：本文中谈到的多模态大模型主要是关于视觉方面的，我的认为是，语音可以通过一些方法或者工具转换成文字，例如：自动生成字幕等。虽然在语音转换到文字的过程中会损失一些信息，例如：说话人的语气变化，语音语调的变化，但是还是能够将说话人说出的每一个字，每一个词都完整的识别下来。但是视觉方面就很难通过方法或者工具转化成文字。</p>
<p>所以，从直觉上来看，视觉模态相对于其他模态来说，识别，分析，理解上更具有挑战性。</p>
<p>视觉是人类和许多生物感知和与世界互动的主要渠道之一。人工智能（AI）的核心愿望之一是开发AI代理来模仿这种有效感知和生成视觉信号的能力，从而推理并与视觉世界交互。例子包括识别场景中的物体和动作，以及创建用于交流的草图和图片。构建具有可视化功能的基础模型是努力实现这一目标的流行研究领域。</p>
</blockquote>
<blockquote>
<p>本文一共包括7个章节，下面简单概括了每个章节的内容：</p>
<ol>
<li><p><strong>引言（Introduction）</strong>:</p>
<ul>
<li>介绍了多模态基础模型的研究背景，强调了这些模型在视觉理解和生成任务中的重要性。</li>
<li>提出了从专家模型向通用助手模型转变的趋势，以及这一转变背后的研究动机和挑战。</li>
<li>概述了多模态基础模型的分类，包括视觉理解、视觉生成、统一视觉模型和多模态代理等。</li>
</ul>
</li>
<li><p><strong>视觉理解（Visual Understanding）</strong>:</p>
<ul>
<li>讨论了通过有标签监督学习、无标签图像-文本对比预训练和图像级自监督学习等方法来学习强大的图像表示。</li>
<li>介绍了不同的学习方法，包括使用图像分类、图像-文本对比预训练（如CLIP）和图像掩模自监督学习（如MAE）等。</li>
<li>探讨了如何通过这些方法提升模型在视觉理解任务上的性能，例如图像分类、对象检测和分割等。</li>
</ul>
</li>
<li><p><strong>视觉生成（Visual Generation）</strong>:</p>
<ul>
<li>描述了文本到图像生成模型的发展，以及如何通过人类指导来提高生成图像的质量。</li>
<li>讨论了生成模型的技术，包括基于GAN（生成对抗网络）、VAE（变分自编码器）和扩散模型等方法。</li>
<li>强调了生成模型在遵循文本描述生成图像时的挑战，以及如何通过改进模型架构和训练策略来解决这些挑战。</li>
</ul>
</li>
<li><p><strong>统一视觉模型（Unified Vision Models）</strong>:</p>
<ul>
<li>探讨了如何设计统一的模型架构来整合视觉理解和生成任务。</li>
<li>介绍了如何通过大型语言模型（LLM）来实现视觉任务的统一，以及这种统一模型在不同视觉任务上的表现。</li>
<li>分析了统一模型的优势和挑战，以及如何通过LLM来提升模型的性能。</li>
</ul>
</li>
<li><p><strong>大型多模态模型：与LLM一起训练（Large Multimodal Models: Training with LLM）</strong>:</p>
<ul>
<li>介绍了如何通过LLM来训练多模态模型，以及这些模型在理解和生成任务上的表现。</li>
<li>讨论了端到端训练方法，以及如何将LLM与视觉模型结合起来。</li>
<li>分析了这种方法在提高模型在多模态任务上的性能方面的潜力。</li>
</ul>
</li>
<li><p><strong>多模态代理：与LLM链式工具（Multimodal Agents: Chaining Tools with LLM）</strong>:</p>
<ul>
<li>讨论了如何将多模态工具与LLM结合起来，以实现更强大的视觉理解和生成能力。</li>
<li>介绍了如何通过链式工具来增强模型的功能，以及这种方法在实际应用中的潜力。</li>
<li>分析了多模态代理在工具使用、性能提升和应用多样性方面的优势。</li>
</ul>
</li>
<li><p><strong>结论和研究趋势（Conclusions and Research Trends）</strong>:</p>
<ul>
<li>总结了多模态基础模型的现状，包括它们在视觉理解和生成任务上的最新进展。</li>
<li>展望了未来研究方向，包括如何构建通用目的的AI代理，以及多模态基础模型在这一过程中的作用。</li>
<li>提出了对多模态基础模型未来发展的见解，包括如何通过技术创新和研究合作来推动这一领域的发展。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<p>随着ChatGPT和GPT-4在自然语言处理(NLP)领域取得的重要突破，计算机视觉领域研究人员提出了一个问题，ChatGPT 和GPT-4在视觉、视觉语言和多模态模型方面的对应是什么？</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/%E6%88%AA%E5%9B%BE-1703499425353.png" alt="截图-1703499425353" style="zoom:100%;" />

<h3 id="1-1-什么是多模态基础模型？-What-are-Multimodal-Foundation-Models"><a href="#1-1-什么是多模态基础模型？-What-are-Multimodal-Foundation-Models" class="headerlink" title="1.1 什么是多模态基础模型？ What are Multimodal Foundation Models?"></a>1.1 什么是多模态基础模型？ <br/><span style="font-size:18px;">What are Multimodal Foundation Models?</span></h3><blockquote>
<p><strong>基础模型</strong>：通过大量的数据训练的模型，例如：<code>Bert</code>、<code>GPT系列</code>、<code>CLIP</code>和<code>Dall-E</code>等，这些模型能够适应广泛的下游任务，所以称之为基础模型。[^3]</p>
</blockquote>
<blockquote>
<p>下图中展示了多模态基础模型旨在解决三个典型的问题：<code>视觉理解任务</code>、<code>视觉生成任务</code>和<code>具有语言理解和生成的通用接口</code></p>
<p>**视觉理解(Visual Understanding)**：如何学习视觉表达？</p>
<p>**视觉生成(Visual Generator)**：如何进行视觉生成？</p>
<p>**通用接口(General-purpose Interface)**：</p>
<ol>
<li>如何在没有LLM的情况下，将视觉模型与接口统一起来？ </li>
<li>如何训练多模态大语言模型？</li>
<li>如何将多模态专家和大模型联系起来？</li>
</ol>
<p>从图中我们可以看出具体的流程是：视觉编码器学习输入的视觉表达，输入到语言理解和生成的大语言模型中得到的输出结果输入到视觉生成模块中进行视觉的生成</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/david-deng-01/images/blog/multimodel%20foundation%20models.png" alt="多模态基础模型" style="zoom:100%;" />

<blockquote>
<ol>
<li><strong>视觉理解模型</strong>：学习一般视觉表示对于构建视觉基础模型至关重要，因为预先训练强大的视觉骨干模型(Visual Backbone Model)对于所有计算机视觉下游任务从图像级（例如，图像分类、检索和字幕），区域级（例如，检测和接地）到像素级任务（例如，分段）都是至关重要的。文章将视觉理解模型分成了三类：<ul>
<li>标签监督（Label supervision）</li>
<li>语言监督（Language supervision）</li>
<li>仅使用图片的自监督（Image-only Self-supervision）</li>
</ul>
</li>
<li><strong>视觉生成模型</strong>：<ul>
<li>文本视觉生成（Text-conditioned visual generation），通过文本生成图片和视频</li>
<li>人类对齐视觉生成（Human-aligned visual generation），使模型生成更加符合人类意图，人类价值观的图片和视频</li>
</ul>
</li>
<li><strong>通用接口</strong>：文章提到的通用接口研究集中在以下三个方面：<ul>
<li>用于理解和生成的统一视觉模型（Unified vision models for understanding and generation）通过组合特定用途的多模态模型的功能来构建通用基础模型。</li>
<li>使用大型语言模型进行训练（Training with LLMs）通过将LLM的能力扩展到多模态设置并端到端训练模型，开发了多模态LLM或大型多模态模型，包括<code>Flamingo</code>和多模式<code>GPT-4</code>。</li>
<li>使用大语言模型连接工具（Chaining tools with LLM）利用LLM的工具使用能力，将LLM（如<code>ChatGPT</code>）与各种多模态基础模型集成在一起，以通过对话界面促进图像理解和生成。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<p>基于NLP中的模型发展历史和分类，本文将多模态基础模型分为两类：</p>
<ol>
<li>**专用预训练视觉模型(Specific-Purpose Pre-trained Vision Models)**：涵盖了大多数现有的多模态基础模型，包括视觉理解模型（例如，<code>CLIP</code>、<code>Simplified</code>、<code>BEiT</code>、<code>SAM</code>）和视觉生成模型（例如，Stable Diffusion），因为它们对于特定的视觉问题呈现出强大的可转移能力。</li>
<li>**通用助手(General-Purpose Assistants)**：是指可以遵循人类意图完成各种计算机视觉任务的人工智能代理。通用助理的含义有两个方面：<ul>
<li>具有统一体系结构的模型，可以完成不同问题类型的任务，</li>
<li>遵循人类指令，而不是取代人类。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="2-成熟的多模态基础模型研究Well-established-research-of-multimodal-foundation-models"><a href="#2-成熟的多模态基础模型研究Well-established-research-of-multimodal-foundation-models" class="headerlink" title="2. 成熟的多模态基础模型研究Well-established research of multimodal foundation models"></a>2. 成熟的多模态基础模型研究<br/><span style="font-size:22px;">Well-established research of multimodal foundation models</span></h2><h3 id="2-1-视觉理解-Visual-understanding"><a href="#2-1-视觉理解-Visual-understanding" class="headerlink" title="2.1 视觉理解 Visual understanding"></a>2.1 视觉理解 <br/><span style="font-size:18px;">Visual understanding</span></h3><blockquote>
<p>视觉理解方面，作者主要介绍了如何预训练一个强大的图片骨干网络(Image Backbone)，主要是三个方面：</p>
<ol>
<li>标签监督（Label supervision）</li>
<li>语言监督（Language supervision）</li>
<li>仅使用图片的自监督（Image-only Self-supervision）</li>
</ol>
</blockquote>
<blockquote>
<p>下面是原文第二章的组织结构，感兴趣的同学可以查看原文：</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/david-deng-01/images/blog/%E6%88%AA%E5%9B%BE-1703692552675.png" alt="截图-1703692552675" style="zoom:100%;" />

<h4 id="2-1-1-标签监督Label-supervision"><a href="#2-1-1-标签监督Label-supervision" class="headerlink" title="2.1.1 标签监督Label supervision"></a>2.1.1 标签监督<br/><span style="font-size:16px;">Label supervision</span></h4><blockquote>
<p>标签监督的训练方式是最<code>“朴素”</code> 的方式，我们平常训练模型也是使用带有标签的数据集来训练模型，然后通过模型在验证集和测试集上的预测结果对比对应的标签来评价模型的性能。</p>
<p>下面是常见的几个大规模的，有标签的图片数据集：</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/david-deng-01/images/blog/%E6%88%AA%E5%9B%BE-1703748254333.png" alt="截图-1703748254333" style="zoom:100%;" />



<h4 id="2-1-2-语言监督Language-Supervision"><a href="#2-1-2-语言监督Language-Supervision" class="headerlink" title="2.1.2 语言监督Language Supervision"></a>2.1.2 语言监督<br/><span style="font-size:16px;">Language Supervision</span></h4><blockquote>
<p>传统的监督方式可能是给定一个标签，例如：1表示讽刺，0表示不讽刺，的形式进行模型的训练。语言监督(Language Supervision)使用文本作为标签而不是0，1这种编号。因为语言是一种比经典闭集标签更丰富的监督形式，可以直接用于学习可转换的图像表示</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/david-deng-01/images/blog/CLIP.png" alt="CLIP" style="zoom:100%;" />

<blockquote>
<p>从上面的图片中可以看出，左边是CLIP模型的预训练过程，右边是CLIP模型的零样本预测过程。在CLIP模型中，预训练包括两个阶段：视觉预训练和视觉-语言预训练。</p>
<ol>
<li><strong>视觉预训练</strong>：CLIP模型[^4]使用了一个基于Transformer的编码器将图像转换为特征表示，然后通过对比学习的方法，使得同一张图像的不同裁剪或变换之间的距离更近，而不同图像之间的距离更远。这样，模型就能够学习到具有区分度的视觉特征表示。</li>
<li><strong>视觉-语言预训练</strong>：CLIP模型[^4]使用了一个基于Transformer的编码器将图像和文本转换为特征表示，并通过对比学习的方法，使得相同含义的不同图像和文本之间的距离更近，而不同含义的图像和文本之间的距离更远。这样，模型就能够学习到具有良好泛化能力的视觉和语言特征表示，并用于各种视觉和语言任务中。</li>
</ol>
</blockquote>
<blockquote>
<p>OpenAI 使用从互联网上收集到的 4 亿对图像文本对，分别将文本和图像进行编码，之后使用 metric learning 进行训练，其目标是将图像与文本的相似性提高，核心流程比较简洁，可以直接参考下述伪代码：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0. 变量说明</span></span><br><span class="line"><span class="comment"># image_encoder - ResNet或Vision Transformer</span></span><br><span class="line"><span class="comment"># text_encoder - CBOW或 Text Transformer</span></span><br><span class="line"><span class="comment"># I[n, h, w, c] - 小批量对齐图像</span></span><br><span class="line"><span class="comment"># T [n, l] - 小批量对齐文本</span></span><br><span class="line"><span class="comment"># W_i[d_i, d_e] - 学习图像投影以嵌入</span></span><br><span class="line"><span class="comment"># W_t[d_t, d_e] - 学习要嵌入的文本投影</span></span><br><span class="line"><span class="comment"># t - 学习温度参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 提取每个模态的特征表示</span></span><br><span class="line">I_f = image_encoder(I) <span class="comment">#  [n, d_i]</span></span><br><span class="line">T_f = text_encoder(T) <span class="comment"># [n, d_t]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 联合多模式嵌入 [n, d_e]</span></span><br><span class="line">I_e = l2_normalize(np.dot(I_f, W_i), axis=<span class="number">1</span>)</span><br><span class="line">T_e = l2_normalize(np.dot(T_f, W_t), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 尺度成对余弦相似度 [n, n]</span></span><br><span class="line">logits = np.dot(I_e, T_e.T) * np.exp(t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 对称损失函数</span></span><br><span class="line">labels = np.arange(n)</span><br><span class="line">loss_i = cross_entropy_loss(logits, labels, axis=<span class="number">0</span>)</span><br><span class="line">loss_t = cross_entropy_loss(logits, labels, axis=<span class="number">1</span>)</span><br><span class="line">loss = (loss_i + loss_t)/<span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-仅使用图片的自监督Image-only-Self-supervision"><a href="#2-1-3-仅使用图片的自监督Image-only-Self-supervision" class="headerlink" title="2.1.3 仅使用图片的自监督Image-only Self-supervision"></a>2.1.3 仅使用图片的自监督<br/><span style="font-size:16px;">Image-only Self-supervision</span></h4><blockquote>
<ol>
<li><strong>对比学习</strong>：<ul>
<li><strong>核心思想</strong>：是促进积极的样本对和排斥消极的样本对。除了在CLIP中使用之外，对比学习也是自监督图像表示学习中的流行概念。即：对比学习着重于学习同类实例之间的共同特征，区分非同类实例之间的不同之处。</li>
<li><strong>优点</strong>：与生成式学习比较，对比学习不需要关注实例上繁琐的细节，只需要在抽象语义级别的特征空间上学会对数据的区分即可，因此模型以及其优化变得更加简单，且泛化能力更强。</li>
<li><strong>目标</strong>：是学习一个编码器，此编码器对同类数据进行相似的编码，并使不同类的数据的编码结果尽可能的不同。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><strong>非对比学习</strong>：<ol>
<li>非对比学习是一种学习范式，只使用正样本对来训练模型，不像对比度学习那样同时使用正负样本对。这种方法似乎有些反直觉，因为只尝试最小化正样本对之间的距离可能会导致恒定的解。</li>
<li>然而，非对比学习已经被证明可以使用额外的预测器和停止梯度操作来学习非平凡的表示，而且学到的表示在下游任务中表现相当（甚至更好）。</li>
</ol>
</li>
</ol>
<p>==<strong>注</strong>==：非对比学习在原文中的描写也非常的少，如果对非对比学习相关的知识感兴趣的同学可以参考下面两篇文章：</p>
<ol>
<li>SimSiam[^5]：2021年发表在 CVPR</li>
<li>DINO[^6]：2021年发表在ICCV</li>
</ol>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/david-deng-01/images/blog/%E6%88%AA%E5%9B%BE-1704091119451.png" alt="截图-1704091119451" style="zoom:100%;" />

<blockquote>
<ol start="3">
<li><strong>掩码图像建模</strong>：主要包含两个部分，分别是：图像分词器(Image Tokenizer)，掩码预测(Mask Predict)，下面是掩码图像建模模型的执行过程：<ol>
<li>原始图片通过 Tokenizer 转化成 Visual Tokens，作为模型的标签</li>
<li>原始图片进行切片，按照预先确定的规则切分成多个小图片(下图的例子中是切成了16张小图片)</li>
<li>将切片后的图片进行遮盖，和NLP任务中的掩码类似，然后将遮盖的图片展平</li>
<li>将展平后的图片，加上位置编码后送入BEiT 编码器中，得到遮盖后的图片的编码结果</li>
<li>通过掩码图片建模，得到图片遮盖部分的 Visual Token，与原始的图片进行对比</li>
<li>通过解码器还原原始图片</li>
</ol>
</li>
</ol>
<p>==<strong>注</strong>==: 对于图像掩码建模感兴趣的同学可以参考下面三篇文章:</p>
<ol>
<li>BEiT[^7]:  2022年发表在ICLR</li>
<li>MAE[^8]：2022年发表在CVPR</li>
<li>MaskFeat[^9]：2021年发表在CVPR</li>
</ol>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/david-deng-01/images/blog/image-20231229235647408.png" alt="image-20231229235647408" style="zoom:100%;" />

<img src="https://cdn.jsdelivr.net/gh/david-deng-01/images/blog/%E6%88%AA%E5%9B%BE-1704093685986.png" alt="截图-1704093685986" style="zoom:100%;" />

<h3 id="2-2-视觉生成-Vision-Generation"><a href="#2-2-视觉生成-Vision-Generation" class="headerlink" title="2.2 视觉生成 Vision Generation"></a>2.2 视觉生成 <br/><span style="font-size:18px;">Vision Generation</span></h3><blockquote>
<p>下图显示了截止到2023年7月，一些具有代表性的<code>文本到图像生成</code>模型，从图中我们可以看到，很多的模型都是由国外的一些公司或者机构提出的，例如：<code>OpenAI</code>，<code>MicroSoft</code>，<code>Nvidia</code>，<code>Meta</code>，<code>Google</code>等，还有一些中国的学校或者机构，例如：<code>清华大学</code></p>
<p>从下图可以看出，国内对于<code>文本到图像生成</code>方面的研究还不是很多，而国外研究相对来说比较多。所以在国内视觉生成方面还是一个非常值得研究的方向。</p>
<p>下面将简单的介绍三种视觉生成方面的研究，分别是：<code>空间可控生成(Spatial Controllable Generation)</code>，<code>基于文本的编辑(Text-based Editing)</code>和<code>文本提示(Text Prompts Following)</code></p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/david-deng-01/images/blog/%E6%88%AA%E5%9B%BE-1703693504301.png" alt="截图-1703693504301" style="zoom:100%;" />

<h4 id="2-2-1-空间可控生成Spatial-Controllable-Generation"><a href="#2-2-1-空间可控生成Spatial-Controllable-Generation" class="headerlink" title="2.2.1 空间可控生成Spatial Controllable Generation"></a>2.2.1 空间可控生成<br/><span style="font-size:16px;">Spatial Controllable Generation</span></h4><blockquote>
<p>Text-to-Image(T2L) 生成通产采用开放式文本供用户描述预期的图像，但是在某些描述中，仅使用文本通常是不能完整，准确的描述出用户预期的图像。</p>
<p><code>空间可控T2L生成(Spatial Controllable Text To Image Generation)</code>探索了一种扩展的T2L模型，使用额外的空间输入来指导图像的生成。</p>
<p>==<strong>注</strong>==: 对于空间可控生成方面感兴趣的同学可以参考下面这篇论文：</p>
<ol>
<li>Reco[^10]：2023年发表在IEEE/CVF</li>
</ol>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/david-deng-01/images/blog/image-20240101231034147.png" alt="image-20240101231034147" style="zoom:100%;" />

<h4 id="2-2-2-基于文本编辑Text-based-Editing"><a href="#2-2-2-基于文本编辑Text-based-Editing" class="headerlink" title="2.2.2 基于文本编辑Text-based Editing"></a>2.2.2 基于文本编辑<br/><span style="font-size:16px;">Text-based Editing</span></h4><blockquote>
<p>T2L编辑基于用户给定的图像和输入的文本描述合成新的图像，不需要完全从头开始生成，和之前的T2L模型存在一些区别，之前的T2L大部分都是从头生成一个图片。</p>
<p>T2L编辑的目标是保留大部分的视觉内容，只修改特定的组件，这可能涉及更改局部对象或整体图像样式以精确匹配用户的意图。</p>
<p>T2L编辑为用户提供了一种工具，可以根据已有的图像生成新的图像，在创建准确遵循人类意图的视觉内容方面发挥着至关重要的作用。</p>
<p>下图介绍了三种T2L编辑方式，分别是：<code>单词替换</code>，<code>添加新短语</code>和<code>注意力权重调整</code>。</p>
<p>==<strong>注</strong>==: 对于基于文本编辑方面感兴趣的同学可以参考下面这篇论文：</p>
<ol>
<li>Prompt- to-prompt image editing with cross-attention control[^11]: 2023年发表在ICLR</li>
</ol>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/david-deng-01/images/blog/%E6%88%AA%E5%9B%BE-1704126148632.png" alt="截图-1704126148632" style="zoom:100%;" />

<blockquote>
<p><code>单词替换</code>，<code>添加新短语</code>和<code>注意力权重调整</code>三种方法的概述：顶部：视觉和文本嵌入使用交叉注意力层进行融合，为每个文本标记生成空间注意力图。底部：我们使用源图像的注意力图来控制生成图像的空间布局和几何结构。这通过仅编辑文本提示来启用各种编辑任务。当在提示中交换单词时，我们注入源图像映射Mt，覆盖目标图像映射M*t，以保留空间布局。其中，在添加新短语的情况下，我们只注入与提示的未更改部分相对应的映射。通过重新加权相应的注意力图来放大或减弱单词的语义效果。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/david-deng-01/images/blog/image-20240102002848562.png" alt="image-20240102002848562" style="zoom:100%;" />

<blockquote>
<p><strong>添加，删除，修改一些单词</strong>：我们的方法提供了各种“提示到提示”编辑功能。用户可以调整形容词的影响程度（左上）、替换图像中的项目（右上）、指定图像的样式（左下）或对生成的图像进行进一步细化（右下）。操作通过扩散模型的交叉注意力机制渗透，而不需要在图像像素空间上进行任何规范。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/david-deng-01/images/blog/image-20240102003100042.png" alt="image-20240102003100042" style="zoom:100%;" />

<blockquote>
<p><strong>注意力权重调整</strong>：通过不同数量的扩散步骤注入注意力。在顶部，我们显示源图像和提示。在每一行中，我们通过替换文本中的单个单词并注入源图像的交叉注意力图来修改图像的内容，该图的范围从0%（左侧）到100%（右侧）的扩散步骤。请注意，一方面，如果没有我们的方法，就不能保证保留任何源图像内容。另一方面，在所有扩散步骤中注入交叉注意力可能会过度约束几何体，导致对文本提示的保真度较低，例如，汽车（第三排）变成了具有完全交叉注意力注入的自行车。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/david-deng-01/images/blog/image-20240102003441391.png" alt="image-20240102003441391" style="zoom:100%;" />

<h4 id="2-2-3-文本提示跟随Text-Prompts-Following"><a href="#2-2-3-文本提示跟随Text-Prompts-Following" class="headerlink" title="2.2.3 文本提示跟随Text Prompts Following"></a>2.2.3 文本提示跟随<br/><span style="font-size:16px;">Text Prompts Following</span></h4><blockquote>
<p>使用图像文本配对进行训练，可以促使T2I模型生成与输入文本条件在语义上相对应的图像。然而，图像生成训练目标并不直接要求生成的图像完全遵循文本提示。有研究表明： T2I模型可能无法完全遵循文本提示，尤其是当图像描述变得复杂时。例如，某些名词短语可能会被省略，属性可能被错误地应用到不正确的对象上，生成的图像可能具有错误的对象数量、关系、风格等。这些限制促使人们致力于改进T2I模型，使其更好地遵循文本提示。</p>
<p>==<strong>注</strong>==: 对于文本提示跟随方面感兴趣的同学可以参考下面这篇论文：</p>
<ol>
<li>DreamBooth[^12]：2023年发表在CVPR</li>
</ol>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/david-deng-01/images/blog/image-20240102144342034.png" alt="image-20240102144342034" style="zoom:100%;" />

<blockquote>
<p>仅凭几张（通常3-5张）关于某个主题（左图）的图片，我们的模型DreamBooth就能在不同的情境（右图）中生成大量该主题的图片，同时利用文本提示的指导。这些结果展现了与环境的自然互动，以及新颖的表达和光照条件的变化，同时保持了对主题关键视觉特征的高度保真。</p>
</blockquote>
<blockquote>
<p>我对于这部分的理解是，用户可以输入3到5张图片，然后输入一个提示，例如上图中演示的样子，然后模型根据用户输入的图片和提示生成对应的图片。上图中输入了几张狗狗的图片，然后输入的提示是<code>&quot;in the Acropolis&quot;</code>，模型就能输出一只在<code>卫城(古希腊的一个地名，现在位于埃及境内)</code>狗狗的图片。</p>
</blockquote>
<h2 id="3-探索性的，开放的多模式基础模型的研究Research-on-exploratory-and-open-multimodal-foundational-models"><a href="#3-探索性的，开放的多模式基础模型的研究Research-on-exploratory-and-open-multimodal-foundational-models" class="headerlink" title="3. 探索性的，开放的多模式基础模型的研究Research on exploratory and open multimodal foundational models"></a>3. 探索性的，开放的多模式基础模型的研究<br/><span style="font-size:22px;">Research on exploratory and open multimodal foundational models</span></h2><h3 id="3-1-统一视觉模型Unified-vision-models"><a href="#3-1-统一视觉模型Unified-vision-models" class="headerlink" title="3.1 统一视觉模型Unified vision models"></a>3.1 统一视觉模型<br/><span style="font-size:18px;">Unified vision models</span></h3><blockquote>
<p> 在“统一视觉模型（Unified Vision Models）”章节中，文章详细探讨了如何构建能够处理多种视觉任务的统一模型架构。本章节的核心内容可以概括为以下几点：</p>
</blockquote>
<blockquote>
<ol>
<li><strong>统一模型架构的提出</strong>：<ul>
<li>提出了一种新的模型设计理念，即通过统一的视觉模型架构来处理不同的视觉任务，如图像分类、对象检测、分割等。</li>
<li>这种架构旨在减少模型的复杂性，提高训练和推理的效率，同时在多个任务上实现更好的性能。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><strong>视觉和语言的统一</strong>：<ul>
<li>文章讨论了如何将视觉信息和语言信息融合在一个模型中，以便更好地理解和处理视觉内容。</li>
<li>这包括使用共享的表示空间来整合视觉和语言特征，以及如何通过这种融合来提高模型在视觉理解任务上的性能。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li><strong>模型训练策略</strong>：<ul>
<li>描述了使用大规模图像数据集进行预训练的方法，以及如何通过微调来适应特定的下游任务。</li>
<li>强调了在预训练阶段使用多样化的数据集，以及在微调阶段使用任务特定的数据集来提高模型的泛化能力。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li><strong>功能统一的实现</strong>：<ul>
<li>探讨了如何通过统一的模型架构来实现不同的视觉功能，例如通过共享的编码器和解码器来处理图像分类和分割任务。</li>
<li>讨论了如何通过调整模型的输出层来适应不同的任务需求，例如从图像级到像素级的转换。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li><strong>从静态到提示式模型的转变</strong>：<ul>
<li>文章提出了将静态视觉模型转变为能够响应用户指令的提示式模型的方法。</li>
<li>这涉及到模型如何理解和遵循用户的自然语言指令，以及如何将这些指令转化为视觉输出。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="6">
<li><strong>总结和讨论</strong>：<ul>
<li>总结了统一视觉模型在处理多样化视觉任务中的潜力，以及通过整合视觉和语言信息来提高模型的理解和生成能力。</li>
<li>对未来的研究方向进行了讨论，包括如何进一步提升模型的性能、泛化能力，以及如何更好地理解和生成视觉内容。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<p> 这一章节强调了统一视觉模型在处理多样化视觉任务中的潜力，以及如何通过整合视觉和语言信息来提高模型的理解和生成能力。通过统一模型，研究者们希望能够构建出更加灵活、高效且强大的视觉系统，这些系统能够在多种视觉任务中展现出强大的性能。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/david-deng-01/images/blog/%E6%88%AA%E5%9B%BE-1704180909968.png" alt="截图-1704180909968" style="zoom:100%;" />

<blockquote>
<p> 在自然语言处理（NLP）领域，我们已经见证了构建统一模型的明确趋势，例如GPT-3以及随后的复杂的人-人工智能交互系统ChatGPT，这激发了整个社区和社会对人工智能的兴趣。对于计算机视觉（CV）领域，一个自然的问题是我们是否可以统一所有不同类型的视觉任务，如图像分类、目标检测、分割和视觉问答等，并相应地构建计算机视觉模型与人类之间的交互接口。受到这一愿景的启发，最近已经有许多尝试从不同的角度解决这个问题，包括但不限于（a）使视觉模型成为开放式集合；（b）统一不同的粒度；以及（c）使模型更具提示性。</p>
</blockquote>
<h4 id="3-1-1-从闭集模型到开集模型From-Closed-Set-to-Open-Set-Models"><a href="#3-1-1-从闭集模型到开集模型From-Closed-Set-to-Open-Set-Models" class="headerlink" title="3.1.1 从闭集模型到开集模型From Closed-Set to Open-Set Models"></a>3.1.1 从闭集模型到开集模型<br/><span style="font-size:16px;">From Closed-Set to Open-Set Models</span></h4><blockquote>
<p><strong>问题1</strong>：什么是<code>Closed-Set Models</code>？</p>
<ol>
<li>这些模型是在有限的、预先定义好的类别集合上进行训练的。例如，一个图像分类模型可能只被训练来识别特定的一组类别，如ImageNet数据集中的1000个类别。</li>
<li>封闭集合模型在训练时只考虑这些类别，并且在测试时也仅对这些类别进行预测。</li>
<li>这些模型的一个主要限制是它们无法识别训练数据集中不存在的新类别或未见过的类别。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>问题2</strong>：什么是<code>Open-Set Models</code>？</p>
<ol>
<li>开放集合模型旨在处理超出训练数据集类别范围的新类别。它们不仅能够识别训练过的类别，还能够识别和处理未见过的新类别。</li>
<li>这些模型通常使用一种机制来区分已知类别和未知类别，例如通过概率分布或置信度得分来区分。</li>
<li>开放集合模型在处理现实世界的视觉任务时更为灵活，因为现实世界中存在无数的类别，而不仅仅是训练数据集中的那些。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>问题3</strong>：<code>Closed-Set Models</code> 和 <code>Open-Set Models</code> 有什么相同点和不同点？</p>
<ol>
<li><p><strong>相同点</strong>：</p>
<ul>
<li>无论是封闭集合模型还是开放集合模型，它们都旨在从视觉数据（如图像）中提取有意义的信息，并进行分类或识别。</li>
</ul>
</li>
<li><p><strong>不同点</strong>：</p>
<ul>
<li><strong>类别范围</strong>：封闭集合模型仅针对有限的类别进行训练和测试，而开放集合模型能够处理超出训练数据集的类别。</li>
<li><strong>泛化能力</strong>：开放集合模型通常需要更强的泛化能力，因为它们需要能够识别和处理训练过程中未遇到的新类别。</li>
<li><strong>输出格式</strong>：开放集合模型的输出可能包括一个额外的“未知”类别，而封闭集合模型的输出则限于训练过的类别。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong>问题4</strong>：如何从<code>Closed-Set Models</code> 转变到 <code>Open-Set Models</code>？</p>
<ol>
<li><strong>数据表示的扩展</strong>：通过引入文本描述或概念嵌入，将图像数据与丰富的语义信息结合起来。例如，使用CLIP模型，可以将图像与描述图像内容的文本描述配对，从而学习到图像和文本之间的映射关系。</li>
<li><strong>训练策略的调整</strong>：采用对比学习等自监督学习方法，使用大量的图像-文本对进行预训练，使模型能够学习到更广泛的视觉特征和语义表示。</li>
<li><strong>模型架构的改进</strong>：设计能够处理开放集合任务的模型架构。例如，可以在模型的输出层添加一个额外的分支，用于输出未知类别的置信度得分。</li>
<li><strong>评估方法的更新</strong>：开发新的评估指标和测试集，以更准确地衡量模型在开放集合设置下的性能。这可能包括设计包含未见过类别的测试集，以及开发能够评估模型对未知类别识别能力的指标。</li>
</ol>
</blockquote>
<h4 id="3-1-2-从特定任务模型到通用模型From-Task-Specific-Models-to-Generic-Models"><a href="#3-1-2-从特定任务模型到通用模型From-Task-Specific-Models-to-Generic-Models" class="headerlink" title="3.1.2 从特定任务模型到通用模型From Task-Specific Models to Generic Models"></a>3.1.2 从特定任务模型到通用模型<br/><span style="font-size:16px;">From Task-Specific Models to Generic Models</span></h4><blockquote>
<p><strong>问题1</strong>：什么是<code>Task-Specific Models</code>？</p>
<ol>
<li><strong>设计目的</strong>：这些模型是为了解决特定的视觉任务而设计的，如图像分类、目标检测、分割等。</li>
<li><strong>训练数据</strong>：它们通常在特定的、有限的数据集上进行训练，例如，一个图像分类模型可能只在ImageNet数据集上进行训练。</li>
<li><strong>性能依赖</strong>：模型的性能高度依赖于训练数据的质量和多样性。如果模型只见过有限的类别，它可能在识别新的、未见过的类别时遇到困难。</li>
<li><strong>架构定制</strong>：为了优化特定任务的性能，这些模型可能会包含为该任务定制的模块或架构。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>问题2</strong>：什么是<code>Generic Models</code>？</p>
<ol>
<li><strong>设计目的</strong>：通用模型旨在处理多种视觉任务，而不是仅限于单一任务。它们的目标是学习一种通用的视觉表示，这种表示可以在多个任务之间迁移。</li>
<li><strong>训练数据</strong>：通用模型通常在大规模、多样化的数据集上进行预训练，以学习丰富的视觉特征和模式。</li>
<li><strong>迁移学习</strong>：通过迁移学习，这些模型可以在预训练的基础上，通过微调来适应特定的视觉任务，从而提高在新任务上的性能。</li>
<li><strong>架构灵活性</strong>：通用模型的架构设计通常更加灵活，可以适应不同的任务需求，而不需要为每个任务重新设计模型。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>问题3</strong>：<code>Task-Specific Models</code> 和 <code>Generic Models</code> 有什么相同点和不同点？</p>
<ol>
<li><p><strong>相同点</strong>：</p>
<ul>
<li>无论是任务特定模型还是通用模型，它们都是计算机视觉模型，旨在从视觉数据中提取有意义的信息。</li>
<li>两者都可以通过深度学习技术进行训练，并且可以利用神经网络架构来学习复杂的视觉特征。</li>
</ul>
</li>
<li><p><strong>不同点</strong>：</p>
<ul>
<li><strong>任务范围</strong>：任务特定模型专注于单一任务，而通用模型旨在处理多种任务。</li>
<li><strong>训练数据</strong>：任务特定模型通常针对特定数据集进行训练，而通用模型则在大规模、多样化的数据集上进行预训练。</li>
<li><strong>迁移学习</strong>：通用模型通过迁移学习可以适应新任务，而任务特定模型则需要为每个新任务重新训练。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong>问题4</strong>：如何从<code>Task-Specific Models</code> 转变到 <code>Generic Models</code>？</p>
<ul>
<li><strong>预训练</strong>：在大规模数据集上进行预训练，以学习通用的视觉特征。这可以通过使用无监督或自监督学习方法来完成，如对比学习、掩模自编码等。</li>
<li><strong>微调</strong>：在预训练的基础上，对模型进行微调，以适应特定的视觉任务。这通常涉及到在特定任务的数据集上进行额外的训练。</li>
<li><strong>模型设计</strong>：设计能够适应多种任务的模型架构。例如，使用统一的编码器-解码器结构，或者通过模块化设计来整合不同的视觉任务。</li>
<li><strong>损失函数和训练策略</strong>：开发新的损失函数和训练策略，以促进模型在多个任务上的学习。这可能包括多任务学习、元学习等方法。</li>
</ul>
</blockquote>
<h4 id="3-1-3-从静态模型到可提示模型From-Static-to-Promptable-Models"><a href="#3-1-3-从静态模型到可提示模型From-Static-to-Promptable-Models" class="headerlink" title="3.1.3 从静态模型到可提示模型From Static to Promptable Models"></a>3.1.3 从静态模型到可提示模型<br/><span style="font-size:16px;">From Static to Promptable Models</span></h4><blockquote>
<p><strong>问题1</strong>：什么是<code>Static Models</code>？</p>
<ol>
<li><strong>定义</strong>：静态模型是指那些在特定任务上进行训练，并且在测试时仅执行这些任务的模型。它们通常不涉及与用户的交互，而是直接对输入数据进行处理并输出结果。</li>
<li><strong>交互性</strong>：静态模型的交互性有限，用户通常只能提供数据输入，而不能直接影响模型的决策过程。</li>
<li><strong>灵活性</strong>：由于静态模型针对特定任务进行优化，它们在处理未在训练数据中见过的新情况时可能表现不佳。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>问题2</strong>：什么是<code>Promptable Models</code>？</p>
<ol>
<li><strong>定义</strong>：可提示模型允许用户通过自然语言提示来引导模型的行为。这些模型通常结合了视觉处理能力和语言理解能力，能够根据用户的指令执行多样化的任务。</li>
<li><strong>交互性</strong>：可提示模型提供了一种更自然、更直观的交互方式，用户可以通过文本提示来指导模型的输出。</li>
<li><strong>灵活性</strong>：这些模型通常更灵活，因为它们可以根据用户的提示适应不同的任务需求，即使这些任务在训练时并未直接见过。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>问题3</strong>：<code>Static Models</code> 和 <code>Promptable Models</code> 有什么相同点和不同点？</p>
<ol>
<li><strong>相同点</strong>：无论是静态模型还是可提示模型，它们都是基于深度学习的计算机视觉模型，旨在处理视觉数据并生成有意义的输出。</li>
<li><strong>不同点</strong>：<ul>
<li><strong>交互方式</strong>：静态模型通常不提供交互界面，而可提示模型允许用户通过文本提示与模型进行交互。</li>
<li><strong>灵活性</strong>：可提示模型在任务执行上的灵活性更高，因为它们可以根据用户的指令适应不同的任务需求。</li>
<li><strong>输出控制</strong>：静态模型的输出通常是固定的，而可提示模型的输出可以根据用户的提示进行调整。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong>问题4</strong>：如何从<code>Static Models</code> 转变到 <code>Promptable Models</code>？</p>
<ol>
<li><strong>集成语言模型</strong>：将视觉模型与大型语言模型（如GPT系列）结合，使模型能够理解和响应自然语言指令。这通常涉及到将视觉模型的输出与语言模型的输入结合起来。</li>
<li><strong>训练策略</strong>：开发新的训练策略，使模型能够在视觉任务中学习和利用自然语言提示。这可能包括对比学习、强化学习等方法，以提高模型对提示的敏感性和响应性。</li>
<li><strong>模型架构</strong>：设计能够处理文本提示的模型架构。这可能包括添加文本编码器来处理用户输入的提示，以及调整视觉模型的输出层以适应提示引导的任务。</li>
<li><strong>用户界面</strong>：构建用户界面，允许用户通过文本提示与模型进行交互。这可能包括聊天界面、图形用户界面（GUI）或其他用户友好的交互方式。</li>
</ol>
</blockquote>
<h3 id="3-2-大语言模型加持的多模态大模型Large-Multimodal-Models-Training-with-LLM"><a href="#3-2-大语言模型加持的多模态大模型Large-Multimodal-Models-Training-with-LLM" class="headerlink" title="3.2 大语言模型加持的多模态大模型Large Multimodal Models: Training with LLM"></a>3.2 大语言模型加持的多模态大模型<br/><span style="font-size:18px;">Large Multimodal Models: Training with LLM</span></h3><h4 id="3-2-1-背景Background"><a href="#3-2-1-背景Background" class="headerlink" title="3.2.1 背景Background"></a>3.2.1 背景<br/><span style="font-size:16px;">Background</span></h4><blockquote>
<p>大型语言模型（LLMs）结合进行训练的研究背景的总结：</p>
<ol>
<li><strong>多模态生成模型</strong>：介绍了多模态生成模型的基本概念，这些模型能够将图像作为输入，输出文本序列。这些模型通常包含一个图像编码器来提取视觉特征，以及一个语言模型来生成文本序列。</li>
<li><strong>模型架构</strong>：描述了这些模型的典型架构，包括图像编码器和语言模型，以及它们之间的连接模块。图像编码器和语言模型可以是从头开始训练的，也可以是从预训练模型初始化的。</li>
<li><strong>训练目标</strong>：阐述了模型的训练目标，通常采用自回归损失函数在输出文本序列上进行训练。在Transformer架构中，图像标记可以相互关注，当前文本标记可以关注所有图像标记以及之前的文本标记。</li>
<li><strong>案例研究</strong>：提供了一些著名的大型多模态模型（如GIT和BLIP2）作为案例研究，展示了如何在不同的模型架构中实现上述网络结构，同时保持相同的自回归训练目标。</li>
<li><strong>多模态上下文学习</strong>：特别强调了多模态上下文学习（Multimodal In-Context-Learning）这一新兴特性，这是Flamingo模型的一个显著特点。这种能力使得模型能够通过少量示例进行零样本任务迁移，解决未见过的复杂问题。</li>
<li><strong>OpenAI Multimodal GPT-4</strong>：提到了OpenAI发布的GPT-4模型，它展示了在视觉理解和推理方面的强能力，尽管模型的具体细节尚未公开。</li>
<li><strong>研究差距</strong>：指出了当前多模态模型与OpenAI Multimodal GPT-4之间存在的差距，特别是在如何执行指令跟随和对齐人类意图的研究方面。</li>
</ol>
<p>这一章节为读者提供了大型多模态模型的背景知识，特别是它们如何与大型语言模型结合进行训练，以及这些模型在视觉理解和生成任务中的最新进展。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/david-deng-01/images/blog/%E6%88%AA%E5%9B%BE-1704273389055.png" alt="截图-1704273389055" style="zoom:100%;" />

<blockquote>
<p>OpenAI 提出的多模态GPT-4，视觉样例来自OpenAI[^13]</p>
</blockquote>
<h2 id="4-总结和展望"><a href="#4-总结和展望" class="headerlink" title="4. 总结和展望"></a>4. 总结和展望</h2><h3 id="3-3-总结Summary-and-Conclusions"><a href="#3-3-总结Summary-and-Conclusions" class="headerlink" title="3.3 总结Summary and Conclusions"></a>3.3 总结<br/><span style="font-size:18px;">Summary and Conclusions</span></h3><blockquote>
<ol>
<li><strong>特定目的的多模态基础模型</strong>：这些模型针对计算机视觉社区中的多样化问题进行了广泛的研究。为了为引入通用视觉助手打下全面基础，讨论了许多研讨会论文，涵盖了在预训练时代的问题。主要范式是在大量与问题相关的数据上进行预训练，然后以零或少次的方式转移到相同问题类型的现实世界场景中。具体来说，章节讨论了两个一般主题：<ul>
<li>在第2章视觉理解中：各个多模态基础模型已经发展到可以在图像、区域、像素级别分析视觉内容，语言增强视觉模型是最近在野外视觉理解任务中取得成功的流行家族。 </li>
<li>在第3章视觉生成中：文本到图像生成模型为图像合成奠定了基础，已经成功地扩展到允许用户以更细粒度的方式控制和自定义图像。大量与问题相关的数据的可用性在使这些多模态基础模型成为可能方面发挥了关键作用。</li>
</ul>
</li>
<li><strong>通用助手</strong>：作者回顾了最近出现的文献，关于构建通用助手，这些助手通常具有统一的网络架构、统一的输入输出数据格式以及便于与人类轻松互动的通用接口。受到大型语言模型（LLM）如ChatGPT/GPT-4作为广泛语言任务的通用助手的启发，计算机视觉研究人员探索了针对视觉任务的对应解决方案。根据LLM在方法论中的利用方式，现有工作可以分为三个主题：<ul>
<li>第4章统一视觉模型中：借鉴LLM中统一建模的精神，构建不同级别和跨不同任务的统一视觉模型。</li>
<li>第5章与LLM一起训练中：从预训练的LLM开始，将视觉数据连接到LLM进行端到端训练。</li>
<li>第6章与LLM链接中：通过冻结LLM，现有的视觉专家可以通过提示工程LLM来完成特定视觉任务。</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="3-3-展望Research-Trends"><a href="#3-3-展望Research-Trends" class="headerlink" title="3.3 展望Research Trends"></a>3.3 展望<br/><span style="font-size:18px;">Research Trends</span></h3><blockquote>
<p>构建通用目的AI代理的研究方向和趋势的主要内容：</p>
<ol>
<li><strong>通用代理与多模态性</strong>：<ul>
<li>作者强调了构建一个单一的通用代理，它能够通过融合多种渠道（如语言、视觉、语音和行动）与世界互动，类似于人类。在这种背景下，多模态基础模型的概念变得不那么突出，而是成为代理感知和合成视觉信号的关键组成部分。</li>
<li>提出了构建一个能够像人类一样通过多种渠道（如语言、视觉、语音和动作）与世界互动的单一通用代理的目标。</li>
<li>多模态基础模型被视为代理感知和合成视觉信号的关键组成部分，而不是单独的模态。例如，Gato（Reed等人，2022）和PaLM-E（Driess等人，2023）展示了如何使用单一的模型权重执行广泛的语言、多模态和控制任务，其中视觉感知是理解环境的关键组成部分。</li>
</ul>
</li>
<li><strong>与人类意图的对齐</strong>：<ul>
<li>AI对齐研究关注于引导AI系统朝着人类的预期目标、价值观或道德准则发展。</li>
<li>尽管语言在表达人类意图方面表现出了通用性，但视觉提示（如关键点、边界框和素描）在视觉理解和生成任务中可以更精确和方便地表示人类意图。</li>
<li>构建具备多模态人机交互界面的基础模型是解锁新用例的关键，其中人类意图最好通过视觉表示。</li>
</ul>
</li>
<li><strong>规划、记忆和工具使用</strong>：<ul>
<li>提到了LLM驱动的自主代理系统，其中LLM作为代理的大脑，并辅以规划、记忆和工具使用等关键组件。</li>
<li><strong>规划</strong>：为了在现实世界场景中完成复杂任务，代理需要能够将大型任务分解为更小、更易管理的子目标。理想情况下，AI代理应具备自我改进能力，通过自我评估和内省来学习从错误中吸取教训，并改进后续行动的方法，最终实现更好的结果。</li>
<li><strong>记忆</strong>：短期记忆可以通过上下文学习（或提示工程）实现，而长期记忆则需要模型能够快速检索跨会话的外部知识。</li>
<li><strong>工具使用</strong>：代理需要学习利用外部API来获取基础模型权重中缺失的知识。在处理视觉模态的多种场景时，需要新的处理能力。</li>
</ul>
</li>
<li><strong>研究趋势</strong>：<ul>
<li>作者强调了多模态基础模型领域的快速发展，并指出新的方向和方法不断涌现。尽管有许多重要的研究主题没有在本文中讨论，主要是因为研究创新每天都在更新，但作者对多模态基础模型的未来持乐观态度。</li>
<li>作者相信，通过遵循LLM的道路，可以预见到各个领域的令人兴奋的研究创新和想法在不久的将来成为现实，并且将计算机视觉与更广泛的AI社区联系起来，构建通用目的的AI代理将显著推进人类日常生活。</li>
</ul>
</li>
</ol>
<p>文章强调了多模态基础模型在构建通用AI代理中的重要性，并提出了未来研究的方向，包括提升模型的规划、记忆和工具使用能力，以及如何更好地与人类意图对齐。</p>
</blockquote>
<h2 id="参考文件或链接"><a href="#参考文件或链接" class="headerlink" title="参考文件或链接"></a>参考文件或链接</h2><p>[^1]:<a href="https://arxiv.org/abs/2309.10020">Multimodal Foundation Models: From Specialists to General-Purpose Assistants (arxiv.org)</a><br>[^2]:<a href="https://mp.weixin.qq.com/s/wC4q-GRt8YY4u8-vOl6uMg">多模态大模型最全综述来了！ (qq.com)</a></p>
<p>[^3]:<a href="https://arxiv.org/abs/2108.07258">On the Opportunities and Risks of Foundation Models (arxiv.org)</a></p>
<p>[^4]:<a href="https://github.com/openai/CLIP">openai/CLIP - GitHub</a><br>[^5]:<a href="https://openaccess.thecvf.com/content/CVPR2021/papers/Chen_Exploring_Simple_Siamese_Representation_Learning_CVPR_2021_paper.pdf">Exploring Simple Siamese Representation Learning (thecvf.com)</a><br>[^6]:<a href="https://openaccess.thecvf.com/content/ICCV2021/papers/Caron_Emerging_Properties_in_Self-Supervised_Vision_Transformers_ICCV_2021_paper.pdf">Emerging Properties in Self-Supervised Vision Transformers (thecvf.com)</a><br>[^7]: <a href="https://arxiv.org/pdf/2106.08254.pdf">BEIT: BERT Pre-Training of Image Transformers(arxiv.org)</a><br>[^8]: <a href="https://openaccess.thecvf.com/content/CVPR2022/papers/He_Masked_Autoencoders_Are_Scalable_Vision_Learners_CVPR_2022_paper.pdf">Masked Autoencoders Are Scalable Vision Learners (thecvf.com)</a><br>[^9]: <a href="https://openaccess.thecvf.com/content/CVPR2022/papers/Wei_Masked_Feature_Prediction_for_Self-Supervised_Visual_Pre-Training_CVPR_2022_paper.pdf">Masked Feature Prediction for Self-Supervised Visual Pre-Training (thecvf.com)</a><br>[^10]: <a href="https://openaccess.thecvf.com/content/CVPR2023/papers/Yang_ReCo_Region-Controlled_Text-to-Image_Generation_CVPR_2023_paper.pdf">ReCo: Region-Controlled Text-to-Image Generation (thecvf.com)</a><br>[^11]: <a href="https://arxiv.org/pdf/2208.01626.pdf">Prompt- to-prompt image editing with cross-attention control (arxiv.org)</a><br>[^12]: <a href="https://openaccess.thecvf.com/content/CVPR2023/papers/Ruiz_DreamBooth_Fine_Tuning_Text-to-Image_Diffusion_Models_for_Subject-Driven_Generation_CVPR_2023_paper.pdf">DreamBooth: Fine Tuning Text-to-Image Diffusion Models for Subject-Driven Generation (thecvf.com)</a><br>[^13]: <a href="https://arxiv.org/pdf/2303.08774.pdf">GPT-4 Technical Report (arxiv.org)</a></p>
]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题300道打卡</title>
    <url>//2023/03/29/other-leetcode-%E3%80%902023-03-39-LeetCode-%E5%88%B7%E9%A2%98-300%E9%81%93%E6%89%93%E5%8D%A1%E3%80%91/</url>
    <content><![CDATA[<h2 id="LeetCode-刷题-300-道打卡"><a href="#LeetCode-刷题-300-道打卡" class="headerlink" title="LeetCode 刷题 300 道打卡"></a>LeetCode 刷题 300 道打卡</h2><h3 id="记录一下-LeetCode-刷题-300-道"><a href="#记录一下-LeetCode-刷题-300-道" class="headerlink" title="记录一下 LeetCode 刷题 300 道"></a>记录一下 LeetCode 刷题 300 道</h3><p><a href="https://leetcode.cn/u/david-beckham/">我的 LeetCode 主页</a><br><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/100e2a9f0aac4dad8982e600531a787b.png" alt="300题打卡"></p>
<h3 id="书山有路勤为径，学海无涯苦作舟。诸君共勉之！"><a href="#书山有路勤为径，学海无涯苦作舟。诸君共勉之！" class="headerlink" title="书山有路勤为径，学海无涯苦作舟。诸君共勉之！"></a>书山有路勤为径，学海无涯苦作舟。诸君共勉之！</h3><h3 id="再接再厉吧！"><a href="#再接再厉吧！" class="headerlink" title="再接再厉吧！"></a>再接再厉吧！</h3><blockquote>
<p><strong>时间：2023-03-29</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题400道打卡</title>
    <url>//2024/03/18/other-leetcode-%E3%80%902024-03-18-LeetCode-%E5%88%B7%E9%A2%98-400%E9%81%93%E6%89%93%E5%8D%A1%E3%80%91/</url>
    <content><![CDATA[<h2 id="LeetCode-刷题-400-道打卡"><a href="#LeetCode-刷题-400-道打卡" class="headerlink" title="LeetCode 刷题 400 道打卡"></a>LeetCode 刷题 400 道打卡</h2><h3 id="记录一下-LeetCode-刷题-400-道"><a href="#记录一下-LeetCode-刷题-400-道" class="headerlink" title="记录一下 LeetCode 刷题 400 道"></a>记录一下 LeetCode 刷题 400 道</h3><p><a href="https://leetcode.cn/u/david-beckham/">我的 LeetCode 主页</a>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/david-deng-01/images/blog/202403181348364.png" alt="400题打卡"></p>
<h3 id="书山有路勤为径，学海无涯苦作舟。诸君共勉之！"><a href="#书山有路勤为径，学海无涯苦作舟。诸君共勉之！" class="headerlink" title="书山有路勤为径，学海无涯苦作舟。诸君共勉之！"></a>书山有路勤为径，学海无涯苦作舟。诸君共勉之！</h3><h3 id="再接再厉吧！"><a href="#再接再厉吧！" class="headerlink" title="再接再厉吧！"></a>再接再厉吧！</h3><blockquote>
<p><strong>时间：2024-03-18</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题100道打卡</title>
    <url>//2022/11/09/other-leetcode-%E3%80%902022-11-09-LeetCode-%E5%88%B7%E9%A2%98-100%E9%A2%98%E6%89%93%E5%8D%A1%E3%80%91/</url>
    <content><![CDATA[<h2 id="LeetCode-刷题-100-道打卡"><a href="#LeetCode-刷题-100-道打卡" class="headerlink" title="LeetCode 刷题 100 道打卡"></a>LeetCode 刷题 100 道打卡</h2><h3 id="记录一下-LeetCode-刷题-100-道"><a href="#记录一下-LeetCode-刷题-100-道" class="headerlink" title="记录一下 LeetCode 刷题 100 道"></a>记录一下 LeetCode 刷题 100 道</h3><p><a href="https://leetcode.cn/u/david-beckham/">我的 LeetCode 主页</a><br><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/adbf6937a1a343529329136d5dcdb2c7.png" alt="100题记录"></p>
<h4 id="书山有路勤为径，学海无涯苦作舟。诸君共勉之！"><a href="#书山有路勤为径，学海无涯苦作舟。诸君共勉之！" class="headerlink" title="书山有路勤为径，学海无涯苦作舟。诸君共勉之！"></a>书山有路勤为径，学海无涯苦作舟。诸君共勉之！</h4><h4 id="再接再厉吧！"><a href="#再接再厉吧！" class="headerlink" title="再接再厉吧！"></a>再接再厉吧！</h4><blockquote>
<p><strong>时间：2022-11-09</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>校园网自动登录脚本</title>
    <url>//2023/12/30/%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="校园网自动登录脚本"><a href="#校园网自动登录脚本" class="headerlink" title="校园网自动登录脚本"></a>校园网自动登录脚本</h1><h2 id="1-开发原因"><a href="#1-开发原因" class="headerlink" title="1. 开发原因"></a>1. 开发原因</h2><ol>
<li>组内的服务器联网存在一些问题，总是自动断网</li>
<li>手动联网比较缓慢，而且有时还容易失败</li>
<li>服务器联网对于安装依赖，安装软件等都是非常关键的</li>
</ol>
<h2 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2. 实现方法"></a>2. 实现方法</h2><h3 id="2-1-使用-selenium-模拟登录-2"><a href="#2-1-使用-selenium-模拟登录-2" class="headerlink" title="2.1 使用 selenium 模拟登录^2"></a>2.1 使用 selenium 模拟登录<a href="%5B%E3%80%90python%E3%80%91%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E4%B8%AD%E7%A7%91%E5%A4%A7%E6%A0%A1%E5%9B%AD%E7%BD%91_%E4%B8%AD%E7%A7%91%E5%A4%A7%E7%BB%9F%E4%B8%80%E8%BA%AB%E4%BB%BD%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/qq_39534909/article/details/131523646)">^2</a></h3><blockquote>
<p>这种方法比较简单，而且成功的概率很大，基本就是<code>所见即所得</code>，能够看得到的页面都可以使用这种方法进行模拟登录</p>
<p>优点就是：代码简单，逻辑清晰，所见即所得</p>
<p>缺点就是：需要一些软件的配合，如果网站的页面发生改变需要重新写代码</p>
</blockquote>
<p><strong>参考代码如下</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spider</span>():</span><br><span class="line">    driver = webdriver.Edge()</span><br><span class="line">    driver.get(<span class="string">&#x27;登录的网址&#x27;</span>)  <span class="comment"># 这里输入你的校园网登录网址</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#input_tag = driver.find_element(By.XPATH, &quot;//input[@type=&#x27;text&#x27; and @name=&#x27;username&#x27; and @id=&#x27;username&#x27; and @class=&#x27;from-control&#x27;]&quot;)  # 通过xpath确定账号框位置</span></span><br><span class="line">    input_tag = driver.find_element(By.XPATH, <span class="string">&quot;//input[ @type=&#x27;text&#x27; and @name=&#x27;username&#x27; and @id=&#x27;username&#x27; and @id=&#x27;username&#x27;]&quot;</span>)</span><br><span class="line">    input_tag.send_keys(<span class="string">&quot;你自己的账户&quot;</span>)  <span class="comment"># 输入账号</span></span><br><span class="line">    input_tag2 = driver.find_element(By.XPATH, <span class="string">&quot;//input[ @type=&#x27;password&#x27; and @name=&#x27;password&#x27; and  @id=&#x27;password&#x27;]&quot;</span>)  <span class="comment"># 通过xpath确定密码框位置</span></span><br><span class="line">    input_tag2.send_keys(<span class="string">&quot;你自己的密码&quot;</span>)  <span class="comment"># 输入密码</span></span><br><span class="line">    input_tag2.send_keys(Keys.ENTER)  <span class="comment"># 敲一下回车</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    input_tag3 = driver.find_element(By.XPATH, <span class="string">&quot;//button[@class=&#x27;btn btn-block btn-primary&#x27; and @id=&#x27;login&#x27; and @type=&#x27;button&#x27;]&quot;</span>)  <span class="comment"># 找到开通网络按钮</span></span><br><span class="line">    input_tag3.send_keys(Keys.ENTER)  <span class="comment"># 敲一下回车</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)  <span class="comment"># 1秒后自动关闭浏览器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试网络是否连通</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Ping</span>():</span><br><span class="line">    backinfo = subprocess.call(<span class="string">&#x27;ping www.zhihu.com -n 1&#x27;</span>, shell=<span class="literal">True</span>, stdin=subprocess.PIPE, stdout=subprocess.PIPE,</span><br><span class="line">                               stderr=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">if</span> backinfo:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;网络未连接&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;有网&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    spider()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;连接网络中·····&quot;</span>)</span><br><span class="line">    connection = Ping()</span><br><span class="line">    <span class="keyword">if</span> connection == <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ping&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> connection == <span class="number">1</span>:</span><br><span class="line">        spider()</span><br><span class="line">    exit()</span><br></pre></td></tr></table></figure>



<h3 id="2-2-使用-requests-请求登录接口-1"><a href="#2-2-使用-requests-请求登录接口-1" class="headerlink" title="2.2 使用 requests 请求登录接口^1"></a>2.2 使用 requests 请求登录接口<a href="%5B%E3%80%90python%E3%80%91%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E4%B8%AD%E7%A7%91%E5%A4%A7%E6%A0%A1%E5%9B%AD%E7%BD%91_%E4%B8%AD%E7%A7%91%E5%A4%A7%E7%BB%9F%E4%B8%80%E8%BA%AB%E4%BB%BD%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/qq_39534909/article/details/131523646)">^1</a></h3><blockquote>
<p>这种方法比较困难，而且成功的概率不大，需要一些技术手段找到网站后端的接口，然后破解后端的加密方法才能使用</p>
<p>优点就是：不需要其他软件的配合，执行速度快，执行效率高，不依赖网站的界面，网站界面修改后还能使用</p>
<p>缺点就是：需要一些JavaScript相关的知识，找到后端的接口，破解后端的加密方法，代码复杂，逻辑复杂</p>
</blockquote>
<p><strong>参考代码如下</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*-coding: Utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Packages: auto_srun-master</span></span><br><span class="line"><span class="comment"># @File : AutoLogin.py</span></span><br><span class="line"><span class="comment"># @Author: David</span></span><br><span class="line"><span class="comment"># @Date: 2023/12/30 15:07</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> logging <span class="keyword">import</span> Logger</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_logger</span>(<span class="params">is_log_to_file=<span class="literal">False</span></span>) -&gt; Logger:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取日志输出对象</span></span><br><span class="line"><span class="string">    :param is_log_to_file: 是否输出到日志文件中</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1、创建一个logger</span></span><br><span class="line">    log_obj = logging.getLogger(__name__)</span><br><span class="line">    log_obj.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2、定义handler的输出格式（formatter）</span></span><br><span class="line">    formatter = logging.Formatter(<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 创建一个handler，用于输出到控制台</span></span><br><span class="line">    ch = logging.StreamHandler()</span><br><span class="line">    ch.setLevel(logging.INFO)  <span class="comment"># 设置日志输出的等级</span></span><br><span class="line">    ch.setFormatter(formatter)  <span class="comment"># 设置日志输出格式</span></span><br><span class="line">    log_obj.addHandler(ch)  <span class="comment"># 将 handler 添加到 log_obj 中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> is_log_to_file:</span><br><span class="line">        <span class="comment"># 4. 创建一个handler，用于写入日志文件</span></span><br><span class="line">        fh = logging.FileHandler(<span class="string">&#x27;auto_login.log&#x27;</span>)</span><br><span class="line">        fh.setLevel(logging.DEBUG)  <span class="comment"># 设置日志输出的等级</span></span><br><span class="line">        fh.setFormatter(formatter)  <span class="comment"># 设置日志输出格式</span></span><br><span class="line">        log_obj.addHandler(fh)  <span class="comment"># 将 handler 添加到 log_obj 中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> log_obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logger_message</span>(<span class="params">message_key: <span class="built_in">str</span>, message_value: <span class="built_in">object</span>, level: <span class="built_in">str</span> = <span class="string">&#x27;info&#x27;</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    输出日志</span></span><br><span class="line"><span class="string">    :param message_key:</span></span><br><span class="line"><span class="string">    :param message_value:</span></span><br><span class="line"><span class="string">    :param level:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    message = <span class="string">f&quot;<span class="subst">&#123;message_key&#125;</span> &gt;&gt; <span class="subst">&#123;message_value&#125;</span>\n&quot;</span></span><br><span class="line">    <span class="keyword">if</span> level == <span class="string">&#x27;info&#x27;</span>:</span><br><span class="line">        logger.info(message)</span><br><span class="line">    <span class="keyword">elif</span> level == <span class="string">&#x27;debug&#x27;</span>:</span><br><span class="line">        logger.info(message)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logger.critical(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_byte</span>(<span class="params">s: <span class="built_in">str</span>, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    x = <span class="built_in">ord</span>(s[i])</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">255</span>:</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_base64</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    base64 编码器</span></span><br><span class="line"><span class="string">    :param s:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    pad_char = <span class="string">&quot;=&quot;</span></span><br><span class="line">    alpha = <span class="string">&quot;LVoJPiCN2R8G90yg+hmFHuacZ1OWMnrsSTXkYpUq/3dlbfKwv6xztjI7DeBE45QA&quot;</span></span><br><span class="line">    res = []</span><br><span class="line">    imax = <span class="built_in">len</span>(s) - <span class="built_in">len</span>(s) % <span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, imax, <span class="number">3</span>):</span><br><span class="line">        b10 = (get_byte(s, i) &lt;&lt; <span class="number">16</span>) | (get_byte(s, i + <span class="number">1</span>) &lt;&lt; <span class="number">8</span>) | get_byte(s, i + <span class="number">2</span>)</span><br><span class="line">        res.append(alpha[(b10 &gt;&gt; <span class="number">18</span>)])</span><br><span class="line">        res.append(alpha[((b10 &gt;&gt; <span class="number">12</span>) &amp; <span class="number">63</span>)])</span><br><span class="line">        res.append(alpha[((b10 &gt;&gt; <span class="number">6</span>) &amp; <span class="number">63</span>)])</span><br><span class="line">        res.append(alpha[(b10 &amp; <span class="number">63</span>)])</span><br><span class="line">    i = imax</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) - imax == <span class="number">1</span>:</span><br><span class="line">        b10 = get_byte(s, i) &lt;&lt; <span class="number">16</span></span><br><span class="line">        res.append(alpha[(b10 &gt;&gt; <span class="number">18</span>)] + alpha[((b10 &gt;&gt; <span class="number">12</span>) &amp; <span class="number">63</span>)] + pad_char + pad_char)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        b10 = (get_byte(s, i) &lt;&lt; <span class="number">16</span>) | (get_byte(s, i + <span class="number">1</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">        res.append(alpha[(b10 &gt;&gt; <span class="number">18</span>)] + alpha[((b10 &gt;&gt; <span class="number">12</span>) &amp; <span class="number">63</span>)] + alpha[((b10 &gt;&gt; <span class="number">6</span>) &amp; <span class="number">63</span>)] + pad_char)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_md5</span>(<span class="params">password: <span class="built_in">str</span>, token: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    md5 编码器</span></span><br><span class="line"><span class="string">    :param password:</span></span><br><span class="line"><span class="string">    :param token:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> hmac.new(token.encode(), password.encode(), hashlib.md5).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sha1</span>(<span class="params">value: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    sha1 编码器</span></span><br><span class="line"><span class="string">    :param value:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.sha1(value.encode()).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">force</span>(<span class="params">msg</span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> msg:</span><br><span class="line">        ret.append(<span class="built_in">ord</span>(w))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ordat</span>(<span class="params">msg: <span class="type">List</span>[<span class="built_in">str</span>], idx: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(msg) &gt; idx:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ord</span>(msg[idx])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str_encode</span>(<span class="params">msg, key: <span class="built_in">bool</span></span>) -&gt; <span class="built_in">list</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    编码器</span></span><br><span class="line"><span class="string">    :param msg:</span></span><br><span class="line"><span class="string">    :param key:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    length = <span class="built_in">len</span>(msg)</span><br><span class="line">    pwd = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, length, <span class="number">4</span>):</span><br><span class="line">        pwd.append(</span><br><span class="line">            ordat(msg, i) | ordat(msg, i + <span class="number">1</span>) &lt;&lt; <span class="number">8</span> | ordat(msg, i + <span class="number">2</span>) &lt;&lt; <span class="number">16</span></span><br><span class="line">            | ordat(msg, i + <span class="number">3</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">    <span class="keyword">if</span> key:</span><br><span class="line">        pwd.append(length)</span><br><span class="line">    <span class="keyword">return</span> pwd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lencode</span>(<span class="params">msg, key: <span class="built_in">bool</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    编码器</span></span><br><span class="line"><span class="string">    :param msg:</span></span><br><span class="line"><span class="string">    :param key:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    length = <span class="built_in">len</span>(msg)</span><br><span class="line">    ll = (length - <span class="number">1</span>) &lt;&lt; <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> key:</span><br><span class="line">        m = msg[length - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> m &lt; ll - <span class="number">3</span> <span class="keyword">or</span> m &gt; ll:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        ll = m</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, length):</span><br><span class="line">        msg[i] = <span class="built_in">chr</span>(msg[i] &amp; <span class="number">0xff</span>) + <span class="built_in">chr</span>(msg[i] &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>) + <span class="built_in">chr</span>(</span><br><span class="line">            msg[i] &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span>) + <span class="built_in">chr</span>(msg[i] &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>)</span><br><span class="line">    <span class="keyword">if</span> key:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(msg)[<span class="number">0</span>:ll]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_x_encode</span>(<span class="params">msg: <span class="built_in">str</span>, key: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    自定义编码器</span></span><br><span class="line"><span class="string">    :param msg:</span></span><br><span class="line"><span class="string">    :param key:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    pwd = str_encode(msg, <span class="literal">True</span>)</span><br><span class="line">    pwdk = str_encode(key, <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pwdk) &lt; <span class="number">4</span>:</span><br><span class="line">        pwdk = pwdk + [<span class="number">0</span>] * (<span class="number">4</span> - <span class="built_in">len</span>(pwdk))</span><br><span class="line">    n = <span class="built_in">len</span>(pwd) - <span class="number">1</span></span><br><span class="line">    z = pwd[n]</span><br><span class="line">    c = <span class="number">0x86014019</span> | <span class="number">0x183639A0</span></span><br><span class="line">    q = math.floor(<span class="number">6</span> + <span class="number">52</span> / (n + <span class="number">1</span>))</span><br><span class="line">    d = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">0</span> &lt; q:</span><br><span class="line">        d = d + c &amp; (<span class="number">0x8CE0D9BF</span> | <span class="number">0x731F2640</span>)</span><br><span class="line">        e = d &gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span></span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p &lt; n:</span><br><span class="line">            y = pwd[p + <span class="number">1</span>]</span><br><span class="line">            m = z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span></span><br><span class="line">            m = m + ((y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (d ^ y))</span><br><span class="line">            m = m + (pwdk[(p &amp; <span class="number">3</span>) ^ e] ^ z)</span><br><span class="line">            pwd[p] = pwd[p] + m &amp; (<span class="number">0xEFB8D130</span> | <span class="number">0x10472ECF</span>)</span><br><span class="line">            z = pwd[p]</span><br><span class="line">            p = p + <span class="number">1</span></span><br><span class="line">        y = pwd[<span class="number">0</span>]</span><br><span class="line">        m = z &gt;&gt; <span class="number">5</span> ^ y &lt;&lt; <span class="number">2</span></span><br><span class="line">        m = m + ((y &gt;&gt; <span class="number">3</span> ^ z &lt;&lt; <span class="number">4</span>) ^ (d ^ y))</span><br><span class="line">        m = m + (pwdk[(p &amp; <span class="number">3</span>) ^ e] ^ z)</span><br><span class="line">        pwd[n] = pwd[n] + m &amp; (<span class="number">0xBB390742</span> | <span class="number">0x44C6F8BD</span>)</span><br><span class="line">        z = pwd[n]</span><br><span class="line">        q = q - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> lencode(pwd, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_check_sum</span>(<span class="params">token: <span class="built_in">str</span>, username: <span class="built_in">str</span>, hmd5: <span class="built_in">str</span>, ac_id: <span class="built_in">str</span>, ip: <span class="built_in">str</span>, n: <span class="built_in">str</span>, type_str: <span class="built_in">str</span>, info: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取校验str</span></span><br><span class="line"><span class="string">    :param token:</span></span><br><span class="line"><span class="string">    :param username:</span></span><br><span class="line"><span class="string">    :param hmd5:</span></span><br><span class="line"><span class="string">    :param ac_id:</span></span><br><span class="line"><span class="string">    :param ip:</span></span><br><span class="line"><span class="string">    :param n:</span></span><br><span class="line"><span class="string">    :param type_str:</span></span><br><span class="line"><span class="string">    :param info:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    check_str = <span class="string">f&quot;<span class="subst">&#123;token&#125;</span><span class="subst">&#123;username&#125;</span><span class="subst">&#123;token&#125;</span><span class="subst">&#123;hmd5&#125;</span><span class="subst">&#123;token&#125;</span><span class="subst">&#123;ac_id&#125;</span><span class="subst">&#123;token&#125;</span><span class="subst">&#123;ip&#125;</span><span class="subst">&#123;token&#125;</span><span class="subst">&#123;n&#125;</span><span class="subst">&#123;token&#125;</span><span class="subst">&#123;type_str&#125;</span><span class="subst">&#123;token&#125;</span><span class="subst">&#123;info&#125;</span>&quot;</span></span><br><span class="line">    logger_message(message_key=<span class="string">&quot;check str&quot;</span>, message_value=check_str, level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> check_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_info</span>(<span class="params">username: <span class="built_in">str</span>, password: <span class="built_in">str</span>, ip: <span class="built_in">str</span>, ac_id: <span class="built_in">str</span>, enc: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取 info</span></span><br><span class="line"><span class="string">    :param username:</span></span><br><span class="line"><span class="string">    :param password:</span></span><br><span class="line"><span class="string">    :param ip:</span></span><br><span class="line"><span class="string">    :param ac_id:</span></span><br><span class="line"><span class="string">    :param enc:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    info_temp = &#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>: password,</span><br><span class="line">        <span class="string">&quot;ip&quot;</span>: ip,</span><br><span class="line">        <span class="string">&quot;acid&quot;</span>: ac_id,</span><br><span class="line">        <span class="string">&quot;enc_ver&quot;</span>: enc</span><br><span class="line">    &#125;</span><br><span class="line">    info = re.sub(<span class="string">&quot;&#x27;&quot;</span>, <span class="string">&#x27;&quot;&#x27;</span>, <span class="built_in">str</span>(info_temp))</span><br><span class="line">    info = re.sub(<span class="string">&quot; &quot;</span>, <span class="string">&#x27;&#x27;</span>, info)</span><br><span class="line">    logger_message(message_key=<span class="string">&quot;info&quot;</span>, message_value=info, level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_get_ip</span>(<span class="params">base_url: <span class="built_in">str</span>, headers: <span class="built_in">dict</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取 ip</span></span><br><span class="line"><span class="string">    :param base_url:</span></span><br><span class="line"><span class="string">    :param headers:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    init_res = requests.get(base_url, headers=headers)</span><br><span class="line">    ip = re.search(<span class="string">&#x27;id=&quot;user_ip&quot; value=&quot;(.*?)&quot;&#x27;</span>, init_res.text).group(<span class="number">1</span>)</span><br><span class="line">    logger_message(message_key=<span class="string">&quot;ip&quot;</span>, message_value=ip, level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_token</span>(<span class="params">username: <span class="built_in">str</span>, ip: <span class="built_in">str</span>, get_challenge_url: <span class="built_in">str</span>, headers: <span class="built_in">dict</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    get_challenge_params = &#123;</span><br><span class="line">        <span class="string">&quot;callback&quot;</span>: <span class="string">&quot;jQuery112404953340710317169_&quot;</span> + <span class="built_in">str</span>(<span class="built_in">int</span>(time.time() * <span class="number">1000</span>)),</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">        <span class="string">&quot;ip&quot;</span>: ip,</span><br><span class="line">        <span class="string">&quot;_&quot;</span>: <span class="built_in">int</span>(time.time() * <span class="number">1000</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    get_challenge_res = requests.get(get_challenge_url, params=get_challenge_params, headers=headers)</span><br><span class="line">    token = re.search(<span class="string">&#x27;&quot;challenge&quot;:&quot;(.*?)&quot;&#x27;</span>, get_challenge_res.text).group(<span class="number">1</span>)</span><br><span class="line">    logger_message(message_key=<span class="string">&quot;params&quot;</span>, message_value=get_challenge_params, level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">    logger_message(message_key=<span class="string">&quot;token&quot;</span>, message_value=token, level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_login</span>(<span class="params"></span></span><br><span class="line"><span class="params">        username: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        hmd5: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        ac_id: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        ip: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        check_sum: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        info: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        n: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        type_str: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        srun_portal_url: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        headers: <span class="built_in">dict</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    srun_portal_params = &#123;</span><br><span class="line">        <span class="string">&#x27;callback&#x27;</span>: <span class="string">&#x27;jQuery11240645308969735664_&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">int</span>(time.time() * <span class="number">1000</span>)),</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: <span class="string">&#x27;login&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>: username,</span><br><span class="line">        <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;&#123;MD5&#125;&#x27;</span> + hmd5,</span><br><span class="line">        <span class="string">&#x27;ac_id&#x27;</span>: ac_id,</span><br><span class="line">        <span class="string">&#x27;ip&#x27;</span>: ip,</span><br><span class="line">        <span class="string">&#x27;chksum&#x27;</span>: check_sum,</span><br><span class="line">        <span class="string">&#x27;info&#x27;</span>: info,</span><br><span class="line">        <span class="string">&#x27;n&#x27;</span>: n,</span><br><span class="line">        <span class="string">&#x27;type&#x27;</span>: type_str,</span><br><span class="line">        <span class="string">&#x27;os&#x27;</span>: <span class="string">&#x27;Windows 10&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Windows&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;double_stack&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;_&#x27;</span>: <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    srun_portal_res = requests.get(srun_portal_url, params=srun_portal_params, headers=headers)</span><br><span class="line">    logger_message(message_key=<span class="string">&quot;params&quot;</span>, message_value=srun_portal_params, level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">    logger_message(message_key=<span class="string">&quot;response&quot;</span>, message_value=srun_portal_res.text, level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> srun_portal_res.text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">config: <span class="built_in">dict</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    主程序</span></span><br><span class="line"><span class="string">    :param config: 配置文件</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ip = init_get_ip(base_url=config[<span class="string">&#x27;base_url&#x27;</span>], headers=config[<span class="string">&#x27;headers&#x27;</span>])</span><br><span class="line">    token = get_token(</span><br><span class="line">        username=config[<span class="string">&#x27;username&#x27;</span>],</span><br><span class="line">        ip=ip,</span><br><span class="line">        get_challenge_url=config[<span class="string">&quot;get_challenge_url&quot;</span>],</span><br><span class="line">        headers=config[<span class="string">&#x27;headers&#x27;</span>]</span><br><span class="line">    )</span><br><span class="line">    info = get_info(</span><br><span class="line">        username=config[<span class="string">&#x27;username&#x27;</span>],</span><br><span class="line">        password=config[<span class="string">&#x27;password&#x27;</span>],</span><br><span class="line">        ip=ip,</span><br><span class="line">        ac_id=config[<span class="string">&quot;ac_id&quot;</span>],</span><br><span class="line">        enc=config[<span class="string">&quot;enc&quot;</span>]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    info = <span class="string">&quot;&#123;SRBX1&#125;&quot;</span> + get_base64(s=get_x_encode(msg=info, key=token))</span><br><span class="line">    hmd5 = get_md5(password=config[<span class="string">&#x27;password&#x27;</span>], token=token)</span><br><span class="line"></span><br><span class="line">    check_sum = get_check_sum(</span><br><span class="line">        token=token,</span><br><span class="line">        username=config[<span class="string">&#x27;username&#x27;</span>],</span><br><span class="line">        hmd5=hmd5,</span><br><span class="line">        ac_id=config[<span class="string">&quot;ac_id&quot;</span>],</span><br><span class="line">        ip=ip,</span><br><span class="line">        n=config[<span class="string">&quot;n&quot;</span>],</span><br><span class="line">        type_str=config[<span class="string">&quot;type&quot;</span>],</span><br><span class="line">        info=info</span><br><span class="line">    )</span><br><span class="line">    check_sum = get_sha1(check_sum)</span><br><span class="line"></span><br><span class="line">    do_login(</span><br><span class="line">        username=config[<span class="string">&#x27;username&#x27;</span>],</span><br><span class="line">        hmd5=hmd5,</span><br><span class="line">        ac_id=config[<span class="string">&quot;ac_id&quot;</span>],</span><br><span class="line">        ip=ip,</span><br><span class="line">        check_sum=check_sum,</span><br><span class="line">        info=info,</span><br><span class="line">        n=config[<span class="string">&quot;n&quot;</span>],</span><br><span class="line">        type_str=config[<span class="string">&quot;type&quot;</span>],</span><br><span class="line">        srun_portal_url=config[<span class="string">&quot;srun_portal_url&quot;</span>],</span><br><span class="line">        headers=config[<span class="string">&#x27;headers&#x27;</span>]</span><br><span class="line">    )</span><br><span class="line">    res = requests.get(config[<span class="string">&quot;get_info_url&quot;</span>], headers=config[<span class="string">&#x27;headers&#x27;</span>])</span><br><span class="line">    logger_message(message_key=<span class="string">&quot;response&quot;</span>, message_value=res.text, level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_config</span>() -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取全局配置文件</span></span><br><span class="line"><span class="string">    :return: 配置文件</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    config = &#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;你的校园网账号&quot;</span>,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>: <span class="string">&quot;你的校园网密码&quot;</span>,</span><br><span class="line">        <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.26 Safari/537.36&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment"># &quot;base_url&quot;: &quot;http://192.168.0.1/cgi-bin&quot;,</span></span><br><span class="line">        <span class="string">&quot;base_url&quot;</span>: <span class="string">&quot;校园网的基础地址，参考上面的链接&quot;</span>,</span><br><span class="line">        <span class="string">&quot;n&quot;</span>: <span class="string">&quot;200&quot;</span>,</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ac_id&quot;</span>: <span class="string">&quot;4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;enc&quot;</span>: <span class="string">&quot;srun_bx1&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    config[<span class="string">&quot;get_challenge_url&quot;</span>] = <span class="string">f&quot;<span class="subst">&#123;config[<span class="string">&#x27;base_url&#x27;</span>]&#125;</span>/get_challenge&quot;</span></span><br><span class="line">    config[<span class="string">&quot;srun_portal_url&quot;</span>] = <span class="string">f&quot;<span class="subst">&#123;config[<span class="string">&#x27;base_url&#x27;</span>]&#125;</span>/srun_portal&quot;</span></span><br><span class="line">    get_info_url = <span class="string">f&quot;<span class="subst">&#123;config[<span class="string">&#x27;base_url&#x27;</span>]&#125;</span>/rad_user_info?callback=jQuery112406118340540763985_1556004912581&amp;_=1556004912582&quot;</span></span><br><span class="line">    config[<span class="string">&quot;get_info_url&quot;</span>] = get_info_url</span><br><span class="line">    logger_message(message_key=<span class="string">&quot;config&quot;</span>, message_value=config, level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    logger = get_logger()</span><br><span class="line">    cfg = get_config()</span><br><span class="line">    main(config=cfg)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用-requests-方式代码解析"><a href="#使用-requests-方式代码解析" class="headerlink" title="使用 requests 方式代码解析"></a>使用 requests 方式代码解析</h2><blockquote>
<p>本文借鉴了 <code>校园网自动登录Python版</code> <a href="%5B%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95Python%E7%89%88_%E6%B7%B1%E6%BE%9C%E8%BD%AF%E4%BB%B6%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/qq_20534023/article/details/124159181)">^1</a>博主的思路，基于该博主的代码进行了改进，博主的源码路径：<a href="https://gitee.com/yshbcom/auto_srun">Gitee</a></p>
</blockquote>
<blockquote>
<p>首先，获取初始化的 <code>ip</code> 这是你在局域网中的<code>ip</code>地址，该地址隐藏在登录的界面中，具体的情况需要具体的分析。获取<code>ip</code>的代码如下：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_get_ip</span>(<span class="params">base_url: <span class="built_in">str</span>, headers: <span class="built_in">dict</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取 ip</span></span><br><span class="line"><span class="string">    :param base_url:</span></span><br><span class="line"><span class="string">    :param headers:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    init_res = requests.get(base_url, headers=headers)</span><br><span class="line">    ip = re.search(<span class="string">&#x27;id=&quot;user_ip&quot; value=&quot;(.*?)&quot;&#x27;</span>, init_res.text).group(<span class="number">1</span>)</span><br><span class="line">    logger_message(message_key=<span class="string">&quot;ip&quot;</span>, message_value=ip, level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> ip</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其次，获得登录时需要的<code>token</code>令牌，获取令牌时需要上一步获取到的<code>ip</code>才行，这是你登录时候的验证令牌，获取登录令牌的代码如下：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_token</span>(<span class="params">username: <span class="built_in">str</span>, ip: <span class="built_in">str</span>, get_challenge_url: <span class="built_in">str</span>, headers: <span class="built_in">dict</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    get_challenge_params = &#123;</span><br><span class="line">        <span class="string">&quot;callback&quot;</span>: <span class="string">&quot;jQuery112404953340710317169_&quot;</span> + <span class="built_in">str</span>(<span class="built_in">int</span>(time.time() * <span class="number">1000</span>)),</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">        <span class="string">&quot;ip&quot;</span>: ip,</span><br><span class="line">        <span class="string">&quot;_&quot;</span>: <span class="built_in">int</span>(time.time() * <span class="number">1000</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    get_challenge_res = requests.get(get_challenge_url, params=get_challenge_params, headers=headers)</span><br><span class="line">    token = re.search(<span class="string">&#x27;&quot;challenge&quot;:&quot;(.*?)&quot;&#x27;</span>, get_challenge_res.text).group(<span class="number">1</span>)</span><br><span class="line">    logger_message(message_key=<span class="string">&quot;params&quot;</span>, message_value=get_challenge_params, level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">    logger_message(message_key=<span class="string">&quot;token&quot;</span>, message_value=token, level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> token</span><br></pre></td></tr></table></figure>

<blockquote>
<p>之后，需要获取你的登录信息，通过<code>username</code>，<code>password</code>，<code>ip</code>获取认证信息，获取认证信息的代码如下：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_info</span>(<span class="params">username: <span class="built_in">str</span>, password: <span class="built_in">str</span>, ip: <span class="built_in">str</span>, ac_id: <span class="built_in">str</span>, enc: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取 info</span></span><br><span class="line"><span class="string">    :param username:</span></span><br><span class="line"><span class="string">    :param password:</span></span><br><span class="line"><span class="string">    :param ip:</span></span><br><span class="line"><span class="string">    :param ac_id:</span></span><br><span class="line"><span class="string">    :param enc:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    info_temp = &#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>: password,</span><br><span class="line">        <span class="string">&quot;ip&quot;</span>: ip,</span><br><span class="line">        <span class="string">&quot;acid&quot;</span>: ac_id,</span><br><span class="line">        <span class="string">&quot;enc_ver&quot;</span>: enc</span><br><span class="line">    &#125;</span><br><span class="line">    info = re.sub(<span class="string">&quot;&#x27;&quot;</span>, <span class="string">&#x27;&quot;&#x27;</span>, <span class="built_in">str</span>(info_temp))</span><br><span class="line">    info = re.sub(<span class="string">&quot; &quot;</span>, <span class="string">&#x27;&#x27;</span>, info)</span><br><span class="line">    logger_message(message_key=<span class="string">&quot;info&quot;</span>, message_value=info, level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> info</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>之后，获取登录时的校验和，校验和使用sha1算法加密，获取校验和的代码如下：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_check_sum</span>(<span class="params">token: <span class="built_in">str</span>, username: <span class="built_in">str</span>, hmd5: <span class="built_in">str</span>, ac_id: <span class="built_in">str</span>, ip: <span class="built_in">str</span>, n: <span class="built_in">str</span>, type_str: <span class="built_in">str</span>, info: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取校验str</span></span><br><span class="line"><span class="string">    :param token:</span></span><br><span class="line"><span class="string">    :param username:</span></span><br><span class="line"><span class="string">    :param hmd5:</span></span><br><span class="line"><span class="string">    :param ac_id:</span></span><br><span class="line"><span class="string">    :param ip:</span></span><br><span class="line"><span class="string">    :param n:</span></span><br><span class="line"><span class="string">    :param type_str:</span></span><br><span class="line"><span class="string">    :param info:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    check_str = <span class="string">f&quot;<span class="subst">&#123;token&#125;</span><span class="subst">&#123;username&#125;</span><span class="subst">&#123;token&#125;</span><span class="subst">&#123;hmd5&#125;</span><span class="subst">&#123;token&#125;</span><span class="subst">&#123;ac_id&#125;</span><span class="subst">&#123;token&#125;</span><span class="subst">&#123;ip&#125;</span><span class="subst">&#123;token&#125;</span><span class="subst">&#123;n&#125;</span><span class="subst">&#123;token&#125;</span><span class="subst">&#123;type_str&#125;</span><span class="subst">&#123;token&#125;</span><span class="subst">&#123;info&#125;</span>&quot;</span></span><br><span class="line">    logger_message(message_key=<span class="string">&quot;check str&quot;</span>, message_value=check_str, level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> check_str</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 最后，将上述所有的信息统一放入登录接口的参数中，即可完成登录的联网的功能，具体登录的方法代码如下：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">do_login</span>(<span class="params"></span></span><br><span class="line"><span class="params">        username: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        hmd5: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        ac_id: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        ip: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        check_sum: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        info: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        n: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        type_str: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        srun_portal_url: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        headers: <span class="built_in">dict</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    srun_portal_params = &#123;</span><br><span class="line">        <span class="string">&#x27;callback&#x27;</span>: <span class="string">&#x27;jQuery11240645308969735664_&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">int</span>(time.time() * <span class="number">1000</span>)),</span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>: <span class="string">&#x27;login&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>: username,</span><br><span class="line">        <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;&#123;MD5&#125;&#x27;</span> + hmd5,</span><br><span class="line">        <span class="string">&#x27;ac_id&#x27;</span>: ac_id,</span><br><span class="line">        <span class="string">&#x27;ip&#x27;</span>: ip,</span><br><span class="line">        <span class="string">&#x27;chksum&#x27;</span>: check_sum,</span><br><span class="line">        <span class="string">&#x27;info&#x27;</span>: info,</span><br><span class="line">        <span class="string">&#x27;n&#x27;</span>: n,</span><br><span class="line">        <span class="string">&#x27;type&#x27;</span>: type_str,</span><br><span class="line">        <span class="string">&#x27;os&#x27;</span>: <span class="string">&#x27;Windows 10&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Windows&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;double_stack&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;_&#x27;</span>: <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    srun_portal_res = requests.get(srun_portal_url, params=srun_portal_params, headers=headers)</span><br><span class="line">    logger_message(message_key=<span class="string">&quot;params&quot;</span>, message_value=srun_portal_params, level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">    logger_message(message_key=<span class="string">&quot;response&quot;</span>, message_value=srun_portal_res.text, level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> srun_portal_res.text</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：使用 <code>requests </code>方式需要清楚的了解后端的接口参数，已经参数使用何种方式进行加密，这需要一定的<code>JavaScript</code>能力，所以相比于使用 <code>selenium </code>方法更加的复杂，逻辑也更加的复杂。但是使用 <code>requests </code>代码的效率更高，对于网站的界面没有依赖，所以网站界面修改后也可以使用，泛化能力较强。</p>
</blockquote>
<h2 id="3-参考链接"><a href="#3-参考链接" class="headerlink" title="3. 参考链接"></a>3. 参考链接</h2>]]></content>
      <categories>
        <category>spider</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>spider</tag>
      </tags>
  </entry>
  <entry>
    <title>Pycharm解决启动时候索引慢的问题</title>
    <url>//2023/10/11/other-%E8%BD%AC%E8%BD%BD-cndn-Pycharm%E8%A7%A3%E5%86%B3%E5%90%AF%E5%8A%A8%E6%97%B6%E5%80%99%E7%B4%A2%E5%BC%95%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>设置里去掉update里面的两个勾<br><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/313169ca1076412b876ad9a06db27ea6.png" alt="在这里插入图片描述"><br>shared indexes中，把自动下载索引改成不下载使用本地索引</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/2ffc3c8ad38c472abf5a0c314693f268.png" alt="在这里插入图片描述"></p>
<p>本文转自 <a href="https://blog.csdn.net/weixin_43941438/article/details/132240663">https://blog.csdn.net/weixin_43941438/article/details/132240663</a>，如有侵权，请联系删除。</p>
]]></content>
      <categories>
        <category>转载</category>
        <category>csdn</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>csdn</tag>
      </tags>
  </entry>
  <entry>
    <title>问题笔记</title>
    <url>//2023/10/11/other-%E9%9A%8F%E7%AC%94-%E9%97%AE%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="遇到的问题-amp-解决方案【持续更新-】"><a href="#遇到的问题-amp-解决方案【持续更新-】" class="headerlink" title="遇到的问题&amp;解决方案【持续更新~】"></a>遇到的问题&amp;解决方案【持续更新~】</h1><h2 id="2023-09-16-笔记"><a href="#2023-09-16-笔记" class="headerlink" title="2023-09-16 笔记"></a>2023-09-16 笔记</h2><h3 id="解决-MP4-视频转成-m3u8-格式的问题"><a href="#解决-MP4-视频转成-m3u8-格式的问题" class="headerlink" title="解决 MP4 视频转成 m3u8 格式的问题"></a>解决 MP4 视频转成 m3u8 格式的问题</h3><ol>
<li><p>需求描述：</p>
<p>现在需要批量将一些存放在文件夹下的 MP4 视频转成 m3u8 格式，其中视频存放的位置可能是多层文件夹下，m3u8 视频需要分门别类的存放</p>
</li>
<li><p>解决思路</p>
<ol>
<li>使用 <code>Python</code> + <code>ffmpeg</code> 实现视频的转码</li>
<li>使用多线程加速视频的转码</li>
</ol>
</li>
<li><p>遇到的问题</p>
<ol>
<li>多个视频不能按照预设的顺序进行转码，前一个视频还没有完成，下一个视频就中断了前一个视频的转码</li>
<li>本机的性能不足，需要放在服务器上运行，但是服务器上的<code>Linux</code>环境导致运行出现一些没有预测到的问题</li>
</ol>
</li>
<li><p>最终解决方案</p>
<ol>
<li>不使用多线程运行</li>
<li>使用<code>Python</code> 创建好输出的路径以及视频转码的命令</li>
<li>手动输入转码的命令，顺序进行视频转码</li>
</ol>
</li>
<li><p>最终的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*-coding: Utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Project Name: GithubCopilot试用</span></span><br><span class="line"><span class="comment"># @File: mp4转m3u8.py</span></span><br><span class="line"><span class="comment"># @Author: David</span></span><br><span class="line"><span class="comment"># @Date：2023/9/11 21:34</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> argparse <span class="keyword">import</span> ArgumentParser, Namespace</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> pool</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">Tuple</span>, <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># from ffmpeg import _ffmpeg as ffmpeg</span></span><br><span class="line"><span class="keyword">import</span> hydra</span><br><span class="line"><span class="keyword">from</span> omegaconf <span class="keyword">import</span> DictConfig, OmegaConf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_file_path_list</span>(<span class="params">input_dir: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        获取文件目录下的所有 mp4 文件</span></span><br><span class="line"><span class="string">        :param input_dir: 输入目录</span></span><br><span class="line"><span class="string">        :return: 输入目录中所有 mp4 文件的路径</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result: <span class="type">List</span>[<span class="built_in">str</span>] = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> os.listdir(input_dir):</span><br><span class="line">        path = os.path.join(input_dir, path)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(path):</span><br><span class="line">            result.extend(get_file_path_list(path))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> path.split(<span class="string">&#x27;.&#x27;</span>)[-<span class="number">1</span>].lower() == <span class="string">&#x27;mp4&#x27;</span>:</span><br><span class="line">                result.append(path)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_file</span>(<span class="params">mp4_file: <span class="built_in">str</span>, m3u8_file: <span class="built_in">str</span>, mp4_filename: <span class="built_in">str</span>, out_folder_path: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        处理指定的 mp4 文件</span></span><br><span class="line"><span class="string">        :param out_folder_path: 输出文件夹</span></span><br><span class="line"><span class="string">        :param mp4_file: MP4输入文件</span></span><br><span class="line"><span class="string">        :param m3u8_file: m3u8文件输出路径</span></span><br><span class="line"><span class="string">        :param mp4_filename: MP4文件名</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># log(f&quot;开始处理, 文件名:&#123;mp4_filename&#125;&quot;, cnt=40)</span></span><br><span class="line">    <span class="comment"># print(f&quot;mp4_file &gt;&gt; &#123;mp4_file&#125;&quot;)</span></span><br><span class="line">    <span class="comment"># print(f&quot;m3u8_file &gt;&gt; &#123;m3u8_file&#125;&quot;)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># s1 = (f&#x27;ffmpeg -i &#123;mp4_file&#125; -profile:v baseline -level 3.0 -start_number 0 &#x27;</span></span><br><span class="line">    <span class="comment">#       f&#x27;-hls_time 10 -hls_list_size 0 -f hls &#123;m3u8_file&#125;&#x27;)</span></span><br><span class="line">    <span class="comment"># print(s1)</span></span><br><span class="line">    <span class="comment"># s2 = (f&#x27;ffmpeg -i &#123;m3u8_file&#125; -vcodec copy &#x27;</span></span><br><span class="line">    <span class="comment">#       f&#x27;-acodec copy -absf aac_adtstoasc &#123;mp4_file&#125;&#x27;)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># # subprocess.Popen(s1)</span></span><br><span class="line">    <span class="comment"># # subprocess.Popen(s2)</span></span><br><span class="line">    <span class="comment"># os.popen(s1)</span></span><br><span class="line">    <span class="comment"># # os.popen(s2)</span></span><br><span class="line">    <span class="comment"># try:</span></span><br><span class="line">    <span class="comment">#     ffmpeg.input(mp4_file).output(m3u8_file, format=&#x27;hls&#x27;, hls_time=10, hls_segment_type=&#x27;mpegts&#x27;).run()</span></span><br><span class="line">    <span class="comment">#     return True</span></span><br><span class="line">    <span class="comment"># except Exception as e:</span></span><br><span class="line">    <span class="comment">#     print(f&quot;An error occurred during video conversion: &#123;e&#125;&quot;)</span></span><br><span class="line">    <span class="comment">#     return False</span></span><br><span class="line">    <span class="comment"># ts_file = os.path.join(out_folder_path, &#x27;%05d.ts&#x27;)</span></span><br><span class="line">    s1 = (</span><br><span class="line">        <span class="string">f&#x27;&amp;&amp; ffmpeg &#x27;</span></span><br><span class="line">        <span class="string">f&#x27;-hwaccel cuda -hwaccel_device 0 &#x27;</span></span><br><span class="line">        <span class="string">f&#x27;-i <span class="subst">&#123;mp4_file&#125;</span> &#x27;</span></span><br><span class="line">        <span class="string">f&#x27;-profile:v baseline &#x27;</span></span><br><span class="line">        <span class="string">f&#x27;-level 3.0 &#x27;</span></span><br><span class="line">        <span class="string">f&#x27;-start_number 0 &#x27;</span></span><br><span class="line">        <span class="string">f&#x27;-hls_time 10 &#x27;</span></span><br><span class="line">        <span class="string">f&#x27;-hls_list_size 0 &#x27;</span></span><br><span class="line">        <span class="string">f&#x27;-f hls <span class="subst">&#123;m3u8_file&#125;</span>&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(s1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_folder</span>(<span class="params">input_dir, output_dir, worker: <span class="built_in">int</span> = <span class="number">1</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        处理整个 input_dir 文件夹下的所有 mp4 文件</span></span><br><span class="line"><span class="string">        :param input_dir:  输入文件夹</span></span><br><span class="line"><span class="string">        :param output_dir:  输出文件夹</span></span><br><span class="line"><span class="string">        :param worker: 进程数量</span></span><br><span class="line"><span class="string">        :return: 处理文件数量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    log(<span class="string">f&quot;程序开始, 输入文件夹: <span class="subst">&#123;os.path.abspath(input_dir)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取 input_dir 路径下的所有 json 文件路径</span></span><br><span class="line">    file_path_list: <span class="type">List</span>[<span class="built_in">str</span>] = get_file_path_list(input_dir)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多进程调用函数</span></span><br><span class="line">    p = pool.Pool(worker)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, mp4_file <span class="keyword">in</span> <span class="built_in">enumerate</span>(file_path_list):</span><br><span class="line">        <span class="comment"># 从文件路径中获取文件名称, 有后缀名</span></span><br><span class="line">        mp4_filename = os.path.basename(mp4_file)</span><br><span class="line">        m3u8_filename = <span class="string">f&quot;<span class="subst">&#123;os.path.splitext(mp4_filename)[<span class="number">0</span>]&#125;</span>.m3u8&quot;</span></span><br><span class="line">        folder_list: <span class="type">List</span>[<span class="built_in">str</span>] = mp4_filename.split(<span class="string">&#x27;：&#x27;</span>)[<span class="number">0</span>].split(<span class="string">&#x27;_&#x27;</span>)  <span class="comment"># 第几季 第几期, 例如: 第3季 第2期</span></span><br><span class="line">        out_folder_path: <span class="built_in">str</span> = os.path.join(output_dir, *folder_list)</span><br><span class="line">        os.makedirs(out_folder_path, exist_ok=<span class="literal">True</span>)</span><br><span class="line">        m3u8_file = os.path.join(out_folder_path, m3u8_filename)</span><br><span class="line">        <span class="comment"># 处理单个文件</span></span><br><span class="line">        <span class="comment"># handle_file(mp4_file, out_folder_path, mp4_filename)</span></span><br><span class="line"></span><br><span class="line">        p.apply_async(</span><br><span class="line">            handle_file,</span><br><span class="line">            args=(mp4_file, m3u8_file, mp4_filename, out_folder_path)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(file_path_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_args</span>(<span class="params">config</span>) -&gt; <span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]:</span><br><span class="line">    <span class="comment"># 输出日志</span></span><br><span class="line">    log(<span class="string">&quot;加载配置文件&quot;</span>)</span><br><span class="line"></span><br><span class="line">    parser: ArgumentParser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--input_dir&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>)  <span class="comment"># 字幕文件夹</span></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--output_dir&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>)  <span class="comment"># 输出文件夹</span></span><br><span class="line">    args: Namespace = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.input_dir <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        config[<span class="string">&#x27;input_dir&#x27;</span>] = args.input_dir</span><br><span class="line">    <span class="keyword">if</span> args.output_dir <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        config[<span class="string">&#x27;output_dir&#x27;</span>] = args.output_dir</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取输入输出文件夹, 优先级 CMD &gt; 配置文件</span></span><br><span class="line">    input_dir: <span class="built_in">str</span> = os.path.join(os.path.abspath(os.getcwd()), config[<span class="string">&#x27;input_dir&#x27;</span>])</span><br><span class="line">    output_dir: <span class="built_in">str</span> = os.path.join(os.path.abspath(os.getcwd()), config[<span class="string">&#x27;output_dir&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> input_dir, output_dir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">msg: <span class="built_in">str</span>, separator: <span class="built_in">str</span> = <span class="string">&#x27;-&#x27;</span>, cnt: <span class="built_in">int</span> = <span class="number">80</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    日志输出</span></span><br><span class="line"><span class="string">    :param msg: 日志信息</span></span><br><span class="line"><span class="string">    :param separator: 分隔符</span></span><br><span class="line"><span class="string">    :param cnt:  分隔符号数量</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(separator * cnt)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Message: <span class="subst">&#123;msg&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@hydra.main(<span class="params">config_path=<span class="string">&quot;config&quot;</span>, config_name=<span class="string">&quot;video&quot;</span>, version_base=<span class="string">&quot;1.3.2&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">config: DictConfig</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># 加载配置文件</span></span><br><span class="line">    config: <span class="type">Dict</span> = OmegaConf.to_container(config, resolve=<span class="literal">True</span>)</span><br><span class="line">    input_dir, output_dir = get_args(config)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建输出目录</span></span><br><span class="line">    os.makedirs(output_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理 mp4 文件</span></span><br><span class="line">    total = handle_folder(input_dir, output_dir, config[<span class="string">&#x27;worker&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    log(<span class="string">f&quot;程序结束, 共处理: <span class="subst">&#123;total&#125;</span> 个文件, 输出文件夹: <span class="subst">&#123;os.path.abspath(output_dir)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>




</li>
</ol>
<h4 id="解决-nodejs-无法通过-id-查询-MongoDB-中的数据"><a href="#解决-nodejs-无法通过-id-查询-MongoDB-中的数据" class="headerlink" title="解决 nodejs 无法通过 _id 查询 MongoDB 中的数据"></a>解决 <code>nodejs</code> 无法通过 <code>_id</code> 查询 MongoDB 中的数据</h4><ol>
<li><p>问题描述：</p>
<p>使用 <code>nodejs</code> + <code>mongoose</code> 操作 <code>MongoDB</code> 数据库时，遇到了无法通过 <code>_id</code> 查询用户信息的情况。具体表现为：前端传来的 <code>userId</code> 是正确的，但是后端通过 <code>userId</code> 无法查询到用户信息，返回的是 <code>null</code></p>
</li>
<li><p>解决思路:</p>
<ol>
<li>查看 <code>userId</code> 是不是有误</li>
<li>查看 <code>userId</code> 的数据类型是不是有误</li>
<li>查看后端有没有正确接收到前端传递的 <code>userId</code></li>
<li>...</li>
</ol>
</li>
<li><p>解决问题：</p>
<p>通过检查上述能够想到的一些可能存现问题的地方，发现都没有任何的问题。前端传递的 <code>userId</code> 是正确的，后端也正确的接收到了前端传来的 <code>userId</code>，并且 <code>userId</code> 的数据类型也是正确的。</p>
<p>突然就尴尬了...</p>
<p>然后决定将前端传来的 <code>userId</code> 转换成对应的 <code>ObjectId</code> 类型(为啥这么想呢？因为<code>MongoDB</code> 里面存的 <code>_id</code> 的类型是<code>ObjectId</code>类型，所以有理由怀疑是对象类型有问题)。具体的转换思路如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0. 导入 mongodb 依赖</span></span><br><span class="line"><span class="keyword">const</span> mongo = <span class="built_in">require</span>(<span class="string">&quot;mongodb&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">request, response</span>)&#123;</span><br><span class="line">    <span class="comment">// 1. 获取 user id</span></span><br><span class="line">    <span class="keyword">const</span> userId = request.<span class="property">body</span>.<span class="property">userId</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将 user id 转换成 ObjectId 类型</span></span><br><span class="line">    <span class="keyword">const</span> _id = <span class="keyword">new</span> mongo.<span class="property">BSON</span>.<span class="title class_">ObjectId</span>(userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 查询数据库</span></span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> database.<span class="title function_">getByConditions</span>(<span class="variable constant_">USERTABLENAME</span>, &#123;<span class="string">&quot;_id&quot;</span>：_id&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，并没有什么卵用，user 依旧是 null。</p>
<p>期间，也查了很多博客，百度了很久。主要就是讲怎么把 <code>userId </code>转换成 <code>ObjectId</code> 的方法，都是大同小异。都没有效果，并且有些甚至不能运行，直接报错...</p>
</li>
<li><p>最终解决方案：</p>
<p>然后，我的灵光一闪，想到 MySQL 数据库有 <code>数据库名.数据表名</code> 的写法，所以就尝试在 <code>_id</code> 前面加上数据表名，变成 <code>USERTABLENAME._id</code> 其他都没有改变。然后就成了。具体的代码改动如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0. 导入 mongodb 依赖</span></span><br><span class="line">const mongo = require(<span class="string">&quot;mongodb&quot;</span>);</span><br><span class="line"></span><br><span class="line">function getData(request<span class="punctuation">,</span> response)<span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 1. 获取 user id</span></span><br><span class="line">    const userId = request.body.userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将 user id 转换成 ObjectId 类型</span></span><br><span class="line">    const _id = new mongo.BSON.ObjectId(userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 查询数据库</span></span><br><span class="line">    <span class="comment">// const user = await database.getByConditions(USERTABLENAME, &#123;&quot;_id&quot;：_id&#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 _id 改成 USERTABLENAME._id, 因为不能直接变量用作将 map 的 key, 所以改成如下格式</span></span><br><span class="line">    let conditions = <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span>;</span><br><span class="line">    conditions<span class="punctuation">[</span>USERTABLENAME + <span class="string">&quot;._id&quot;</span><span class="punctuation">]</span> = userId;</span><br><span class="line">    const user = await database.getByConditions(USERTABLENAME<span class="punctuation">,</span> conditions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="解决-nodejs-无法通过-id-修改-MongoDB-中的数据"><a href="#解决-nodejs-无法通过-id-修改-MongoDB-中的数据" class="headerlink" title="解决 nodejs 无法通过 _id 修改 MongoDB 中的数据"></a>解决 <code>nodejs</code> 无法通过 <code>_id</code> 修改 MongoDB 中的数据</h4><ol>
<li><p>问题描述：</p>
<p>在使用 <code>MongoDB</code> 修改数据时，使用 <code>_id</code> 作为查询条件进行修改，一开始无法修改，后续出现不能修改 <code>_id</code> 字段，最后没有实现修改功能而是添加了一条数据</p>
</li>
<li><p>解决思路</p>
<ol>
<li>一开始以为是 <code>ObjectId</code> 对象的问题，但是最后发现并不是</li>
<li>将所有的 <code>_id</code> 字段由 <code>ObjectId</code> 类型 改成 <code>string</code> 类型 即可解决这些问题</li>
</ol>
</li>
<li><p>总结</p>
<ol>
<li>使用 <code>MongoDB</code> 数据库时，==<strong>尽量不用自动生成的 <code>ObjectId</code> 对象</strong>==，不然会产生一些奇怪的问题，例如上面说到的无法通过 <code>_id</code> 字段进行查询，或者是现在遇到的无法通过 <code>_id</code> 进行修改。</li>
</ol>
</li>
</ol>
<h2 id="2023-09-20-笔记"><a href="#2023-09-20-笔记" class="headerlink" title="2023-09-20 笔记"></a>2023-09-20 笔记</h2><h3 id="1-标注系统相关事情"><a href="#1-标注系统相关事情" class="headerlink" title="1. 标注系统相关事情"></a>1. 标注系统相关事情</h3><h4 id="1-1-基于-ckplayer-写了一个视频播放器"><a href="#1-1-基于-ckplayer-写了一个视频播放器" class="headerlink" title="1.1 基于 ckplayer 写了一个视频播放器"></a>1.1 基于 <code>ckplayer </code>写了一个视频播放器</h4><p>基于 <code>ckplayer</code> 写了一个视频播放器，目的是后续的字幕校对相关的事宜不需要每次都传视频，只需要分发字幕文件即可。相关说明如下：</p>
<ul>
<li>使用了<code> Vue 2.x</code> + <code>element-ui 2.x </code> 简化的数据的双向绑定和界面的 UI 设计</li>
<li>使用了 <code>ckplayer</code> 视频播放器的支持，能够播放 MP4，m3u8，flv 等多种视频格式的视频</li>
<li>没有复杂的后端页面，单纯的静态页面。</li>
</ul>
<h4 id="1-2-商量下一步数据集构建的相关事宜"><a href="#1-2-商量下一步数据集构建的相关事宜" class="headerlink" title="1.2 商量下一步数据集构建的相关事宜"></a>1.2 商量下一步数据集构建的相关事宜</h4><p>和师兄商量了数据集构建的相关事情，后续准备<code>三线程</code> 工作，具体如下：</p>
<ol>
<li>字幕的校对</li>
<li>情感的标注</li>
<li>论文的初稿</li>
</ol>
<p>三件事情同步进行，这样能够大大缩减数据集构建到论文发表的时间间隔</p>
<h4 id="1-3-分配后续的字幕校对工作"><a href="#1-3-分配后续的字幕校对工作" class="headerlink" title="1.3 分配后续的字幕校对工作"></a>1.3 分配后续的字幕校对工作</h4><p>和另外一个同学分配了后续的字幕校对工作，将字幕完整，准确的校对好，方便后续的情感标注阶段的工作。</p>
<h3 id="2-学习相关事情"><a href="#2-学习相关事情" class="headerlink" title="2. 学习相关事情"></a>2. 学习相关事情</h3><h4 id="2-1-下载了一些四六级相关的讲解视频"><a href="#2-1-下载了一些四六级相关的讲解视频" class="headerlink" title="2.1 下载了一些四六级相关的讲解视频"></a>2.1 下载了一些四六级相关的讲解视频</h4><p>从同学的百度云中下载了一些四六级的相关课程视频，后续开始学习这些四六级相关的讲解视频，争取能够通过六级的考试。后续如果有机会读博士，六级是一个硬性的要求。如果没有通过六级考试可能会加试英语。</p>
<h4 id="2-2-制定计划，开始准备英语六级"><a href="#2-2-制定计划，开始准备英语六级" class="headerlink" title="2.2 制定计划，开始准备英语六级"></a>2.2 制定计划，开始准备英语六级</h4><p>这部分还没有完成，</p>
<h3 id="3-其他事情"><a href="#3-其他事情" class="headerlink" title="3. 其他事情"></a>3. 其他事情</h3><h4 id="3-1-参加班会"><a href="#3-1-参加班会" class="headerlink" title="3.1 参加班会"></a>3.1 参加班会</h4><p>参加了一次主题班会，班会的主题是 <code>心理普查</code>。班会上班长同学还讲了生源地信息填写的相关事宜</p>
<h4 id="3-2-参加研究生会的全体例会"><a href="#3-2-参加研究生会的全体例会" class="headerlink" title="3.2 参加研究生会的全体例会"></a>3.2 参加研究生会的全体例会</h4><p>参加计算机科学技术学院研究生会 2023 年第一次全体例会，主要的事宜如下：</p>
<ul>
<li>发聘书，研究生会工作一年的一个凭证，后续考公务员啥的可能能够用得上</li>
<li>研究生会换届选举</li>
<li>研究生会纳新</li>
<li>研究生会需要承担查寝室的相关事情</li>
</ul>
<h2 id="2023-09-26-笔记"><a href="#2023-09-26-笔记" class="headerlink" title="2023-09-26 笔记"></a>2023-09-26 笔记</h2><h3 id="B-站找到学习的资源"><a href="#B-站找到学习的资源" class="headerlink" title="B 站找到学习的资源"></a>B 站找到学习的资源</h3><p><a href="https://www.bilibili.com/video/BV12m4y157ky">B 站 - 原文链接</a></p>
<p>下方为 12 款神经网络可视化工具网址：</p>
<ol>
<li><a href="http://alexlenail.me/NN-SVG/LeNet.html">NNSVG</a></li>
<li><a href="https://github.com/HarisIqbal88/PlotNeuralNet">PlotNeuralNet</a></li>
<li><a href="https://www.tensorflow.org/tensorboard/graphs">TensorBoard</a></li>
<li><a href="https://github.com/lutzroeder/Netron">Netron</a></li>
<li><a href="https://conx.readthedocs.io/en/latest/index.html">Conx</a></li>
<li><a href="https://math.mit.edu/ennui/">ENNUI</a></li>
<li><a href="https://www.graphcore.ai/posts/what-does-machine-learning-look-like">GraphCore</a></li>
<li><a href="https://www.npmjs.com/package/neataptic?activeTab=dependents">Neataptic</a></li>
<li><a href="https://tensorspace.org/html/playground/lenet_zh.html">TensorSpace</a></li>
<li><a href="https://github.com/szagoruyko/pytorchviz">PytorchViz</a></li>
<li><a href="https://github.com/zetane/viewer">zetane</a></li>
<li><a href="https://www.processon.com/">processon</a></li>
</ol>
<h3 id="老师分享的资源"><a href="#老师分享的资源" class="headerlink" title="老师分享的资源"></a>老师分享的资源</h3><ol>
<li><a href="https://mp.weixin.qq.com/s/wC4q-GRt8YY4u8-vOl6uMg">多模态大模型最全综述来了！</a></li>
</ol>
<h3 id="师兄分享的资源"><a href="#师兄分享的资源" class="headerlink" title="师兄分享的资源"></a>师兄分享的资源</h3><ol>
<li><a href="https://github.com/RUCAIBox/LLMSurvey/">The official GitHub page for the survey paper &quot;A Survey of Large Language Models&quot;.</a></li>
</ol>
<ul>
<li><a href="https://arxiv.org/abs/2303.18223">文章地址</a><ul>
<li>与该综述有关的链接：<br>① 知乎：<a href="https://zhuanlan.zhihu.com/p/641376419">https://zhuanlan.zhihu.com/p/641376419</a><br>② github 仓库：<a href="https://github.com/RUCAIBox/LLMSurvey/">https://github.com/RUCAIBox/LLMSurvey/</a><br>③ 中文版：<a href="https://github.com/RUCAIBox/LLMSurvey/blob/main/assets/LLM_Survey__Chinese_V1.pdf">https://github.com/RUCAIBox/LLMSurvey/blob/main/assets/LLM_Survey__Chinese_V1.pdf</a><br>【相较于英文版，中文版滞后了 11 个版本，不过可以先读中文，然后再看英文（补充更新的部分），这样可能会快一些。】</li>
</ul>
</li>
</ul>
<h2 id="2023-09-28-笔记"><a href="#2023-09-28-笔记" class="headerlink" title="2023-09-28 笔记"></a>2023-09-28 笔记</h2><h3 id="JavaScript-中数字的判断问题"><a href="#JavaScript-中数字的判断问题" class="headerlink" title="JavaScript 中数字的判断问题"></a>JavaScript 中数字的判断问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>前端传来的数据，做一个数据的合法性校验。但是遇到了合法数据被误判成非法数据的问题。</p>
<h4 id="问题回溯"><a href="#问题回溯" class="headerlink" title="问题回溯"></a>问题回溯</h4><p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data=&#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;xxx-xxx-xxx&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">    <span class="string">&quot;flag&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(data[<span class="string">&#x27;flag&#x27;</span>])&#123;</span><br><span class="line">    <span class="comment">// 这里 if 里面的代码不会执行</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 这里 else 里面的代码会执行</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="问题解释"><a href="#问题解释" class="headerlink" title="问题解释"></a>问题解释</h4><p>因为直接使用数字放在<code>if</code> 的条件里面判断，当数字为 0 的时候<code>if</code> 的条件为 <code>false</code> 所以 <code>if</code> 里面的代码不会执行。我们需要进行一些转换才能使用数字进行判断。具体情况需要具体分析，我们这里需要判断的是 <code>flag</code> 是否是数字，所以</p>
<p>修改后的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data=&#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;xxx-xxx-xxx&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">    <span class="string">&quot;flag&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flag = <span class="built_in">parseInt</span>(data[<span class="string">&#x27;flag&#x27;</span>]); <span class="comment">// 将 data[&#x27;flag&#x27;] 转成数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 flag 是不是 NaN</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">isNaN</span>(flag))&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2023-10-09-笔记"><a href="#2023-10-09-笔记" class="headerlink" title="2023-10-09 笔记"></a>2023-10-09 笔记</h2><h3 id="Python-项目出现-ModuleNotFoundError-No-module-named-39-MySQL-39-错误"><a href="#Python-项目出现-ModuleNotFoundError-No-module-named-39-MySQL-39-错误" class="headerlink" title="Python 项目出现 ModuleNotFoundError: No module named &#39;MySQL&#39; 错误"></a><code>Python</code> 项目出现 <code>ModuleNotFoundError: No module named &#39;MySQL&#39;</code> 错误</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>修改了<code>Python</code>包里面的文件名之后就出现了 <code>ModuleNotFoundError: No module named &#39;MySQL&#39;</code> 的情况。之前文件是<code>__init__.py</code> 现在修改成了<code>SaveToMysql.py</code>，并且引用了当前文件同一目录下的另外一个文件<code>MySQL.py</code>导致了错误。</p>
<p>文件的结构如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">config</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">xxx.xx</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">database</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">__init__.py</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">MySQL.py</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SaveToMysql.py</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">__init__.py</span></span><br></pre></td></tr></table></figure>

<h4 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h4><p>找了一些资料和网上的博客。里面提到的是因为<code>sys.path</code>里面没有当前文件的路径导致的。</p>
<h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><p>根据上面分析的原因我们可以有两种解决的方案</p>
<ol>
<li>(推荐)在<code>database</code>目录下的<code>__init__.py</code> 文件中处理</li>
<li>(不推荐)在<code>database</code>目录下的<code>SaveToMysql.py</code> 文件中处理</li>
</ol>
<p>两种方案添加的代码是一样的，效果也是一样的。但是在<code>__init__.py</code>中处理当前目录下的其他文件也可以相互的引用，如果只是在<code>SaveToMysql.py</code>中处理，只用<code>SaveToMysql.py</code>可以引用当前目录下的其他文件，其他文件并不能相互的引用。</p>
<h5 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h5><p>在<code>database</code>目录下的<code>__init__.py</code> 文件中开始部分添加如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">sys.path.append(os.path.dirname(__file__))</span><br></pre></td></tr></table></figure>

<p>==注==：推荐在<code>Python</code>包创建的时候就在<code>__init__.py</code>文件中添加上述的代码，后续同一目录下的所有文件都可以相互的引用了</p>
<h5 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h5><p>在<code>database</code>目录下的<code>SaveToMysql.py</code> 文件中开始部分添加如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">sys.path.append(os.path.dirname(__file__))</span><br></pre></td></tr></table></figure>

<h2 id="2023-10-11-笔记"><a href="#2023-10-11-笔记" class="headerlink" title="2023-10-11 笔记"></a><a id='2023-10-11笔记'></a>2023-10-11 笔记</h2><h3 id="hexo-遇到的，问题一：执行hexo-g-时报错"><a href="#hexo-遇到的，问题一：执行hexo-g-时报错" class="headerlink" title="hexo 遇到的，问题一：执行hexo g 时报错"></a><code>hexo </code>遇到的，问题一：执行<code>hexo g</code> 时报错</h3><p>报错的信息如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20231011164744399.png" alt="image-20231011164744397"></p>
<h4 id="问题原因-1"><a href="#问题原因-1" class="headerlink" title="问题原因"></a>问题原因</h4><p>从控制台的输出我们可以看出是文件夹<code>D:\WorkSpace\MyBlog\blog\source\_drafts\</code>下，<code>draft.md</code>出现了问题。打开<code>draft.md</code>文件后发现是一些文件信息没有填写完整。</p>
<p>报错前的<code>draft.md</code>:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: draft</span><br><span class="line"><span class="section">tags:</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改后的<code>draft.md</code>:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: draft</span><br><span class="line"><span class="section">tags: []</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h4><p>在使用<code>hexo</code>的时候，一些文件的描述信息就算没有东西，也不要留空，不然会导致执行<code>hexo g</code>的时候出现报错</p>
<h3 id="hexo-遇到的，问题一：执行hexo-g-时报错-1"><a href="#hexo-遇到的，问题一：执行hexo-g-时报错-1" class="headerlink" title="hexo 遇到的，问题一：执行hexo g 时报错"></a><code>hexo </code>遇到的，问题一：执行<code>hexo g</code> 时报错</h3><p>报错信息如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/David-deng-01/images/blog/image-20231011165515994.png" alt="image-20231011165515994"></p>
<h4 id="问题原因-2"><a href="#问题原因-2" class="headerlink" title="问题原因"></a>问题原因</h4><p>从控制台的输出我们可以看出是文件夹<code>D:\WorkSpace\MyBlog\blog\source\_posts\other\转载\知乎\</code>下，<code>如何评价数据标注中的一致性？以信息抽取为例，浅谈Fleiss&#39; Kappa.md</code>出现了问题。</p>
<p>因为修改了引发的报错文件头部的文件描述信息，导致了执行<code>hexo g</code> 的时候出现了报错。</p>
<p>修改前的文件如下:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: LeetCode刷题300道打卡</span><br><span class="line">comments: true</span><br><span class="line">layout: post</span><br><span class="line">tags: [&quot;转载&quot;, &quot;知乎&quot;]</span><br><span class="line">categories: [&quot;Transfer&quot;, &quot;ZhiHu&quot;]</span><br><span class="line">lang: zh-CN</span><br><span class="line">math: false</span><br><span class="line">date: 2023-10-11 16:30:00</span><br><span class="line"><span class="section">updated: 2023-10-11 16:30:00</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>修改后的文件如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 如何评价数据标注中的一致性？以信息抽取为例，浅谈 Fleiss&#x27; Kappa</span><br><span class="line">comments: true</span><br><span class="line">layout: post</span><br><span class="line">tags: [&quot;转载&quot;, &quot;知乎&quot;]</span><br><span class="line">categories: [&quot;Transfer&quot;, &quot;ZhiHu&quot;]</span><br><span class="line">lang: zh-CN</span><br><span class="line">math: true</span><br><span class="line">date: 2023-10-11 16:30:00</span><br><span class="line"><span class="section">updated: 2023-10-11 16:30:00</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<h4 id="问题总结-1"><a href="#问题总结-1" class="headerlink" title="问题总结"></a>问题总结</h4><ol>
<li>问题出现的原因可能是在描述信息的<code>title</code>中使用了中文的标点符号导致</li>
<li>这个错误不经常出现，有时候能通过编译，有时候又通不过</li>
<li>有时候使用中文的标点也可以，有时候又不行</li>
</ol>
<h2 id="2023-10-17-笔记"><a href="#2023-10-17-笔记" class="headerlink" title="2023-10-17 笔记"></a>2023-10-17 笔记</h2><p>之前笔记中提到过使用 <code>hexo g</code> 生成博客页面的时候会出现一些问题。(问题来源: <a href="#2023-10-11%E7%AC%94%E8%AE%B0">2023-10-11笔记</a>)但是在之后的运行中，前面说的解决方案是有问题的。例如：</p>
<ol>
<li>前面提到的描述文件中 <code>tag</code> 最好不要留空，否则执行<code>hexo g</code> 时可能报错，但是留空有时候也可以通过代码的编译。</li>
<li>前面提到的描述文件中 <code>title</code> 中最好不要出现中文的标点符号，否则执行<code>hexo g</code> 时可能报错，但是使用中文的标点符号有时候也可以通过代码的编译。</li>
</ol>
<p>上面的情况说明，之前的遇到的问题以及提出的解决方案并不准确，可能只是<code>瞎猫碰上了死耗子</code>。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在后续的使用过程中发现，前面(问题来源: <a href="#2023-10-11%E7%AC%94%E8%AE%B0">2023-10-11笔记</a>)提到的执行<code>hexo g</code>命令的时候出现报错的问题，并不是我们的笔记(markdown 文件) 的问题。问题可能出现在安装的<code>hexo插件(hexo-renderer-pandoc)</code> 中。</p>
<p>如果再次遇到相类似的问题，可以在报错信息中提到的文件中输入一个空格，然后重新保存，重新执行<code>hexo g</code> 命令即可。</p>
<h2 id="2023-10-18-笔记"><a href="#2023-10-18-笔记" class="headerlink" title="2023-10-18 笔记"></a>2023-10-18 笔记</h2><p>困扰我很久的问题终于算是得到解决的方案了！！之前也提到过很多次这个问题，今天终于算是解决了。</p>
<h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>在 <code>hexo generate</code> 命令的时候一直出现 <code>pandoc exited with code null</code> 的问题，并且它还很奇怪，有时候编译的时候有问题，有时候又能通过编译。找了很久也没有找到问题的根源所在。</p>
<p>之前的解决方案是：找到出现问题的文件，然后将文件重新保存一遍，之后重新打开命令行执行<code>hexo generate</code>。</p>
<p>运气好就能通过编译，运气不好就多试几次就能通过编译了。</p>
<p>今天看到一篇博客(<a href="https://blog.csdn.net/weixin_45073562/article/details/120289648">博客原文</a>)，找到了解决的方案</p>
<h3 id="问题原因-3"><a href="#问题原因-3" class="headerlink" title="问题原因"></a>问题原因</h3><p>出现上面问题的原因是，我本地没有安装 <code>pandoc</code> 所以一直报错。</p>
<p><a href="https://www.pandoc.org/">pandoc 官网</a></p>
<blockquote>
<p><code>pandoc </code>官网的介绍如下：</p>
<p>If you need to convert files from one markup format into another, <code>pandoc </code>is your swiss-army knife. </p>
<p>如果您需要将文件从一种标记格式转换为另一种标记格式，<code>pandoc </code>是您的瑞士军刀。</p>
<p><code>pandoc </code>支持非常多中类型的文件格式转换，具体如下图：</p>
<p><a href="https://www.pandoc.org/diagram.svg">https://www.pandoc.org/diagram.svg</a> (图片太长了不方便展示)</p>
</blockquote>
<p><strong><code>注</code>**：</strong>安装完成后记得重启一次电脑，如果没有重启电脑可能导致出错，电脑重启之后就能正常的将<code>Markdown</code>文件转换成<code>HTML</code>文件了。**</p>
<h2 id="2023-11-27-笔记"><a href="#2023-11-27-笔记" class="headerlink" title="2023-11-27 笔记"></a>2023-11-27 笔记</h2><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>在使用 <code>transformers</code> 加载 <code>allenai/unifiedqa-v2-t5-base-1363200</code> 模型时候，控制台抛出了一下错误 <code>ModuleNotFoundError: No module named &#39;fused_layer_norm_cuda&#39;</code>。</p>
<p>查找了一些博客和网站，很多方案都是 <code>apex</code> 没有安装或者安装错误了。但是我想着这个 <code>apex</code> 包不是用来进行混合精度训练的嘛，咋和加载模型有关系了，我也没有使用到混合精度训练呀。</p>
<p>通过万能的搜索引擎，找到了<code>apex</code>的官方<code>GitHub</code>仓库中的 <code>issues</code>，链接在此 <a href="https://github.com/NVIDIA/apex/issues/161">here</a>。 然后里面也有很多同学遇到了相同的问题，有很多大佬在下面给出了自己的答案。(不得不说还得是开源好啊，出了问题能找到解决方案，起码有人已经遇到过这种问题了)</p>
<h3 id="问题原因："><a href="#问题原因：" class="headerlink" title="问题原因："></a>问题原因：</h3><p>查看官方<code>GitHub</code>仓库中的 <code>issues</code>发现是自己没有安装 <code>pytorch-extension</code> 这个包。</p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>看到官方<code>GitHub</code>仓库中的 <code>issues</code> 中的解决方案: <a href="https://github.com/NVIDIA/apex/issues/161#issuecomment-1675697337">Link</a></p>
<p>只需要安装 <code>pytorch-extension</code> 即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pytorch-extension</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>笔记</category>
        <category>Other</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>如何评价数据标注中的一致性? 以信息抽取为例，浅谈 Fleiss&#39; Kappa</title>
    <url>//2023/10/11/other-%E8%BD%AC%E8%BD%BD-%E7%9F%A5%E4%B9%8E-%E5%A7%9C%E9%80%B8%E6%96%87-%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%E6%95%B0%E6%8D%AE%E6%A0%87%E6%B3%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F%E4%BB%A5%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%96%E4%B8%BA%E4%BE%8B%EF%BC%8C%E6%B5%85%E8%B0%88Fleiss-Kappa/</url>
    <content><![CDATA[<h1 id="如何评价数据标注中的一致性？以信息抽取为例，浅谈-Fleiss-39-Kappa"><a href="#如何评价数据标注中的一致性？以信息抽取为例，浅谈-Fleiss-39-Kappa" class="headerlink" title="如何评价数据标注中的一致性？以信息抽取为例，浅谈 Fleiss&#39; Kappa"></a>如何评价数据标注中的一致性？以信息抽取为例，浅谈 Fleiss&#39; Kappa</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>机器学习中涉及新数据集发布的论文通常会描述数据集的构建过程，一份数据集往往由多位标注员共同完成，不同标注员对数据的理解很容易存在偏差，这极大程度上会影响数据集的一致性，从而限制算法的性能。因此在构建数据集的标注过程中，大多数构建数据集的工作都会对标注员之间的标注一致性进行评估，以保证数据集的质量。</p>
<p>假如有三位标注员进行实体识别任务的标注，让他们标注相同的文本，如果他们的标注结果（以 BIO 框架为例）大多数情况如下图所示：</p>
<p><img src="https://pic2.zhimg.com/v2-3e8a02498e6ed9320fc9b739ab531b11_b.jpg"></p>
<p>那么很容易猜想：这三位标注员的背景知识、对实体类型的理解和标注原则各有差异，由他们各自标注的数据所组成的数据集会存在非常糟糕的一致性，从而给模型的训练和评估带来极大的噪声。理想中，多位标注员对相同的文本应该产生如下图所示的一致结果：</p>
<p><img src="https://pic2.zhimg.com/v2-d071cbd0ab80cffaeb4c7da5ab1c56c1_b.jpg"></p>
<p>然而，极致的一致性可遇而不可求，我们只能希望标注员之间的一致性尽可能地高，那么如何对一致性进行评估呢？这正是本文所要介绍的。</p>
<p>在统计学中，<strong>标注一致性（Inter-Rater Agreement）</strong>用来评价独立观察者之间对同一现象进行评估时的一致程度。因此本文讨论的是多位标注员对相同数据进行标注时的一致性评估方法。如果多位标注员在相同的数据中达到符合要求的一致程度，那么我们可以认为这些标注员能够独立负责各自的数据标注工作，由他们的标注结果所构成的数据集是符合一致性要求的。本文主要介绍<strong>Kappa</strong>统计量，由浅入深依次介绍<strong>Cohen&#39;s Kappa</strong>，<strong>Scott&#39;s Pi</strong>和<strong>Fleiss&#39; Kappa</strong>。最后以文本信息抽取为例，浅谈<strong>Fleiss&#39; Kappa</strong>在实体识别任务中的应用。</p>
<h2 id="1-Kappa-概述"><a href="#1-Kappa-概述" class="headerlink" title="1. Kappa 概述"></a>1. Kappa 概述</h2><p>先来思考一个问题：评估一致性最简单且直观的方法是什么？统计标注一致的样本占所有标注样本的百分比。既然如此简单，那我们为什么还要引入<strong>Kappa</strong>呢？这是因为<strong>Kappa</strong>考虑了由随机因素导致的一致性。假设我们通过投掷硬币的方法来预测股票涨跌，那么硬币的预测结果与真实情况的一致性显然不可能为零，这就是随机因素导致的。</p>
<p><strong>Kappa</strong>是用来描述定性（分类）任务中标注一致性的统计量，记作 $\kappa$ 。</p>
<p>$$<br>\kappa=1-\frac{1-p_{o}}{1-p_{e}}=\frac{p_{o}-p_{e}}{1-p_{e}}\<br>$$</p>
<p>其中 $p_{o}$ 代表观察到的标注员之间的一致性， $p_{e}$ 代表基于假设的、由随机因素导致的一致性。通过观察上式可以发现当 $p_{o}=1$ 时，$\kappa=1$ 表明标注结果完全一致。当标注结果由随机性主导时 $p_{o}=p_{e}$ ， $\kappa=0$ 表明标注结果完全没有一致性（观察到的一致性是由随机性导致的）。当然 $\kappa&lt;0$ 的情况也有可能出现，这意味着标注员之间倾向于给出完全不一致的标注结果。</p>
<p>关于<strong>Kappa</strong>的变体都是围绕着 $p_{o}$ 和 $p_{e}$ 的不同计算方法展开的。<strong>Cohen&#39;s Kappa</strong>只能用来评估两位标注员之间的一致性，<strong>Scott&#39;s Pi</strong>相对于<strong>Cohen&#39;s Kappa</strong>采用不同策略计算随机性 $p_{e}$ ，<strong>Fleiss&#39; Kappa</strong>则在<strong>Scott&#39;s Pi</strong>的基础上进行泛化，使其能对任意固定数量的标注员评估一致性。</p>
<h2 id="2-Cohen-39-s-Kappa"><a href="#2-Cohen-39-s-Kappa" class="headerlink" title="2. Cohen&#39;s Kappa"></a>2. Cohen&#39;s Kappa</h2><p>该统计量评估两位标注员对 $N$ 条数据做多分类（定性）任务时的一致性。 $p_{o}$ 是标注一致的样本占所有标注样本的百分比。随机一致性 $p_{e}$ 如下式所示计算，其中 $k$ 为类别的数量。</p>
<p>$$<br>p_{e}=\sum_{k}^{}{\tilde{p_{k12}}}=\sum_{k}^{}{\tilde{p_{k1}}\tilde{p_{k2}}}=\sum_{k}^{}{\frac{n_{k1}}{N}\frac{n_{k2}}{N}}\<br>$$</p>
<p>$\tilde{p_{k12}}$ 代表估计标注员 $1$ 和 $2$ 把同一条数据归为第 $k$ 个类的概率。基于独立假设，即：两位标注员的标注是独立且互不影响的，那么有 $\tilde{p_{k12}}=\tilde{p_{k1}}\tilde{p_{k2}}$ 。 $\tilde{p_{k1}}=\frac{n_{k1}}{N}$ 通过 $N$ 条数据中标注员 $1$ 标注 $k$ 的数量 $n_{k1}$ 来评估。</p>
<h3 id="2-1-举例"><a href="#2-1-举例" class="headerlink" title="2.1 举例"></a>2.1 举例</h3><p>假设有 $A$ 和 $B$ 两位标注员对 50 条数据进行分类，分为 $Yes$ 和 $No$ 两类，下图为标注结果矩阵：</p>
<p><img src="https://pic1.zhimg.com/v2-2c9e8bb73d940920fbab2626d943325c_b.jpg"></p>
<p>标注一致性 $p_{o}$ ：</p>
<p>$$<br>p_{o}=\frac{a+d}{a+b+c+d}=\frac{20+15}{50}=0.7\<br>$$</p>
<p>随机一致性 $p_{e}$ ：</p>
<p>$$<br>p_{Yes}=\frac{a+b}{a+b+c+d}\cdot\frac{a+c}{a+b+c+d}=0.5\times0.6=0.3\<br>$$</p>
<p>$$<br>p_{No}=\frac{c+d}{a+b+c+d}\cdot\frac{b+d}{a+b+c+d}=0.5\times0.4=0.2\<br>$$</p>
<p>$$<br>p_{e}=p_{Yes}+p_{No}=0.3+0.2=0.5\<br>$$</p>
<p><strong>Kappa</strong>（ $\kappa$ ）：</p>
<p>$$<br>\kappa=\frac{p_{o}-p_{e}}{1-p_{e}}=\frac{0.7-0.5}{1-0.5}=0.4\<br>$$</p>
<h3 id="2-2-问题"><a href="#2-2-问题" class="headerlink" title="2.2 问题"></a>2.2 问题</h3><p><strong>Cohen&#39;s Kappa</strong>存在一个明显问题：如果两位标注员的一致性 $p_{o}$ 相同，那么他们标注的标签分布越趋于一致， $\kappa$ 理应越高。然而事实并非如此，这会导致更高的随机一致性 $p_{e}$ ，从而使 $\kappa$ 下降。</p>
<p>如下图所示，当标注员之间的一致性 $p_{o}$ 相同，且标注员 $A$ 的标签分布为（60%-Yes，40%-No）保持不变时，标注员 $B$ 的标签分布由（70%-Yes，30%-No）变为（30%-Yes，70%-No），这种与 $A$ 趋于相反的标签分布变化反而提升了 $\kappa$ 的值，这是显然违背直觉的。</p>
<p><img src="https://pic1.zhimg.com/v2-87a6995cec5adfe0d6a95877d9652738_b.jpg"></p>
<h2 id="3-Scott-39-s-Pi"><a href="#3-Scott-39-s-Pi" class="headerlink" title="3. Scott&#39;s Pi"></a>3. Scott&#39;s Pi</h2><p>为了优化<strong>Cohen&#39;s Kappa</strong>的上述问题，采用不同策略计算 $p_{e}$ 。如下式所示，通过标签的联合边缘分布来估计随机一致性，也可以说<strong>Scott&#39;s Pi</strong>是算数平均值的平方，而<strong>Cohen&#39;s Kappa</strong>是几何平均值的平方。</p>
<p>$$<br>p_{e}=\sum_{k}^{}{(\frac{n_{k1}+n_{k2}}{N})^{2}}\<br>$$</p>
<h3 id="3-1-举例"><a href="#3-1-举例" class="headerlink" title="3.1 举例"></a>3.1 举例</h3><p>假设有 $A$ 和 $B$ 两位标注员对 45 条数据进行分类，分为 $Yes$ 、 $No$ 和 $Maybe$ 三类，下图为标注结果矩阵：</p>
<p><img src="https://pic4.zhimg.com/v2-4d3eeefe6bbd22fe3923ee2dd9a7bcdb_b.jpg"></p>
<p>Marginal Sum 为标签的边缘分布</p>
<p><img src="https://pic1.zhimg.com/v2-6699e04d6ad505e0279ed3dd9027e85c_b.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-6699e04d6ad505e0279ed3dd9027e85c_720w.webp"></p>
<p>Joint Proportion(JP) 为联合边缘分布，Squared 对其求平方</p>
<p>标注一致性 $p_{o}$ ：</p>
<p>$$<br>p_{o}=\frac{1+5+9}{45}=0.333\<br>$$</p>
<p><strong>Kappa</strong>（ $\kappa$ ）：</p>
<p>$$<br>\kappa=\frac{p_{o}-p_{e}}{1-p_{e}}=\frac{0.333-0.369}{1-0.369}=-0.057\<br>$$</p>
<h3 id="3-2-问题"><a href="#3-2-问题" class="headerlink" title="3.2 问题"></a>3.2 问题</h3><p><strong>Cohen&#39;s Kappa</strong>和<strong>Scott&#39;s Pi</strong>只能评估两位标注员之间的一致性，无法拓展到多位标注员。</p>
<h2 id="4-Fleiss-39-Kappa"><a href="#4-Fleiss-39-Kappa" class="headerlink" title="4. Fleiss&#39; Kappa"></a>4. Fleiss&#39; Kappa</h2><p>对<strong>Scott&#39;s Pi</strong>进行泛化，可以评估多位标注员之间的标注一致性。假设有 $N$ 条数据进行多分类任务，每条数据被标注了 $n$ 次， $k$ 为类别数量。标注数据的索引为 $i=1,2,...,N$ ，类别的索引为 $j=1,2,...k$ ，那么令 $n_{ij}$ 表示将第 $i$ 条数据被标注为类别 $j$ 的次数。</p>
<p>随机一致性 $p_{e}$ 的评估方法与<strong>Scott&#39;s Pi</strong>相同， $p_{j}$ 是类别 $j$ 的联合边缘分布：</p>
<p>$$<br>p_{j}=\frac{1}{Nn}\sum_{i=1}^{N}{n_{ij}}\<br>$$</p>
<p>$$<br>p_{e}=\sum_{j=1}^{k}{p_{j}^{2}}\<br>$$</p>
<p>标注一致性 $p_{o}$ 是每条数据的一致性 $p_{i}$ 的均值：</p>
<p>$$<br>p_{i}=\frac{1}{n(n-1)}\sum_{j=1}^{k}{n_{ij}(n_{ij}-1)}\<br>$$</p>
<p>已知第 $i$ 条数据被标注 $n$ 次，任取一位标注员，则有 $n-1$ 位其他标注员与该位标注员的标注结果一致或不一致，因此 $n(n-1)$ 代表所有标注对（Annotation Pairs）的数量。同理，对于类别 $j$ 来说，有 $n_{ij}(n_{ij}-1)$ 个一致的标注对。 $p_{i}$ 是各类别一致的标注对占所有标注对的百分比，化简后有：</p>
<p>$$<br>p_{i}=\frac{1}{n(n-1)}[(\sum_{j=1}^{k}{n_{ij}^{2})-n}]\<br>$$</p>
<p>$$<br>p_{o}=\frac{1}{N}\sum_{i=1}^{N}{p_{i}}\<br>$$</p>
<h3 id="4-1-举例"><a href="#4-1-举例" class="headerlink" title="4.1 举例"></a>4.1 举例</h3><p>假设有 14 $(n)$ 位标注员对 10 $(N)$ 条数据进行类别数量为 5 $(k)$ 的多分类标注，如下图所示：行（Rows）为数据索引 $i$ ，列（Columns）为类别索引 $j$ ，单元格的值为 $n_{ij}$（标注次数）。</p>
<p><img src="https://pic2.zhimg.com/v2-a0d0d8cc84a8d286ad79c4308f4174e1_b.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-a0d0d8cc84a8d286ad79c4308f4174e1_720w.webp"></p>
<p>随机一致性 $p_{e}$，在计算 $p_{j}$ 时以 $p_{1}$ 为例：</p>
<p>$$<br>p_{j=1}=\frac{0+0+0+0+2+7+3+2+6+0}{140}=0.143\<br>$$</p>
<p>$$<br>p_{e}=0.143^{2}+0.200^{2}+0.279^{2}+0.150^{2}+0.229^{2}=0.213\<br>$$</p>
<p>标注一致性 $p_{o}$ ，在计算 $p_{i}$ 时以 $p_{2}$ 为例：</p>
<p>$$<br>p_{i=2}=\frac{1}{14(14-1)}(0^{2}+2^{2}+6^{2}+4^{2}+2^{2}-14)=0.253\<br>$$</p>
<p>$$<br>p_{o}=\frac{1}{N}\sum_{i=1}^{N}{p_{i}=}\frac{1}{10}(1.000+0.253+...+0.286)=0.378\<br>$$</p>
<p><strong>Kappa</strong>（ $\kappa$ ）：</p>
<p>$$<br>\kappa=\frac{p_{o}-p_{e}}{1-p_{e}}=\frac{0.378-0.213}{1-0.213}=0.210\<br>$$</p>
<h3 id="4-2-分析"><a href="#4-2-分析" class="headerlink" title="4.2 分析"></a>4.2 分析</h3><p>最后一个问题： $\kappa$ 的取值应该如何理解？下图是从主观和经验上对 $\kappa$ 取值的解释，通常认为当 $\kappa&gt;0.8$ 时，标注员之间有几乎完美的一致性。$\kappa$ 越趋近于 1，意味着标注一致性越高。</p>
<p><img src="https://pic3.zhimg.com/v2-b4cf93b362710f29c8650ac3fefd3422_b.jpg"></p>
<h2 id="5-在信息抽取中的应用"><a href="#5-在信息抽取中的应用" class="headerlink" title="5. 在信息抽取中的应用"></a>5. 在信息抽取中的应用</h2><p>以实体识别为例，虽然实体识别是一个序列标注问题，但我们可以将该任务视为对每个 token 的多分类任务。使用<strong>Fleiss&#39; Kappa</strong>评估一致性时，最关键的步骤是构建如 4.1 节所示的：对象-类别矩阵（Objects-Categories Matrix）。在实体识别中，标注对象可以理解为 token，回到本文最初例举的标注案例：</p>
<p><img src="https://pic2.zhimg.com/v2-3e8a02498e6ed9320fc9b739ab531b11_b.jpg"></p>
<p>其标注结果矩阵为：</p>
<p><img src="https://pic1.zhimg.com/v2-2c5d4f26825b10b8f3face99ba28ee2c_b.jpg"></p>
<p>在真实场景中，实体识别任务通常有大量的非实体（被标注为&#39;O&#39;的 token）。这会导致标签的不平衡情况，因此我们可以进一步忽略那些被所有标注员标注为&#39;O&#39;的 token。</p>
<p>如何对嵌套的实体标注进行一致性评估呢？我们可以以连续片段（Span）为标注对象。假设句子的长度为 $n$ ，那么该序列有 $n(n+1)/2$ 个待标注的候选片段，去除大量的非实体片段（负样本）后，其构建的标注结果矩阵如下：</p>
<p><img src="https://pic2.zhimg.com/v2-dee8c73b5c7fd0a09cce47ad19a1dfdd_b.jpg"></p>
<hr>
<p>原文出处：<a href="https://zhuanlan.zhihu.com/p/547781481">如何评价数据标注中的一致性？以信息抽取为例，浅谈 Fleiss&#39; Kappa - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>转载</category>
        <category>知乎</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>知乎</tag>
      </tags>
  </entry>
</search>
